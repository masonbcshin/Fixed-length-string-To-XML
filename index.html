<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>통전문 파서</title>
    <style>
        /**
         * =====================================================
         * 통전문 파서 스타일시트
         * =====================================================
         * 주요 기능:
         * 1. XML 파싱 탭 - XML 규격 기반 통전문 파싱
         * 2. C 구조체 파싱 탭 - C 구조체 기반 파싱
         * 
         * UX 기능:
         * - 구조체 카드 접기/펼치기 (▼ ↔ ▶)
         * - 드래그 앤 드롭 카드 재정렬
         * - 로컬 스토리지 자동 저장/복원
         * - 다크모드 지원
         * - 키보드 단축키 (Ctrl+Enter, Ctrl+N)
         * =====================================================
         */

        /* =====================================================
         * 기본 레이아웃 스타일
         * ===================================================== */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        /* 입력 영역 */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
            color: #333;
            background: white;
        }

        textarea::placeholder {
            color: #999;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
            color: #333;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* =====================================================
         * 결과 표시 영역
         * ===================================================== */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* 테이블 스타일 */
        #result-table, .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td,
        .result-table th, .result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th, .result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even),
        .result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover,
        .result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7),
        .result-table td:last-child {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* 반응형 테이블 래퍼 */
        .table-wrapper {
            overflow-x: auto;
        }

        /* 버튼 그룹 */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #struct-test-btn {
            background: #17a2b8;
            margin-right: 10px;
        }

        #struct-test-btn:hover {
            background: #138496;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* 에러 메시지 스타일 */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* 파싱 에러 스타일 */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* =====================================================
         * 탭 네비게이션 스타일
         * ===================================================== */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            color: #333;
            font-size: 15px;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            background: #e0e0e0;
            color: #007bff;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 구조체 결과 그룹 스타일 */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* 구조체 요약 정보 스타일 */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* 복사 버튼 스타일 */
        .copy-result-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .copy-result-btn:hover {
            background: #1e7e34;
        }

        /* =====================================================
         * 도움말 섹션 (접기/펼치기)
         * ===================================================== */
        .help-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .help-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-toggle:hover {
            background: #dee2e6;
        }

        .help-toggle-icon {
            transition: transform 0.3s ease;
        }

        .help-toggle.expanded .help-toggle-icon {
            transform: rotate(180deg);
        }

        .help-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .help-content.expanded {
            padding: 16px;
            max-height: 1200px;
        }
        
        /* 디버그 가이드 스타일 */
        .debug-guide {
            background: #e8f4fc;
            border: 1px solid #b8daff;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .debug-guide h5 {
            margin: 0 0 10px 0;
            color: #004085;
            font-size: 13px;
            border-bottom: 1px solid #b8daff;
            padding-bottom: 5px;
        }
        
        .debug-guide h5:not(:first-child) {
            margin-top: 15px;
        }
        
        .debug-guide ol,
        .debug-guide ul {
            margin: 5px 0 10px 0;
            padding-left: 20px;
        }
        
        .debug-guide li {
            margin: 4px 0;
            font-size: 12px;
            color: #495057;
        }
        
        .debug-guide kbd {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            padding: 2px 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .help-content h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .help-content p {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        .help-content ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }

        .help-content li {
            margin: 5px 0;
            color: #666;
            font-size: 13px;
        }

        .help-content code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .help-content pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin: 10px 0;
        }

        /* 테스트 버튼 스타일 */
        #run-tests-btn {
            background: #6f42c1;
            margin-left: auto;
        }

        #run-tests-btn:hover {
            background: #5a32a3;
        }

        /* 테스트 결과 스타일 */
        .test-results {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .test-results.success {
            background: #d4edda;
            border: 1px solid #28a745;
        }

        .test-results.failure {
            background: #f8d7da;
            border: 1px solid #dc3545;
        }

        .test-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-pass {
            color: #28a745;
        }

        .test-fail {
            color: #dc3545;
        }

        /* 섹션 헤더 스타일 */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        .header-options {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .option-checkbox {
            background: #e7f3ff;
            padding: 8px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #004085;
        }

        .option-checkbox:hover {
            background: #cce5ff;
        }

        .option-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .option-description {
            background: #f8f9fa;
            padding: 10px 15px;
            border-left: 4px solid #6c757d;
            margin-bottom: 15px;
            color: #495057;
        }

        .option-description small {
            font-size: 13px;
            line-height: 1.6;
        }

        /* =====================================================
         * 서브 탭 네비게이션 (파싱/생성 모드)
         * ===================================================== */
        .sub-tab-nav {
            display: flex;
            gap: 10px;
            margin-top: 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
        }

        .sub-tab-btn {
            padding: 12px 24px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s;
            color: #495057;
        }

        .sub-tab-btn:hover {
            background: #e9ecef;
            color: #007bff;
        }

        .sub-tab-btn.active {
            background: white;
            border-bottom: 3px solid white;
            font-weight: bold;
            color: #007bff;
            position: relative;
            bottom: -2px;
        }

        .sub-mode-content {
            display: none;
            padding: 20px 0;
        }

        .sub-mode-content.active {
            display: block;
        }

        /* =====================================================
         * 전문 생성 모드 스타일
         * ===================================================== */
        .generate-intro {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .generate-intro h4 {
            margin: 0 0 8px 0;
            font-size: 20px;
        }

        .generate-intro p {
            margin: 0;
            opacity: 0.95;
            font-size: 14px;
        }

        .struct-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 25px;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }

        .struct-selector label {
            font-weight: bold;
            min-width: 140px;
            color: #495057;
        }

        .form-select {
            flex: 1;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .form-select:focus {
            border-color: #007bff;
            outline: none;
        }

        .primary-btn {
            padding: 10px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .primary-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .primary-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .secondary-btn {
            padding: 10px 24px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .secondary-btn:hover {
            background: #5a6268;
        }

        .danger-btn {
            padding: 10px 24px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .danger-btn:hover {
            background: #c82333;
        }

        /* =====================================================
         * 전문 생성 폼 스타일
         * ===================================================== */
        .generate-form-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .generate-form-header h5 {
            margin: 0;
            font-size: 16px;
        }

        .generate-form-header .struct-info {
            font-size: 13px;
            opacity: 0.9;
        }

        .generate-fields-form {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .generate-field-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .generate-field-row:last-child {
            margin-bottom: 0;
        }

        .generate-field-row label {
            min-width: 180px;
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }

        .generate-field-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        .generate-field-input:focus {
            border-color: #17a2b8;
            outline: none;
        }

        .generate-field-input:disabled {
            background: #e9ecef;
            color: #6c757d;
        }

        .field-counter {
            min-width: 60px;
            text-align: right;
            font-size: 12px;
            color: #6c757d;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .field-counter.over {
            color: #dc3545;
            font-weight: bold;
        }

        .generate-form-actions {
            display: flex;
            gap: 12px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }

        /* 생성된 레코드 목록 스타일 */
        #generated-records-area {
            margin-top: 25px;
        }

        .generated-records-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: #28a745;
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .generated-records-header h5 {
            margin: 0;
            flex: 1;
        }

        .generated-records-header button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .generated-record-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
        }

        .generated-record-item:last-child {
            border-radius: 0 0 8px 8px;
        }

        .record-info {
            min-width: 150px;
            font-weight: 500;
            color: #495057;
            font-size: 13px;
        }

        .generated-record-content {
            flex: 1;
            padding: 8px 12px;
            background: #f1f3f4;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            word-break: break-all;
            color: #212529;
        }

        .delete-record-btn {
            padding: 6px 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-record-btn:hover {
            background: #c82333;
        }

        /* 레코드 아이템 개선 스타일 */
        .record-item {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
        }

        .record-item .record-info {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .record-number {
            display: inline-block;
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .record-struct-name {
            font-weight: 600;
            color: #212529;
        }

        .record-length {
            color: #6c757d;
            font-size: 12px;
        }

        .record-timestamp {
            color: #adb5bd;
            font-size: 11px;
        }

        .record-telegram {
            flex: 1;
            min-width: 200px;
        }

        .record-btn-group {
            display: flex;
            gap: 6px;
        }

        .toggle-details-btn {
            padding: 6px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .toggle-details-btn:hover {
            background: #5a6268;
        }

        .record-field-details {
            width: 100%;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #dee2e6;
        }

        .field-details-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .field-details-table th,
        .field-details-table td {
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            text-align: left;
        }

        .field-details-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .field-details-table td code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }

        /* =====================================================
         * 생성된 레코드 목록 (새 디자인)
         * ===================================================== */
        .records-header {
            background: #f8f9fa;
            padding: 20px;
            border: 2px solid #dee2e6;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-left h4 {
            margin: 0;
            color: #495057;
        }

        .record-count-badge {
            background: #007bff;
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .header-right {
            display: flex;
            gap: 10px;
        }

        .export-btn,
        .clear-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .export-btn {
            background: #28a745;
            color: white;
        }

        .export-btn:hover {
            background: #218838;
        }

        .clear-btn {
            background: #dc3545;
            color: white;
        }

        .clear-btn:hover {
            background: #c82333;
        }

        .records-list {
            background: #fff;
            border: 2px solid #dee2e6;
            border-top: none;
            padding: 15px;
            max-height: 600px;
            overflow-y: auto;
        }

        #generated-records-area .record-item {
            display: block;
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: all 0.2s;
            padding: 0;
        }

        #generated-records-area .record-item:hover {
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
            transform: translateY(-2px);
        }

        .record-item-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .record-meta {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #generated-records-area .record-item .record-number {
            background: rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 15px;
            color: white;
        }

        #generated-records-area .record-item .record-struct-name {
            font-weight: bold;
            font-size: 16px;
            color: white;
        }

        #generated-records-area .record-item .record-timestamp {
            opacity: 0.9;
            font-size: 13px;
            color: white;
        }

        .record-actions {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .record-item-body {
            padding: 20px;
        }

        .telegram-box {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }

        .telegram-text {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #495057;
            overflow-x: auto;
            white-space: pre;
        }

        .record-stats {
            margin-top: 12px;
            display: flex;
            gap: 20px;
        }

        .stat-item {
            font-size: 14px;
        }

        .stat-label {
            color: #6c757d;
            margin-left: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #495057;
        }

        .record-detail {
            padding: 20px;
            background: #f0f8ff;
            border-top: 2px solid #007bff;
        }

        .detail-table {
            width: 100%;
            border-collapse: collapse;
        }

        .detail-table th,
        .detail-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .detail-table th {
            background: #e7f3ff;
            font-weight: bold;
        }

        .detail-table code {
            background: #fff;
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            font-family: monospace;
        }

        /* =====================================================
         * 전문 생성 폼 (새 디자인)
         * ===================================================== */
        .generate-form {
            background: white;
            border: 2px solid #007bff;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .form-header {
            background: #e7f3ff;
            padding: 20px;
            border-bottom: 2px solid #007bff;
        }

        .form-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .form-title h4 {
            margin: 0;
            color: #004085;
        }

        .form-badge {
            background: #007bff;
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
        }

        .form-info {
            margin-top: 8px;
            color: #004085;
            opacity: 0.8;
        }

        .input-form-table {
            width: 100%;
            border-collapse: collapse;
        }

        .input-form-table th {
            background: #f8f9fa;
            padding: 14px;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #dee2e6;
        }

        .input-form-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }

        .input-form-table .field-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            box-sizing: border-box;
        }

        .input-form-table .field-input:focus {
            border-color: #007bff;
            outline: none;
        }

        .input-form-table .field-input:disabled {
            background: #e9ecef;
            color: #6c757d;
        }

        .input-form-table .field-preview {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: #6c757d;
            word-break: break-all;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .input-form-table .field-preview.filled {
            color: #28a745;
            font-weight: 500;
        }

        .input-form-table .field-preview.padded {
            color: #007bff;
        }

        .input-form-table .field-preview.over {
            color: #dc3545;
            font-weight: bold;
        }

        /* =====================================================
         * 필드 행 스타일 (createFieldRow)
         * ===================================================== */
        .field-name {
            font-weight: bold;
            color: #495057;
        }

        .field-tag {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
            font-weight: bold;
        }

        .auto-tag {
            background: #6c757d;
            color: white;
        }

        .ksc-tag {
            background: #fd7e14;
            color: white;
        }

        /* KSC 필드 바이트 초과 경고 */
        .field-input.over-limit {
            border-color: #dc3545;
            background-color: #fff5f5;
        }

        .char-counter.over-limit {
            color: #dc3545;
            font-weight: bold;
        }

        .numeric-tag {
            background: #ffc107;
            color: #000;
        }

        /* cd/code 필드용 타입 토글 스타일 */
        .type-toggle-label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            background: #e9ecef;
            color: #6c757d;
            border: 1px solid #ced4da;
            margin-left: 6px;
            transition: all 0.2s ease;
            user-select: none;
        }

        .type-toggle-label:hover {
            background: #dee2e6;
            border-color: #adb5bd;
        }

        .type-toggle-checkbox {
            width: 14px;
            height: 14px;
            margin: 0;
            cursor: pointer;
            accent-color: #ffc107;
        }

        .type-toggle-checkbox:checked + .type-toggle-text {
            color: #856404;
            font-weight: bold;
        }

        .type-toggle-label:has(.type-toggle-checkbox:checked) {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .type-toggle-text {
            font-weight: normal;
            transition: all 0.2s ease;
        }

        /* 다크모드 타입 토글 */
        body.dark-mode .type-toggle-label {
            background: #374151;
            color: #9ca3af;
            border-color: #4b5563;
        }

        body.dark-mode .type-toggle-label:hover {
            background: #4b5563;
            border-color: #6b7280;
        }

        body.dark-mode .type-toggle-label:has(.type-toggle-checkbox:checked) {
            background: #78350f;
            border-color: #ffc107;
            color: #fcd34d;
        }

        body.dark-mode .type-toggle-checkbox:checked + .type-toggle-text {
            color: #fcd34d;
        }

        .type-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .type-badge.numeric-type {
            background: #ffc107;
            color: #000;
        }

        .type-badge.string-type {
            background: #17a2b8;
            color: white;
        }

        .type-badge.type-X {
            background: #17a2b8;
            color: white;
        }

        .type-badge.type-N {
            background: #ffc107;
            color: #000;
        }

        .type-badge.type-A {
            background: #28a745;
            color: white;
        }

        .type-badge.type-FULL {
            background: #6f42c1;
            color: white;
        }

        /* 결과 테이블 타입 배지 */
        .type-badge.ksc-badge {
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
            background: linear-gradient(135deg, #fd7e14 0%, #dc3545 100%);
            color: white;
        }

        .type-badge.ascii-badge {
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
            background: #6c757d;
            color: white;
        }

        .type-badge.crlf-badge {
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
            color: white;
            box-shadow: 0 1px 3px rgba(156, 39, 176, 0.3);
        }

        /* 디코딩 모드 드롭다운 */
        .decoding-mode-select {
            padding: 6px 10px;
            font-size: 13px;
            font-weight: 600;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            background: white;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 100px;
        }

        .decoding-mode-select:hover {
            border-color: #17a2b8;
        }

        .decoding-mode-select:focus {
            outline: none;
            border-color: #17a2b8;
            box-shadow: 0 0 0 3px rgba(23, 162, 184, 0.2);
        }

        /* KSC 모드 선택 시 강조 */
        .decoding-mode-select.ksc-active {
            border-color: #fd7e14;
            background: linear-gradient(135deg, #fff5eb 0%, #ffe8d6 100%);
            color: #c23600;
            font-weight: 700;
        }

        /* 값이 변경되었을 때 표시 */
        .decoding-mode-select.value-changed {
            animation: pulse-highlight 0.5s ease;
        }

        @keyframes pulse-highlight {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* 원본 HEX 보기 버튼 */
        .show-raw-btn {
            padding: 5px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .show-raw-btn:hover {
            background: #5a6268;
        }

        /* KSC-5601 입력기 버튼 */
        .ksc-input-btn {
            padding: 5px 10px;
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 8px;
            transition: all 0.2s;
        }

        .ksc-input-btn:hover {
            background: linear-gradient(135deg, #ab47bc 0%, #8e24aa 100%);
            transform: scale(1.05);
        }

        /* 값 셀 스타일 */
        .field-value-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .field-value-cell .editable-value {
            flex: 1;
            min-width: 0;
        }

        .field-type-cell {
            text-align: center;
        }

        .field-size {
            color: #6c757d;
            text-align: center;
        }

        .input-form-table .field-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            transition: border 0.2s;
            box-sizing: border-box;
        }

        .input-form-table .field-input:focus {
            border-color: #007bff;
            outline: none;
            background: #f0f8ff;
        }

        .input-form-table .field-input.auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        .input-meta {
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
        }

        .char-counter {
            font-size: 12px;
            color: #6c757d;
        }

        .current-length {
            font-weight: bold;
        }

        .preview-cell {
            background: #f8f9fa;
        }

        .preview-text {
            display: block;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #495057;
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            overflow-x: auto;
            white-space: pre;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            padding: 20px;
            background: #f8f9fa;
        }

        .form-actions .btn-info {
            background: #17a2b8;
            flex: 1;
        }

        .form-actions .btn-info:hover {
            background: #138496;
        }

        .form-actions .btn-success {
            background: #28a745;
            flex: 1;
        }

        .form-actions .btn-success:hover {
            background: #218838;
        }

        .form-actions .btn-secondary {
            background: #6c757d;
            flex: 1;
        }

        .form-actions .btn-secondary:hover {
            background: #5a6268;
        }

        .form-actions button {
            padding: 12px;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .form-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .preview-box {
            margin-top: 20px;
            border-top: 3px solid #17a2b8;
        }

        .preview-box h5 {
            margin: 0 0 15px 0;
            color: #495057;
        }

        .preview-box .telegram-preview-content {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            word-break: break-all;
            white-space: pre-wrap;
        }

        .preview-box .preview-info {
            margin-top: 10px;
            font-size: 13px;
            color: #6c757d;
        }

        .preview-success {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 20px;
        }

        .preview-error h5 {
            margin: 0 0 12px 0;
            color: #721c24;
        }

        .preview-error ul {
            margin: 0;
            padding-left: 20px;
            color: #721c24;
        }

        .preview-header {
            background: #17a2b8;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h5 {
            margin: 0;
            color: white;
        }

        .copy-preview-btn {
            background: white;
            color: #17a2b8;
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-preview-btn:hover {
            background: #f8f9fa;
            transform: translateY(-1px);
        }

        .preview-content {
            padding: 20px;
        }

        .telegram-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #0c5460;
            white-space: pre;
            margin: 0;
            overflow-x: auto;
        }

        .preview-info {
            background: #bee5eb;
            padding: 15px 20px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .preview-info .info-item {
            display: flex;
            gap: 8px;
        }

        .preview-info .info-label {
            font-weight: bold;
            color: #0c5460;
        }

        .preview-info .info-value {
            color: #0c5460;
        }

        .preview-info .hex-value {
            font-family: monospace;
            font-size: 13px;
        }

        /* =====================================================
         * 구조체 정의 영역
         * ===================================================== */
        #add-struct-btn {
            padding: 10px 20px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        #add-struct-btn:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        /* 전체 접기/펼치기 버튼 */
        .toggle-all-btn {
            padding: 10px 18px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .toggle-all-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }

        .toggle-all-btn .toggle-icon {
            font-size: 11px;
            transition: transform 0.3s ease;
        }

        .toggle-all-btn.all-collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        /* 구조체 정의 컨테이너 스타일 */
        #struct-definitions-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* 구조체 카드 스타일 */
        .struct-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        /* 드래그 앤 드롭 스타일 */
        .struct-card[draggable="true"] {
            cursor: grab;
        }

        .struct-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .struct-card.drag-over {
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        .struct-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .struct-card-header:hover {
            background: rgba(0, 0, 0, 0.02);
            margin: -5px -5px 10px -5px;
            padding: 5px 5px 15px 5px;
            border-radius: 5px 5px 0 0;
        }

        .struct-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapse-icon {
            font-size: 12px;
            color: #6c757d;
            transition: transform 0.3s ease;
            width: 16px;
            text-align: center;
        }

        .struct-card.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .struct-number {
            font-weight: bold;
            color: #495057;
            font-size: 16px;
        }

        /* 접힌 상태의 구조체명 미리보기 */
        .struct-preview {
            font-size: 14px;
            color: #6c757d;
            margin-left: 10px;
            font-style: italic;
        }

        .struct-card-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drag-handle {
            cursor: grab;
            color: #adb5bd;
            font-size: 18px;
            padding: 4px 8px;
        }

        .drag-handle:hover {
            color: #6c757d;
        }

        .remove-struct-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .remove-struct-btn:hover {
            background: #c82333;
        }

        /* 카드 본문 접기/펼치기 */
        .struct-card-body {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 1;
        }

        .struct-card.collapsed .struct-card-body {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .struct-card-body .input-row {
            margin-bottom: 12px;
        }

        .struct-card-body .input-row label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .struct-card-body .input-row input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .struct-card-body .input-row small {
            color: #6c757d;
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }

        .struct-card-body .input-row textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* KSC-5601 힌트 섹션 스타일 */
        .ksc-hint-section {
            margin-top: 15px;
        }

        .ksc-hint {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 14px 18px;
            background: linear-gradient(135deg, #e8f4fd 0%, #d6eaf8 100%);
            border: 1px solid #3498db;
            border-radius: 8px;
            font-size: 13px;
            color: #2c3e50;
        }

        .ksc-hint .hint-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .ksc-hint .hint-text {
            flex: 1;
            line-height: 1.5;
        }

        .ksc-hint .hint-text strong {
            color: #1a5276;
        }

        .ksc-hint .hint-text em {
            font-style: normal;
            color: #2980b9;
            font-weight: 600;
        }

        .ksc-hint .hint-text code {
            background: rgba(52, 152, 219, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            color: #1a5276;
        }

        .ksc-hint .help-icon-btn {
            background: #3498db;
            flex-shrink: 0;
        }

        .ksc-hint .help-icon-btn:hover {
            background: #2980b9;
        }

        .ksc-hint .help-icon {
            color: white;
        }

        .help-icon-btn {
            background: #ffc107;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .help-icon-btn:hover {
            background: #e0a800;
            transform: scale(1.1);
        }

        .help-icon {
            color: #000;
            font-weight: bold;
            font-size: 16px;
        }

        .ksc-notice {
            background: white;
            padding: 15px;
            border: 2px solid #ffc107;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
        }

        .notice-icon {
            font-size: 24px;
            line-height: 1;
        }

        .notice-text {
            flex: 1;
        }

        .notice-text strong {
            color: #856404;
            display: block;
            margin-bottom: 4px;
        }

        .notice-text small {
            color: #856404;
            opacity: 0.8;
        }

        .encoding-mode-selector {
            margin-bottom: 20px;
        }

        .mode-label {
            display: block;
            font-weight: bold;
            color: #856404;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .mode-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .mode-option {
            background: white;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            gap: 12px;
        }

        .mode-option:hover {
            border-color: #ffc107;
            box-shadow: 0 2px 8px rgba(255,193,7,0.2);
        }

        .mode-option:has(.mode-radio:checked) {
            background: #fff3cd;
            border-color: #ffc107;
            border-width: 2px;
        }

        .mode-radio {
            width: 20px;
            height: 20px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .mode-content {
            flex: 1;
        }

        .mode-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-icon {
            font-size: 18px;
        }

        .mode-desc {
            color: #6c757d;
            font-size: 13px;
            line-height: 1.4;
        }

        .ksc-fields-container {
            background: white;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
        }

        .fields-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid #dee2e6;
        }

        .fields-header span {
            font-weight: bold;
            color: #495057;
        }

        .parse-for-ksc-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .parse-for-ksc-btn:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        .ksc-fields-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .ksc-fields-list .no-fields-msg {
            text-align: center;
            color: #6c757d;
            padding: 30px;
            font-style: italic;
            margin: 0;
        }

        /* KSC 필드 체크박스 스타일 */
        .ksc-field-item {
            margin-bottom: 10px;
        }

        .ksc-field-label {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ksc-field-label:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .ksc-field-label.checked {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .ksc-field-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .field-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            margin-left: 12px;
        }

        .field-name {
            font-weight: bold;
            color: #495057;
            font-family: 'Courier New', monospace;
        }

        .field-size-badge {
            background: #6c757d;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .auto-badge {
            background: #28a745;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .ksc-checkbox-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #dee2e6;
        }

        .control-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: #f8f9fa;
        }

        .control-btn.select-all:hover {
            background: #d4edda;
            border-color: #28a745;
        }

        .control-btn.deselect-all:hover {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .reparse-ksc-btn {
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
        }

        .reparse-ksc-btn:hover {
            background: #5a6268;
        }

        .no-valid-fields {
            text-align: center;
            color: #dc3545;
            padding: 30px;
            font-style: italic;
            margin: 0;
        }

        /* 로컬 스토리지 복원 알림 스타일 */
        .restore-notification {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .restore-notification-text {
            color: #1565c0;
            font-size: 14px;
        }

        .restore-notification-actions {
            display: flex;
            gap: 10px;
        }

        .restore-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .restore-btn.primary {
            background: #1976d2;
            color: white;
        }

        .restore-btn.primary:hover {
            background: #1565c0;
        }

        .restore-btn.secondary {
            background: #e0e0e0;
            color: #424242;
        }

        .restore-btn.secondary:hover {
            background: #bdbdbd;
        }

        /* 단축키 힌트 스타일 */
        .shortcut-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.85);
            margin-left: 6px;
            background: rgba(0, 0, 0, 0.15);
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* 버튼 외부에서 사용될 때 */
        label .shortcut-hint,
        span:not([class]) .shortcut-hint {
            color: #6c757d;
            background: rgba(0, 0, 0, 0.05);
        }

        /* 다크모드 토글 버튼 */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: #e0e0e0;
        }

        /* 파싱 설정 정보 스타일 */
        .parse-settings-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .parse-settings-info h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 15px;
        }

        .setting-item {
            display: flex;
            margin-bottom: 8px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-weight: bold;
            width: 150px;
        }

        .setting-value {
            padding: 4px 10px;
            border-radius: 4px;
        }

        .setting-value.enabled {
            background: #d4edda;
            color: #155724;
        }

        .setting-value.disabled {
            background: #f8d7da;
            color: #721c24;
        }

        .setting-value.mode-line-by-line {
            background: #d1ecf1;
            color: #0c5460;
        }

        .setting-value.mode-continuous {
            background: #d4edda;
            color: #155724;
        }

        .setting-value.encoding-ascii {
            background: #e2e3e5;
            color: #383d41;
        }

        .setting-value.encoding-ksc5601 {
            background: #f3e5f5;
            color: #7b1fa2;
            font-weight: bold;
        }

        .setting-value.encoding-unicode {
            background: #e3f2fd;
            color: #1565c0;
        }

        /* 파싱 통계 스타일 */
        .parse-stats {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .parse-stats h3 {
            margin: 0 0 12px 0;
            color: #1565c0;
            font-size: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stats-grid > div {
            background: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }

        /* 에러 레코드 카드 스타일 */
        .error-record-card {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .error-record-card .error-header {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            font-weight: bold;
            align-items: center;
        }

        .error-record-card .error-icon {
            font-size: 24px;
        }

        .error-record-card .error-title {
            color: #856404;
            font-size: 16px;
        }

        .error-record-card .error-body .error-message {
            color: #856404;
            margin: 0 0 10px 0;
        }

        .error-record-card .error-data {
            background: #fff;
            padding: 10px;
            border: 1px solid #ffc107;
            font-family: monospace;
            overflow-x: auto;
            border-radius: 4px;
            margin: 0 0 10px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .error-record-card .error-info {
            color: #856404;
            font-size: 12px;
        }

        /* 레코드 헤더 스타일 */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        /* 구분값 배지 스타일 */
        .kubun-badge {
            background: #6610f2;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }

        /* 길이 검증 뱃지 스타일 */
        .length-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
        }

        .length-badge.success {
            background: #d4edda;
            color: #155724;
        }

        .length-badge.warning {
            background: #fff3cd;
            color: #856404;
        }

        .length-badge.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* 레코드 복사 버튼 스타일 */
        .copy-record-btn {
            padding: 8px 14px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .copy-record-btn:hover {
            background: #1e7e34;
            transform: translateY(-1px);
        }

        /* 자동 설정 필드 스타일 (CRLF 등) */
        .auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        /* CRLF 필드 값 표시 스타일 */
        .crlf-value {
            background: #f3e5f5 !important;
            font-family: 'Courier New', monospace;
            color: #7b1fa2;
            font-weight: bold;
        }

        /* 신규 레코드 폼 필드 입력 스타일 */
        .new-field-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .new-field-input:focus {
            border-color: #80bdff;
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        /* 미리보기 셀 스타일 */
        .preview-cell {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            color: #495057;
        }

        /* 모바일 대응 */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .record-header {
                flex-wrap: wrap;
                gap: 8px;
            }

            .theme-toggle {
                top: 10px;
                right: 10px;
                width: 35px;
                height: 35px;
            }
        }

        /* =====================================================
         * 다크모드 스타일
         * ===================================================== */
        body.dark-mode {
            background-color: #1a1a2e;
            color: #e0e0e0;
        }

        body.dark-mode h1 {
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn:hover {
            background: #3d3d5c;
            color: #64b5f6;
        }

        body.dark-mode .tab-btn.active {
            background: #1a1a2e;
            border-bottom-color: #1a1a2e;
            color: #64b5f6;
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"] {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode textarea::placeholder,
        body.dark-mode input::placeholder {
            color: #888;
        }

        body.dark-mode .struct-card {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .toggle-all-btn {
            background: #4a4a6a;
        }

        body.dark-mode .toggle-all-btn:hover {
            background: #5a5a7a;
        }

        body.dark-mode .struct-card-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .struct-number {
            color: #e0e0e0;
        }

        body.dark-mode .struct-preview {
            color: #aaa;
        }

        body.dark-mode .struct-card-body .input-row label {
            color: #e0e0e0;
        }

        body.dark-mode .struct-card-body .input-row small {
            color: #aaa;
        }

        /* 다크 모드 - KSC-5601 힌트 섹션 스타일 */
        body.dark-mode .ksc-hint {
            background: linear-gradient(135deg, #2d3a4a 0%, #1e3a5f 100%);
            border-color: #3498db;
            color: #b0c4de;
        }

        body.dark-mode .ksc-hint .hint-text strong {
            color: #5dade2;
        }

        body.dark-mode .ksc-hint .hint-text em {
            color: #85c1e9;
        }

        body.dark-mode .ksc-hint .hint-text code {
            background: rgba(52, 152, 219, 0.25);
            color: #85c1e9;
        }

        body.dark-mode .help-icon-btn {
            background: #b8860b;
        }

        body.dark-mode .help-icon-btn:hover {
            background: #d4a017;
        }

        body.dark-mode .ksc-notice {
            background: #2d2d44;
            border-color: #b8860b;
        }

        body.dark-mode .notice-text strong {
            color: #ffd54f;
        }

        body.dark-mode .notice-text small {
            color: #ffd54f;
        }

        body.dark-mode .mode-label {
            color: #ffd54f;
        }

        body.dark-mode .mode-option {
            background: #2d2d44;
            border-color: #4d4d6c;
        }

        body.dark-mode .mode-option:hover {
            border-color: #b8860b;
            box-shadow: 0 2px 8px rgba(184,134,11,0.3);
        }

        body.dark-mode .mode-option:has(.mode-radio:checked) {
            background: #3d3d2e;
            border-color: #b8860b;
        }

        body.dark-mode .mode-title {
            color: #e0e0e0;
        }

        body.dark-mode .mode-desc {
            color: #aaa;
        }

        body.dark-mode .ksc-fields-container {
            background: #2d2d44;
            border-color: #4d4d6c;
        }

        body.dark-mode .fields-header {
            border-bottom-color: #4d4d6c;
        }

        body.dark-mode .fields-header span {
            color: #e0e0e0;
        }

        body.dark-mode .parse-for-ksc-btn {
            background: #138496;
        }

        body.dark-mode .parse-for-ksc-btn:hover {
            background: #17a2b8;
        }

        body.dark-mode .ksc-fields-list .no-fields-msg {
            color: #aaa;
        }

        /* 다크 모드 - KSC 필드 체크박스 스타일 */
        body.dark-mode .ksc-field-label {
            background: #3d3d5c;
            border-color: #4d4d6c;
        }

        body.dark-mode .ksc-field-label:hover {
            background: #4d4d6c;
            border-color: #6d6d8c;
        }

        body.dark-mode .ksc-field-label.checked {
            background: #3d3d2e;
            border-color: #b8860b;
        }

        body.dark-mode .field-name {
            color: #e0e0e0;
        }

        body.dark-mode .field-size-badge {
            background: #5a6268;
        }

        body.dark-mode .ksc-checkbox-controls {
            border-top-color: #4d4d6c;
        }

        body.dark-mode .control-btn {
            background: #2d2d44;
            border-color: #4d4d6c;
            color: #e0e0e0;
        }

        body.dark-mode .control-btn:hover {
            background: #3d3d5c;
        }

        body.dark-mode .control-btn.select-all:hover {
            background: #1e4620;
            border-color: #28a745;
        }

        body.dark-mode .control-btn.deselect-all:hover {
            background: #4a1a1a;
            border-color: #dc3545;
        }

        body.dark-mode .reparse-ksc-btn {
            background: #5a6268;
        }

        body.dark-mode .reparse-ksc-btn:hover {
            background: #6c757d;
        }

        body.dark-mode .no-valid-fields {
            color: #ff6b6b;
        }

        /* 다크 모드 - KSC 필드 바이트 초과 경고 */
        body.dark-mode .field-input.over-limit {
            border-color: #dc3545;
            background-color: #4a1a1a;
        }

        body.dark-mode .char-counter.over-limit {
            color: #ff6b6b;
        }

        /* 다크 모드 - 결과 테이블 타입 배지 */
        body.dark-mode .type-badge.ascii-badge {
            background: #5a6268;
        }

        body.dark-mode .type-badge.crlf-badge {
            background: linear-gradient(135deg, #ab47bc 0%, #8e24aa 100%);
            color: white;
            box-shadow: 0 1px 3px rgba(171, 71, 188, 0.4);
        }

        /* 다크 모드 - 디코딩 모드 드롭다운 */
        body.dark-mode .decoding-mode-select {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .decoding-mode-select:hover {
            border-color: #17a2b8;
        }

        body.dark-mode .decoding-mode-select:focus {
            border-color: #17a2b8;
            box-shadow: 0 0 0 3px rgba(23, 162, 184, 0.3);
        }

        body.dark-mode .decoding-mode-select.ksc-active {
            border-color: #fd7e14;
            background: linear-gradient(135deg, #3d3d2e 0%, #4d3d2e 100%);
            color: #ffc078;
        }

        body.dark-mode .show-raw-btn {
            background: #5a6268;
        }

        body.dark-mode .show-raw-btn:hover {
            background: #6c757d;
        }

        body.dark-mode .ksc-input-btn {
            background: linear-gradient(135deg, #ab47bc 0%, #8e24aa 100%);
        }

        body.dark-mode .ksc-input-btn:hover {
            background: linear-gradient(135deg, #ba68c8 0%, #9c27b0 100%);
        }

        body.dark-mode .help-section {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .help-toggle {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .help-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .help-content {
            color: #ccc;
        }

        body.dark-mode .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-content p,
        body.dark-mode .help-content li {
            color: #bbb;
        }

        body.dark-mode .help-content code {
            background: #3d3d5c;
            color: #64b5f6;
        }

        body.dark-mode .help-content pre {
            background: #1a1a2e;
        }
        
        /* 다크모드 - 디버그 가이드 */
        body.dark-mode .debug-guide {
            background: #1e3a5f;
            border-color: #2d5a8f;
        }
        
        body.dark-mode .debug-guide h5 {
            color: #90caf9;
            border-color: #2d5a8f;
        }
        
        body.dark-mode .debug-guide li {
            color: #b0bec5;
        }
        
        body.dark-mode .debug-guide kbd {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table,
        body.dark-mode .result-table {
            border-color: #3d3d5c;
        }

        body.dark-mode #result-table th,
        body.dark-mode .result-table th {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table td,
        body.dark-mode .result-table td {
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table tr:nth-child(even),
        body.dark-mode .result-table tr:nth-child(even) {
            background: #252540;
        }

        body.dark-mode #result-table tr:hover,
        body.dark-mode .result-table tr:hover {
            background: #35355c;
        }

        body.dark-mode #result-table td:nth-child(7),
        body.dark-mode .result-table td:last-child {
            background: #2d2d44;
        }

        body.dark-mode .empty-value {
            background: #4a3030;
        }

        body.dark-mode .struct-result-group {
            border-color: #3d3d5c;
            background: #252540;
        }

        body.dark-mode .struct-result-group h3 {
            color: #e0e0e0;
        }

        body.dark-mode .record-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .record-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .length-badge.success {
            background: #1e4a2b;
            color: #90ee90;
        }

        body.dark-mode .length-badge.warning {
            background: #4a3d1e;
            color: #ffd700;
        }

        body.dark-mode .length-badge.error {
            background: #4a1e1e;
            color: #ff9090;
        }

        body.dark-mode .parse-settings-info {
            background: #2d2d3d;
            border-color: #4a4a5a;
        }

        body.dark-mode .parse-settings-info h4 {
            color: #b0b0c0;
        }

        body.dark-mode .setting-label {
            color: #e0e0e0;
        }

        body.dark-mode .setting-value.enabled {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .setting-value.disabled {
            background: #4a2020;
            color: #f5c6cb;
        }

        body.dark-mode .setting-value.mode-line-by-line {
            background: #1a3a4a;
            color: #8ecae6;
        }

        body.dark-mode .setting-value.mode-continuous {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .setting-value.encoding-ascii {
            background: #3a3a3a;
            color: #b0b0b0;
        }

        body.dark-mode .setting-value.encoding-ksc5601 {
            background: #4a1a5c;
            color: #e1bee7;
            font-weight: bold;
        }

        body.dark-mode .setting-value.encoding-unicode {
            background: #1a3a5c;
            color: #90caf9;
        }

        body.dark-mode .parse-stats {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .parse-stats h3 {
            color: #64b5f6;
        }

        body.dark-mode .stats-grid > div {
            background: #1a1a2e;
            color: #e0e0e0;
        }

        /* 다크모드 에러 레코드 카드 스타일 */
        body.dark-mode .error-record-card {
            background: #3d3520;
            border-color: #a68307;
        }

        body.dark-mode .error-record-card .error-title {
            color: #ffc107;
        }

        body.dark-mode .error-record-card .error-body .error-message {
            color: #ffd54f;
        }

        body.dark-mode .error-record-card .error-data {
            background: #2a2a3e;
            border-color: #a68307;
            color: #e0e0e0;
        }

        body.dark-mode .error-record-card .error-info {
            color: #ffd54f;
        }

        body.dark-mode .error-message {
            background: #4a2020;
            border-color: #8b3030;
            color: #ff8a80;
        }

        body.dark-mode .restore-notification {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .restore-notification-text {
            color: #64b5f6;
        }

        body.dark-mode .restore-btn.secondary {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .restore-btn.secondary:hover {
            background: #4d4d6c;
        }

        body.dark-mode .theme-toggle {
            background: #3d3d5c;
            border-color: #4d4d6c;
            color: #e0e0e0;
        }

        body.dark-mode .theme-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .test-results.success {
            background: #1e3a29;
            border-color: #2e8b57;
        }

        body.dark-mode .test-results.failure {
            background: #3a1e1e;
            border-color: #8b2e2e;
        }

        body.dark-mode .test-item {
            border-bottom-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .section-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox {
            background: #1e3a5f;
            border-color: #4a90d9;
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox:hover {
            background: #2a4a6f;
        }

        body.dark-mode .option-description {
            background: #2d2d2d;
            border-left-color: #6c757d;
            color: #b0b0b0;
        }

        /* 다크모드 - 서브 탭 네비게이션 */
        body.dark-mode .sub-tab-nav {
            border-bottom-color: #444;
        }

        body.dark-mode .sub-tab-btn {
            background: #2d2d2d;
            border-color: #444;
            color: #b0b0b0;
        }

        body.dark-mode .sub-tab-btn:hover {
            background: #3d3d3d;
        }

        body.dark-mode .sub-tab-btn.active {
            background: #1e1e1e;
            border-bottom-color: #1e1e1e;
            color: #64b5f6;
        }

        body.dark-mode .drag-handle {
            color: #6c757d;
        }

        body.dark-mode .drag-handle:hover {
            color: #adb5bd;
        }

        body.dark-mode .struct-card.drag-over {
            border-color: #64b5f6;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        /* 다크모드 - 자동 설정 필드 스타일 */
        body.dark-mode .auto-field {
            background: #3d3d5c;
            color: #adb5bd;
        }

        /* 다크모드 - CRLF 필드 값 표시 스타일 */
        body.dark-mode .crlf-value {
            background: #3d2a4d !important;  /* 어두운 보라색 배경 */
            color: #ce93d8 !important;       /* 밝은 보라색 글씨 */
        }

        body.dark-mode .new-field-input {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .new-field-input:focus {
            border-color: #64b5f6;
            box-shadow: 0 0 0 0.2rem rgba(100, 181, 246, 0.25);
        }

        body.dark-mode .preview-cell {
            background: #2d2d44;
            color: #adb5bd;
        }

        /* =====================================================
         * 임시 메시지 스타일
         * ===================================================== */
        .temporary-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #17a2b8;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 9999;
            animation: slideIn 0.3s;
        }

        .temporary-message.fade-out {
            opacity: 0;
            transition: opacity 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
            }
            to {
                transform: translateX(0);
            }
        }

        /* =====================================================
         * 도움말 아이콘 및 모달 스타일
         * ===================================================== */
        .help-icon {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 14px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }

        .help-icon:hover {
            background: #138496;
        }

        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 10000;
        }

        .help-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal .help-content {
            background: white;
            width: 600px;
            max-width: 90%;
            max-height: 80vh;
            padding: 30px;
            border-radius: 8px;
            overflow-y: auto;
            position: relative;
        }

        .help-modal .help-content h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        }

        .help-modal .help-content h4 {
            margin-top: 15px;
            margin-bottom: 10px;
            color: #444;
        }

        .help-modal .close-help {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal .close-help:hover {
            background: #5a6268;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .help-section li {
            margin-bottom: 5px;
            line-height: 1.5;
        }

        .help-section code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .help-example {
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            white-space: pre-wrap;
            margin-top: 10px;
            overflow-x: auto;
        }

        /* KSC-5601 도움말 모달 스타일 */
        .help-modal-body .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            color: #856404;
        }

        .info-box {
            background: #e7f3ff;
            padding: 12px;
            border: 1px solid #007bff;
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .mode-explanation {
            background: #f8f9fa;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .mode-explanation h5 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .help-code {
            background: #2d2d44;
            color: #e0e0e0;
            padding: 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .example-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .example-table th,
        .example-table td {
            padding: 10px;
            text-align: left;
            border: 1px solid #dee2e6;
        }

        .example-table th {
            background: #f8f9fa;
            font-weight: bold;
        }

        .help-badge {
            background: #007bff;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 12px;
        }

        .help-tip {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin-top: 20px;
            border-radius: 0 4px 4px 0;
        }

        .help-tip strong {
            color: #856404;
        }

        /* 다크모드 - 도움말 모달 */
        body.dark-mode .help-modal .help-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .help-modal .help-content h3,
        body.dark-mode .help-modal .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-section code {
            background: #3d3d3d;
            color: #e0e0e0;
        }

        body.dark-mode .help-example {
            background: #1e1e1e;
            border-color: #444;
            color: #e0e0e0;
        }

        /* 다크 모드 - KSC-5601 도움말 모달 */
        body.dark-mode .help-modal-body .highlight {
            background: #3d3520;
            color: #ffd54f;
        }

        body.dark-mode .info-box {
            background: #1e3a5f;
            border-color: #2196f3;
            color: #e0e0e0;
        }

        body.dark-mode .mode-explanation {
            background: #2d2d44;
            border-color: #4d4d6c;
        }

        body.dark-mode .mode-explanation h5 {
            color: #e0e0e0;
        }

        body.dark-mode .example-table th {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .example-table td {
            border-color: #4d4d6c;
            color: #e0e0e0;
        }

        body.dark-mode .help-tip {
            background: #3d3520;
            border-left-color: #ffc107;
            color: #e0e0e0;
        }

        /* 테스트 케이스 모달 */
        .test-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 10000;
        }

        .test-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-modal .test-content {
            background: white;
            width: 400px;
            max-width: 90%;
            max-height: 85vh;
            padding: 25px;
            border-radius: 8px;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .test-modal .test-content h4 {
            flex-shrink: 0;
        }
        
        .test-modal .test-groups-container {
            overflow-y: auto;
            flex: 1;
            padding-right: 5px;
        }
        
        /* 스크롤바 스타일 */
        .test-modal .test-groups-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .test-modal .test-groups-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .test-modal .test-groups-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .test-modal .test-groups-container::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
        
        /* 모바일 대응 */
        @media (max-height: 600px) {
            .test-modal .test-content {
                max-height: 90vh;
                padding: 15px;
            }
            
            .test-modal .test-buttons button {
                padding: 10px 15px;
                font-size: 13px;
            }
            
            .test-modal .test-group {
                margin-bottom: 15px;
            }
            
            .test-modal .test-group h5 {
                font-size: 13px;
                margin-bottom: 8px;
            }
        }

        .test-modal .test-content h4 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
        }

        .test-modal .close-test {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-modal .close-test:hover {
            background: #5a6268;
        }

        .test-modal .test-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .test-modal .test-buttons button {
            padding: 12px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s;
        }

        .test-modal .test-buttons button[data-case="normal"] {
            background: #28a745;
            color: white;
        }

        .test-modal .test-buttons button[data-case="normal"]:hover {
            background: #1e7e34;
        }

        .test-modal .test-buttons button[data-case="short"] {
            background: #ffc107;
            color: #212529;
        }

        .test-modal .test-buttons button[data-case="short"]:hover {
            background: #e0a800;
        }

        .test-modal .test-buttons button[data-case="long"] {
            background: #fd7e14;
            color: white;
        }

        .test-modal .test-buttons button[data-case="long"]:hover {
            background: #e96b02;
        }

        .test-modal .test-buttons button[data-case="mismatch"] {
            background: #dc3545;
            color: white;
        }

        .test-modal .test-buttons button[data-case="mismatch"]:hover {
            background: #c82333;
        }

        .test-modal .test-buttons button[data-case="mixed"] {
            background: #6f42c1;
            color: white;
        }

        .test-modal .test-buttons button[data-case="mixed"]:hover {
            background: #5a32a3;
        }

        /* 연속 데이터 테스트 케이스 버튼 스타일 */
        .test-modal .test-buttons button[data-case="continuous"] {
            background: #17a2b8;
            color: white;
        }

        .test-modal .test-buttons button[data-case="continuous"]:hover {
            background: #138496;
        }

        .test-modal .test-buttons button[data-case="continuous_multi"] {
            background: #20c997;
            color: white;
        }

        .test-modal .test-buttons button[data-case="continuous_multi"]:hover {
            background: #1aa179;
        }

        /* KSC-5601 테스트 케이스 버튼 스타일 */
        .test-modal .test-buttons button[data-case="ksc_fullwidth"] {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
            color: white;
        }

        .test-modal .test-buttons button[data-case="ksc_fullwidth"]:hover {
            background: linear-gradient(135deg, #7b1fa2 0%, #6a1b9a 100%);
        }

        .test-modal .test-buttons button[data-case="ksc_mixed"] {
            background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);
            color: white;
        }

        .test-modal .test-buttons button[data-case="ksc_mixed"]:hover {
            background: linear-gradient(135deg, #c2185b 0%, #ad1457 100%);
        }

        /* 테스트 그룹 스타일 */
        .test-modal .test-group {
            margin-bottom: 20px;
        }

        .test-modal .test-group h5 {
            margin: 0 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            color: #495057;
            font-size: 14px;
        }

        .test-modal .test-group:last-child {
            margin-bottom: 0;
        }

        /* 다크모드 - 테스트 모달 */
        body.dark-mode .test-modal .test-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .test-modal .test-content h4 {
            color: #e0e0e0;
        }
        
        body.dark-mode .test-modal .test-groups-container::-webkit-scrollbar-track {
            background: #3d3d3d;
        }
        
        body.dark-mode .test-modal .test-groups-container::-webkit-scrollbar-thumb {
            background: #5a5a5a;
        }
        
        body.dark-mode .test-modal .test-groups-container::-webkit-scrollbar-thumb:hover {
            background: #6a6a6a;
        }
        
        body.dark-mode .test-modal .test-group h5 {
            border-bottom-color: #4a4a4a;
            color: #b0b0b0;
        }

        body.dark-mode .help-tip strong {
            color: #ffc107;
        }

        /* =====================================================
         * 전체 내보내기 모달 스타일
         * ===================================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s;
        }

        .modal-container {
            background: white;
            width: 700px;
            max-height: 90vh;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
        }

        .modal-close-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .modal-close-btn:hover {
            opacity: 0.8;
        }

        .modal-body {
            padding: 25px;
            max-height: calc(90vh - 160px);
            overflow-y: auto;
        }

        .modal-description {
            color: #495057;
            margin-bottom: 20px;
        }

        .export-format-select > label {
            display: block;
            font-weight: bold;
            margin-bottom: 12px;
        }

        .format-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .format-option {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-option:hover {
            background: #e9ecef;
        }

        .format-option.selected {
            background: #e7f3ff;
            border-color: #007bff;
        }

        .format-option input[type="radio"] {
            width: 20px;
            height: 20px;
        }

        .option-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .option-text strong {
            color: #495057;
        }

        .option-text small {
            color: #6c757d;
        }

        .export-preview > label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #export-preview-area {
            width: 100%;
            font-family: monospace;
            font-size: 13px;
            padding: 15px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            background: #f8f9fa;
            box-sizing: border-box;
            resize: vertical;
        }

        .preview-stats {
            margin-top: 10px;
            color: #6c757d;
            text-align: right;
        }

        .modal-footer {
            background: #f8f9fa;
            padding: 20px 25px;
            display: flex;
            gap: 12px;
            border-top: 1px solid #dee2e6;
        }

        .modal-footer button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .modal-footer .btn-primary {
            background: #007bff;
            color: white;
        }

        .modal-footer .btn-primary:hover {
            background: #0056b3;
        }

        .modal-footer .btn-secondary {
            background: #28a745;
            color: white;
        }

        .modal-footer .btn-secondary:hover {
            background: #1e7e34;
        }

        .modal-footer .btn-cancel {
            background: #6c757d;
            color: white;
            flex: 0.5;
        }

        .modal-footer .btn-cancel:hover {
            background: #545b62;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* 다크모드 - 내보내기 모달 */
        body.dark-mode .modal-container {
            background: #2d2d2d;
        }

        body.dark-mode .modal-body {
            color: #e0e0e0;
        }

        body.dark-mode .modal-description {
            color: #b0b0b0;
        }

        body.dark-mode .format-option {
            background: #3d3d3d;
            border-color: #4d4d4d;
        }

        body.dark-mode .format-option:hover {
            background: #4d4d4d;
        }

        body.dark-mode .format-option.selected {
            background: #1a365d;
            border-color: #4a90d9;
        }

        body.dark-mode .option-text strong {
            color: #e0e0e0;
        }

        body.dark-mode .option-text small {
            color: #a0a0a0;
        }

        body.dark-mode #export-preview-area {
            background: #3d3d3d;
            border-color: #4d4d4d;
            color: #e0e0e0;
        }

        body.dark-mode .modal-footer {
            background: #252525;
            border-top-color: #4d4d4d;
        }

        body.dark-mode .preview-stats {
            color: #a0a0a0;
        }

        /* =====================================================
         * 파싱 결과 수정/반영 기능 스타일
         * ===================================================== */
        
        /* 편집 가능한 값 셀 */
        .editable-value {
            cursor: text;
            padding: 6px 10px !important;
            border-radius: 4px;
            transition: all 0.2s ease;
            min-height: 20px;
            position: relative;
        }
        
        .editable-value:hover {
            background: #e7f3ff !important;
            box-shadow: inset 0 0 0 2px #007bff40;
        }
        
        .editable-value:focus {
            outline: none;
            background: #fff !important;
            box-shadow: inset 0 0 0 2px #007bff;
        }
        
        .editable-value.modified {
            background: #fff3cd !important;
            border-left: 3px solid #ffc107;
        }
        
        .editable-value.modified:hover {
            background: #ffe69c !important;
        }
        
        /* 바이트 초과 경고 스타일 */
        .editable-value.byte-overflow {
            background: #f8d7da !important;
            border-left: 3px solid #dc3545;
            animation: pulse-warning 0.5s ease;
        }
        
        .editable-value.byte-overflow:hover {
            background: #f5c6cb !important;
        }
        
        @keyframes pulse-warning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        body.dark-mode .editable-value.byte-overflow {
            background: #4a1a1a !important;
            border-left-color: #dc3545;
        }
        
        /* 바이트 길이 표시 뱃지 */
        .byte-info-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            background: #e3f2fd;
            color: #1565c0;
            margin-left: 8px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .byte-info-badge.byte-ok {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .byte-info-badge.byte-warning {
            background: #fff3e0;
            color: #ef6c00;
        }
        
        .byte-info-badge.byte-error {
            background: #ffebee;
            color: #c62828;
            animation: pulse-warning 0.5s ease;
        }
        
        body.dark-mode .byte-info-badge {
            background: #1a3a5c;
            color: #64b5f6;
        }
        
        body.dark-mode .byte-info-badge.byte-ok {
            background: #1b3a2f;
            color: #81c784;
        }
        
        body.dark-mode .byte-info-badge.byte-warning {
            background: #3a2a1a;
            color: #ffb74d;
        }
        
        body.dark-mode .byte-info-badge.byte-error {
            background: #4a1a1a;
            color: #ef9a9a;
        }
        
        body.dark-mode .editable-value:hover {
            background: #1a3a5c !important;
        }
        
        body.dark-mode .editable-value:focus {
            background: #1e2a3a !important;
        }
        
        body.dark-mode .editable-value.modified {
            background: #3d3500 !important;
            border-left-color: #ffc107;
        }
        
        /* 편집 불가 표시 (FULL 타입 등) */
        .readonly-value {
            background: #f0f0f0;
            color: #6c757d;
            cursor: not-allowed;
        }
        
        body.dark-mode .readonly-value {
            background: #2a2a2a;
            color: #888;
        }
        
        /* 수정 반영 버튼 그룹 */
        .reflect-changes-container {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        
        body.dark-mode .reflect-changes-container {
            background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
            border-color: #404040;
        }
        
        .reflect-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .reflect-info .modified-count {
            background: #ffc107;
            color: #333;
            padding: 4px 10px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 13px;
        }
        
        .reflect-info .modified-count.no-changes {
            background: #6c757d;
            color: white;
        }
        
        .reflect-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn-reflect {
            padding: 10px 20px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-reflect:hover {
            background: linear-gradient(135deg, #218838, #1aa179);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        
        .btn-reflect:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-reset-changes {
            padding: 10px 20px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-reset-changes:hover {
            background: #5a6268;
        }
        
        /* 재생성된 통데이터 결과 영역 */
        .regenerated-data-container {
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 8px;
        }
        
        body.dark-mode .regenerated-data-container {
            background: #1a3a1a;
            border-color: #28a745;
        }
        
        .regenerated-data-container h4 {
            margin: 0 0 15px 0;
            color: #155724;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        body.dark-mode .regenerated-data-container h4 {
            color: #a3d9a5;
        }
        
        .regenerated-data-content {
            background: white;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #c3e6cb;
        }
        
        body.dark-mode .regenerated-data-content {
            background: #1a1a1a;
            border-color: #28a745;
            color: #e0e0e0;
        }
        
        .regenerated-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn-copy-regenerated {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-copy-regenerated:hover {
            background: #0056b3;
        }
        
        .btn-apply-to-input {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-apply-to-input:hover {
            background: #138496;
        }
        
        .btn-download-regenerated {
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-download-regenerated:hover {
            background: #545b62;
        }
        
        /* 필드 편집 힌트 */
        .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        body.dark-mode .edit-hint {
            background: #2a2a2a;
            color: #a0a0a0;
        }
        
        .edit-hint .hint-icon {
            color: #17a2b8;
        }

        /* =====================================================
         * Footer 개발 노트 스타일
         * ===================================================== */
        .footer-devnote {
            margin-top: 50px;
            border-top: 1px solid #e9ecef;
            background: linear-gradient(180deg, transparent, #f8f9fa);
        }

        .footer-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        ._x7k2m9 {
            margin: 0;
            color: #666;
            font-size: 13px;
        }

        ._x7k2m9 ._h3n5v8 {
            color: #667eea;
            font-weight: bold;
        }

        .devnote-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .devnote-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .devnote-toggle .toggle-icon {
            transition: transform 0.3s;
        }

        .devnote-toggle.active .toggle-icon {
            transform: rotate(180deg);
        }

        /* 개발 노트 패널 */
        .devnote-panel {
            border-top: 1px solid #e9ecef;
            background: #fff;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }

        .devnote-panel.open {
            max-height: 2000px;
        }

        .devnote-container {
            padding: 30px 20px;
            max-width: 900px;
            margin: 0 auto;
        }

        .devnote-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .devnote-header h3 {
            font-size: 20px;
            color: #333;
            margin: 0 0 15px 0;
        }

        .devnote-stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: #e9ecef;
            color: #555;
            padding: 6px 14px;
            border-radius: 15px;
            font-size: 12px;
        }

        /* 타임라인 */
        .devnote-timeline {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .timeline-section {
            position: relative;
            padding-left: 45px;
        }

        .timeline-marker {
            position: absolute;
            left: 0;
            top: 5px;
            width: 32px;
            height: 32px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .timeline-marker.latest {
            border-color: #28a745;
            background: #d4edda;
        }

        .timeline-marker.feature {
            border-color: #007bff;
            background: #e7f1ff;
        }

        .timeline-marker.ux {
            border-color: #6f42c1;
            background: #f3e8ff;
        }

        .timeline-marker.start {
            border-color: #fd7e14;
            background: #fff3cd;
        }

        .timeline-content {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
        }

        .timeline-content h4 {
            color: #333;
            margin: 0 0 6px 0;
            font-size: 14px;
        }

        .timeline-date {
            display: inline-block;
            background: #e9ecef;
            color: #666;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-bottom: 10px;
        }

        .feature-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .feature-list li {
            padding: 4px 0;
            font-size: 12px;
            color: #555;
        }

        .tag {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-right: 5px;
            text-transform: uppercase;
        }

        .tag.feature {
            background: #cce5ff;
            color: #004085;
        }

        .tag.fix {
            background: #f8d7da;
            color: #721c24;
        }

        .tag.improve {
            background: #d4edda;
            color: #155724;
        }

        /* 기술 스택 섹션 */
        .tech-stack-section {
            text-align: center;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }

        .tech-badges {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tech-badge {
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
        }

        .tech-badge.html {
            background: #e34c26;
            color: white;
        }

        .tech-badge.css {
            background: #264de4;
            color: white;
        }

        .tech-badge.js {
            background: #f7df1e;
            color: #333;
        }

        .tech-badge.tool {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* 다크모드 - Footer 개발 노트 */
        body.dark-mode .footer-devnote {
            border-top-color: #444;
            background: linear-gradient(180deg, transparent, #1a1a2e);
        }

        body.dark-mode ._x7k2m9 {
            color: #aaa;
        }

        body.dark-mode .devnote-panel {
            background: #1a1a2e;
            border-top-color: #444;
        }

        body.dark-mode .devnote-header h3 {
            color: #fff;
        }

        body.dark-mode .stat-item {
            background: #444;
            color: #ccc;
        }

        body.dark-mode .timeline-marker {
            background: #2d2d44;
        }

        body.dark-mode .timeline-marker.latest {
            background: #1e4620;
        }

        body.dark-mode .timeline-marker.feature {
            background: #1a365d;
        }

        body.dark-mode .timeline-marker.ux {
            background: #2d1f4e;
        }

        body.dark-mode .timeline-marker.start {
            background: #4a3000;
        }

        body.dark-mode .timeline-content {
            background: #2d2d44;
            border-color: #444;
        }

        body.dark-mode .timeline-content h4 {
            color: #fff;
        }

        body.dark-mode .timeline-date {
            background: #444;
            color: #aaa;
        }

        body.dark-mode .feature-list li {
            color: #ccc;
        }

        body.dark-mode .tech-stack-section {
            border-top-color: #444;
        }

    </style>
</head>
<body>
    <!-- 다크모드 토글 버튼 -->
    <button class="theme-toggle" id="theme-toggle" title="다크모드 전환">🌙</button>
    
    <h1>통전문 파서</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML 파싱</button>
        <button class="tab-btn" data-tab="struct">C 구조체 파싱</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        
        <!-- 서브 탭 네비게이션 (신규) -->
        <div class="sub-tab-nav">
            <button class="sub-tab-btn active" data-mode="parse">
                📖 파싱 모드
            </button>
            <button class="sub-tab-btn" data-mode="generate">
                ✏️ 생성 모드
            </button>
        </div>
        
        <!-- 파싱 모드 (기존 내용) -->
        <div id="xml-parse-mode" class="sub-mode-content active">
            <div id="input-section">
                <label for="xml-input">XML 규격</label>
                <textarea id="xml-input" rows="10" placeholder="XML 규격 입력"></textarea>
                
                <label for="telegram-input">통전문</label>
                <textarea id="telegram-input" rows="5" placeholder="통전문 입력"></textarea>
                
                <div class="button-group">
                    <button id="sample-btn">샘플 로드</button>
                    <button id="parse-btn">파싱 실행</button>
                    <button id="clear-btn">초기화</button>
                </div>
            </div>
        </div>
        
        <!-- 생성 모드 (신규) -->
        <div id="xml-generate-mode" class="sub-mode-content">
            <div class="generate-intro">
                <h4>✏️ 전문 생성 (XML 기반)</h4>
                <p>XML 규격을 입력하고 각 필드에 값을 입력하여 통전문을 생성합니다.</p>
                <div class="type-info-box">
                    <strong>지원 타입:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px; font-size: 13px;">
                        <li><code style="background:#17a2b8; color:white; padding:2px 6px; border-radius:3px;">X</code> 문자 타입 - 우측 공백 패딩</li>
                        <li><code style="background:#ffc107; color:#000; padding:2px 6px; border-radius:3px;">N</code> 숫자 타입 - 좌측 0 패딩</li>
                        <li><code style="background:#6f42c1; color:white; padding:2px 6px; border-radius:3px;">FULL</code> KSC-5601 2바이트 완성형 코드 - 한글 인코딩 (바이트 단위)</li>
                    </ul>
                </div>
            </div>
            
            <div class="xml-spec-input">
                <label for="xml-generate-spec">XML 규격</label>
                <textarea id="xml-generate-spec" rows="12" placeholder="<packet>...</packet>"></textarea>
                <button id="load-xml-form-btn" class="primary-btn">
                    폼 불러오기
                </button>
            </div>
            
            <div id="xml-generate-form-container" style="display: none;">
                <!-- 입력 폼 -->
            </div>
            
            <div id="xml-generated-records-area">
                <!-- 생성된 레코드 -->
            </div>
        </div>
        
        <!-- 결과 영역 (공통) -->
        <div id="result-container"></div>
        
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <!-- 도움말 섹션 -->
        <div class="help-section">
            <button class="help-toggle" type="button">
                <span>📖 사용 방법 안내</span>
                <span class="help-toggle-icon">▼</span>
            </button>
            <div class="help-content">
                <h4>C 구조체 파싱 사용법</h4>
                <p>고정 길이 데이터를 C 구조체 정의에 따라 파싱합니다.</p>
                
                <h4>1. 구조체 정의 형식</h4>
                <p>다음 두 가지 형식을 모두 지원합니다:</p>
                <pre>// 형식 1: typedef struct
typedef struct {
    char record_kubun[1];  // 레코드 구분
    char bank_cd[2];       // 은행 코드
    char cust_id[7];       // 고객 ID
} DHF_H;

// 형식 2: struct Name (typedef 없이)
struct MyStruct {
    char field1[10];
    char field2[20];
};</pre>
                
                <h4>2. 데이터 입력 규칙</h4>
                <ul>
                    <li>각 줄이 하나의 데이터 레코드입니다</li>
                    <li>여러 구조체가 있을 경우, 첫 글자로 구조체를 자동 매칭합니다</li>
                    <li>예: <code>H</code>로 시작 → <code>DHF_H</code> (H로 끝나는 구조체)</li>
                    <li>예: <code>D</code>로 시작 → <code>DHF_D</code> (D로 끝나는 구조체)</li>
                </ul>
                
                <h4>3. 지원 기능</h4>
                <ul>
                    <li>여러 구조체 동시 정의 가능</li>
                    <li>주석 지원: <code>//</code> 한줄 주석, <code>/* */</code> 블록 주석</li>
                    <li>파싱 결과를 TSV 형식으로 클립보드에 복사 가능</li>
                </ul>
                
                <h4>4. 주의사항</h4>
                <ul>
                    <li>데이터 길이가 구조체 총 크기와 다르면 경고가 표시됩니다</li>
                    <li>char 배열만 정확히 지원됩니다 (int, short 등은 char로 처리)</li>
                </ul>
                
                <h4>🔍 5. 디버그 모드 사용법</h4>
                <p>디버그 모드를 활성화하면 브라우저 콘솔(F12)에서 상세한 파싱 과정을 확인할 수 있습니다.</p>
                <div class="debug-guide">
                    <h5>📌 디버그 모드 활성화 방법</h5>
                    <ol>
                        <li>상단 옵션에서 <strong>🔍 디버그 모드</strong> 체크박스 선택</li>
                        <li>브라우저 개발자 도구 열기: <kbd>F12</kbd> 또는 <kbd>Ctrl+Shift+I</kbd></li>
                        <li><strong>Console</strong> 탭 선택</li>
                        <li>파싱 실행 후 로그 확인</li>
                    </ol>
                    
                    <h5>📊 출력되는 디버그 정보</h5>
                    <ul>
                        <li><strong>📋 모드</strong>: 파싱 모드 (line-by-line / continuous)</li>
                        <li><strong>📊 전체 라인/바이트 수</strong>: 입력 데이터 크기</li>
                        <li><strong>📐 정의된 구조체</strong>: 등록된 구조체명과 구분값</li>
                        <li><strong>📝 라인별 미리보기</strong>: 각 라인의 길이, 구분값, HEX 값</li>
                    </ul>
                    
                    <h5>✅ 레코드별 상세 정보</h5>
                    <ul>
                        <li><strong>구분값 매칭</strong>: 어떤 구조체에 매칭되었는지</li>
                        <li><strong>길이 비교</strong>: 예상 크기 vs 실제 크기 (일치/부족/초과)</li>
                        <li><strong>필드별 추출</strong>: 각 필드명, 크기, 값, HEX 값</li>
                        <li><strong>KSC 디코딩</strong>: KSC-5601 필드의 디코딩 결과</li>
                    </ul>
                    
                    <h5>⚠️ 에러 추적</h5>
                    <ul>
                        <li><strong>❌ 매칭 실패</strong>: 구분값에 해당하는 구조체를 찾지 못한 경우</li>
                        <li><strong>등록된 구분값 목록</strong>: 현재 정의된 모든 구분값 표시</li>
                        <li><strong>에러 바이트/라인</strong>: 파싱되지 않은 데이터 통계</li>
                    </ul>
                    
                    <h5>💡 활용 팁</h5>
                    <ul>
                        <li>구조체 정의가 올바른지 확인할 때 사용</li>
                        <li>데이터 길이 문제 디버깅에 유용</li>
                        <li>HEX 값으로 인코딩 문제 확인 가능</li>
                        <li>KSC-5601 한글 깨짐 문제 추적에 활용</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- 공통: 구조체 정의 영역 -->
        <div id="struct-definitions-area">
            <div class="section-header">
                <h3>
                    C 구조체 정의
                    <button class="help-icon" id="crlf-help">❓</button>
                </h3>
                <div class="header-options">
                    <label class="option-checkbox">
                        <input type="checkbox" id="recognize-crlf">
                        개행문자 인식 (CRLF)
                    </label>
                    <label class="option-checkbox">
                        <input type="checkbox" id="debug-mode">
                        🔍 디버그 모드
                    </label>
                    <label class="option-select" style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-size: 13px;">입력 인코딩:</span>
                        <select id="input-encoding" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px;">
                            <option value="auto">자동 감지</option>
                            <option value="ascii">ASCII (1byte)</option>
                            <option value="ksc5601">KSC-5601 (바이트)</option>
                        </select>
                    </label>
                    <button id="add-struct-btn">+ 구조체 추가 <span class="shortcut-hint">(Ctrl+N)</span></button>
                    <button id="toggle-all-structs-btn" class="toggle-all-btn" title="전체 접기/펼치기">
                        <span class="toggle-icon">▼</span> 전체 접기
                    </button>
                </div>
            </div>
            <div class="option-description">
                <small>
                    ℹ️ 체크 시: 각 레코드 끝에 CRLF(2 bytes) 존재로 간주<br>
                    📝 체크 해제: 줄바꿈 제거 후 연속 데이터로 처리<br>
                    🔤 입력 인코딩: KSC-5601 감지 시 모든 필드를 <strong>KSC 전각</strong>으로 기본 표시 (파싱 결과에서 필드별 변경 가능)
                </small>
            </div>
            
            <div id="struct-definitions-container">
                <!-- 구조체 입력 카드들이 여기 동적 추가됨 -->
            </div>
        </div>

        <!-- 서브 탭 네비게이션 -->
        <div class="sub-tab-nav">
            <button class="sub-tab-btn active" data-mode="parse">
                📖 파싱 모드
            </button>
            <button class="sub-tab-btn" data-mode="generate">
                ✏️ 생성 모드
            </button>
        </div>

        <!-- 파싱 모드 컨텐츠 -->
        <div id="parse-mode-content" class="sub-mode-content active">
            <label for="struct-data">통 데이터</label>
            <textarea id="struct-data" rows="10" placeholder="파싱할 데이터 입력 (줄바꿈 유무 무관)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">샘플 로드</button>
                <button id="struct-test-btn">테스트 케이스</button>
                <button id="struct-parse-btn">파싱 실행 <span class="shortcut-hint">(Ctrl+Enter)</span></button>
                <button id="struct-clear-btn">전체 초기화</button>
            </div>
        </div>

        <!-- 생성 모드 컨텐츠 -->
        <div id="generate-mode-content" class="sub-mode-content">
          
          <div class="generate-intro">
            <h4>✏️ 전문 생성</h4>
            <p>정의된 구조체를 선택하고 각 필드에 값을 입력하여 통전문을 생성합니다.</p>
          </div>
          
          <div class="struct-selector">
            <label for="generate-struct-select">생성할 구조체 선택</label>
            <select id="generate-struct-select" class="form-select">
              <option value="">구조체를 먼저 정의하세요</option>
            </select>
            <button id="load-generate-form-btn" class="primary-btn" disabled>
              폼 불러오기
            </button>
          </div>
          
          <div id="generate-form-container" style="display: none;">
            <!-- 입력 폼이 여기 동적 생성됨 -->
          </div>
          
          <div id="generated-records-area">
            <!-- 생성된 레코드 목록 -->
          </div>
          
        </div>

        <div id="struct-result-container"></div>

        <!-- 개행문자 인식 도움말 모달 -->
        <div class="help-modal" id="crlf-help-modal">
            <div class="help-content">
                <button class="close-help">✕</button>
                <h3>💡 개행문자 인식 옵션 설명</h3>
                
                <div class="help-section">
                    <h4>✓ 체크 시 (권장)</h4>
                    <ul>
                        <li>C 구조체에 <code>crlf[2]</code> 필드가 있는 경우 사용</li>
                        <li>각 레코드 끝에 자동으로 <code>\r\n</code> (2 bytes) 추가</li>
                        <li>textarea에 줄바꿈으로 레코드 구분</li>
                    </ul>
                    
                    <pre class="help-example">예시:
H881234567
D123456789012345600000000000000001000
       ↓
H881234567\r\n  (12 bytes)
D123456789012345600000000000000001000\r\n  (39 bytes)</pre>
                </div>
                
                <div class="help-section">
                    <h4>✗ 체크 해제 시</h4>
                    <ul>
                        <li>구조체에 CRLF 필드가 없는 경우</li>
                        <li>모든 줄바꿈 제거 후 연속 데이터로 처리</li>
                        <li>구분값으로 레코드 자동 인식</li>
                    </ul>
                </div>
                
                <div class="help-tip">
                    <strong>💡 팁:</strong> 일반적인 전문 파일은 개행문자를 포함합니다.
                    확실하지 않다면 체크 상태로 두세요.
                </div>
            </div>
        </div>

        <!-- KSC-5601 도움말 모달 -->
        <div class="help-modal" id="ksc-help-modal">
            <div class="help-content">
                <button class="close-help">✕</button>
                <h3>🌏 KSC-5601 인코딩 도움말</h3>
                
                <div class="help-modal-body">
                    <section class="help-section">
                        <h4>📌 KSC-5601 (EUC-KR)이란?</h4>
                        <p>
                            한국 산업 표준 완성형 인코딩입니다.<br>
                            <strong class="highlight">KSC-5601 영역의 모든 문자는 2 bytes입니다.</strong>
                        </p>
                        <div class="info-box">
                            <strong>2 bytes 문자:</strong><br>
                            • 한글: 가, 나, 다...<br>
                            • 전각 영문: Ａ, Ｂ, Ｃ... (넓은 글자)<br>
                            • 전각 숫자: １, ２, ３...<br>
                            • 전각 공백: 　(넓은 공백)
                        </div>
                        <div class="info-box">
                            <strong>1 byte 문자 (ASCII):</strong><br>
                            • 반각 영문: A, B, C...<br>
                            • 반각 숫자: 1, 2, 3...<br>
                            • 반각 공백: (일반 공백)
                        </div>
                    </section>
                    
                    <section class="help-section">
                        <h4>💡 인코딩 모드</h4>
                        
                        <div class="mode-explanation">
                            <h5>🔷 전각 전용 모드 (권장)</h5>
                            <p>
                                모든 문자를 2 bytes로 처리합니다.<br>
                                계산: <code>글자 수 × 2 = 바이트 수</code>
                            </p>
                            <pre class="help-code">char name[20];  // 최대 10글자
"홍길동"    → 6 bytes (3글자 × 2)
"HONG"      → 8 bytes (4글자 × 2)
"Hong 123"  → 14 bytes (7글자 × 2)</pre>
                        </div>
                        
                        <div class="mode-explanation">
                            <h5>🔶 혼용 모드</h5>
                            <p>
                                한글/한자는 2 bytes, ASCII는 1 byte로 처리합니다.<br>
                                실무에서 전각/반각이 섞여 있을 때 사용합니다.
                            </p>
                            <pre class="help-code">char name[20];
"홍길동"    → 6 bytes (한글 3자 × 2)
"Hong"      → 4 bytes (ASCII 4자 × 1)
"Hong길동"  → 10 bytes (4 + 6)</pre>
                        </div>
                    </section>
                    
                    <section class="help-section">
                        <h4>🔧 사용 방법</h4>
                        <ol>
                            <li>구조체 정의 입력</li>
                            <li>"구조체 파싱" 버튼 클릭</li>
                            <li>인코딩 모드 선택 (전각 전용 / 혼용)</li>
                            <li>KSC-5601 필드 체크</li>
                            <li>파싱 실행</li>
                        </ol>
                    </section>
                    
                    <section class="help-section">
                        <h4>⚠️ 주의사항</h4>
                        <ul>
                            <li><strong>설계서를 확인하세요:</strong> 전각인지 혼용인지 확인 필수</li>
                            <li><strong>일반적으로 전각 전용:</strong> 대부분의 금융/통신 전문은 전각</li>
                            <li><strong>테스트 필수:</strong> 샘플 데이터로 먼저 확인</li>
                            <li><strong>글자 깨짐 발생 시:</strong> 인코딩 모드를 바꿔보세요</li>
                        </ul>
                    </section>
                    
                    <section class="help-section help-example">
                        <h4>📖 실전 예시</h4>
                        <pre class="help-code">typedef struct {
    char trans_id[10];     // 거래ID (ASCII)
    char cust_nm[20];      // 고객명 (KSC-5601, 전각)
    char amount[15];       // 금액 (ASCII)
    char addr[40];         // 주소 (KSC-5601, 전각)
} TRANSACTION;</pre>
                        
                        <p><strong>설정:</strong></p>
                        <ul>
                            <li>인코딩 모드: <span class="help-badge">전각 전용</span></li>
                            <li>KSC-5601 필드: cust_nm, addr</li>
                        </ul>
                        
                        <p><strong>파싱 결과:</strong></p>
                        <table class="example-table">
                            <tr>
                                <th>필드</th>
                                <th>바이트</th>
                                <th>최대 글자</th>
                            </tr>
                            <tr>
                                <td>trans_id</td>
                                <td>10</td>
                                <td>10자 (ASCII)</td>
                            </tr>
                            <tr>
                                <td>cust_nm</td>
                                <td>20</td>
                                <td class="highlight">10자 (전각)</td>
                            </tr>
                            <tr>
                                <td>amount</td>
                                <td>15</td>
                                <td>15자 (ASCII)</td>
                            </tr>
                            <tr>
                                <td>addr</td>
                                <td>40</td>
                                <td class="highlight">20자 (전각)</td>
                            </tr>
                        </table>
                    </section>
                </div>
            </div>
        </div>

        <!-- KSC-5601 입력기 모달 -->
        <div class="help-modal" id="ksc-input-modal">
            <div class="help-content" style="max-width: 500px;">
                <button class="close-help">✕</button>
                <h3>🔤 KSC-5601 입력기</h3>
                
                <div class="ksc-input-body">
                    <div class="ksc-input-section">
                        <label>입력 (유니코드)</label>
                        <input type="text" id="ksc-input-text" placeholder="문자를 입력하세요 (예: ABC홍길동)" 
                               style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px;">
                        <small style="color: #666;">한글, 영문, 숫자, 공백 등을 입력하면 KSC-5601 전각으로 변환됩니다.</small>
                    </div>
                    
                    <div class="ksc-input-section" style="margin-top: 20px;">
                        <label>변환 결과</label>
                        <div id="ksc-input-result" style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; padding: 15px; min-height: 80px;">
                            <div class="result-row">
                                <span class="result-label">전각 문자:</span>
                                <span id="ksc-result-fullwidth" class="result-value" style="font-family: monospace; font-size: 18px; color: #7b1fa2;">-</span>
                            </div>
                            <div class="result-row" style="margin-top: 10px;">
                                <span class="result-label">바이트 수:</span>
                                <span id="ksc-result-bytes" class="result-value" style="font-weight: bold; color: #1565c0;">0 bytes</span>
                            </div>
                            <div class="result-row" style="margin-top: 10px;">
                                <span class="result-label">HEX:</span>
                                <code id="ksc-result-hex" style="background: #e3f2fd; padding: 4px 8px; border-radius: 4px; font-size: 12px;">-</code>
                            </div>
                        </div>
                    </div>
                    
                    <div class="ksc-input-section" style="margin-top: 20px;">
                        <label>변환 모드</label>
                        <div style="display: flex; gap: 15px; margin-top: 5px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="ksc-input-mode" value="fullwidth" checked style="margin-right: 5px;">
                                전각 전용 (모든 문자 2B)
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="ksc-input-mode" value="mixed" style="margin-right: 5px;">
                                혼용 (한글 2B / ASCII 1B)
                            </label>
                        </div>
                    </div>
                    
                    <div class="ksc-input-actions" style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="ksc-input-copy" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                            📋 바이트 복사
                        </button>
                        <button id="ksc-input-apply" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                            ✅ 필드에 적용
                        </button>
                    </div>
                    
                    <div class="ksc-input-preview" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">
                        <strong>💡 예시</strong>
                        <table style="width: 100%; margin-top: 10px; font-size: 13px;">
                            <tr style="border-bottom: 1px solid #ddd;">
                                <th style="text-align: left; padding: 5px;">입력</th>
                                <th style="text-align: left; padding: 5px;">전각 결과</th>
                                <th style="text-align: left; padding: 5px;">바이트</th>
                            </tr>
                            <tr>
                                <td style="padding: 5px;">A</td>
                                <td style="padding: 5px; font-family: monospace;">Ａ</td>
                                <td style="padding: 5px;">2B (A3C1)</td>
                            </tr>
                            <tr>
                                <td style="padding: 5px;">(공백)</td>
                                <td style="padding: 5px; font-family: monospace;">　</td>
                                <td style="padding: 5px;">2B (A1A1)</td>
                            </tr>
                            <tr>
                                <td style="padding: 5px;">홍</td>
                                <td style="padding: 5px; font-family: monospace;">홍</td>
                                <td style="padding: 5px;">2B (C8AB)</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- 테스트 케이스 선택 모달 -->
        <div class="test-modal" id="test-case-modal">
            <div class="test-content">
                <button class="close-test">✕</button>
                <h4>🧪 테스트 케이스 선택</h4>
                
                <div class="test-groups-container">
                    <!-- 개행 인식 ON 테스트 (라인 단위 파싱) -->
                    <div class="test-group">
                        <h5>📄 개행 인식 ON (라인 단위)</h5>
                        <div class="test-buttons">
                            <button data-case="normal">✅ 정상 데이터</button>
                            <button data-case="short">⚠️ 길이 부족</button>
                            <button data-case="long">📏 길이 초과</button>
                            <button data-case="mismatch">❌ 매칭 실패</button>
                            <button data-case="mixed">🔀 혼합</button>
                        </div>
                    </div>
                    
                    <!-- 개행 인식 OFF 테스트 (연속 데이터 파싱) -->
                    <div class="test-group">
                        <h5>🔗 개행 인식 OFF (연속 데이터)</h5>
                        <div class="test-buttons">
                            <button data-case="continuous">📦 연속 데이터</button>
                            <button data-case="continuous_multi">🔄 연속 다중 레코드</button>
                        </div>
                    </div>
                    
                    <!-- KSC-5601 테스트 (한글 인코딩) -->
                    <div class="test-group">
                        <h5>🔤 KSC-5601 (한글 인코딩)</h5>
                        <div class="test-buttons">
                            <button data-case="ksc_fullwidth">전각 모드 (모든 문자 2B)</button>
                            <button data-case="ksc_mixed">혼용 모드 (한글 2B/ASCII 1B)</button>
                        </div>
                    </div>
                    
                    <!-- 단일 구조체 테스트 -->
                    <div class="test-group">
                        <h5>📋 단일 구조체</h5>
                        <div class="test-buttons">
                            <button data-case="single_struct_ascii">ASCII 단일 구조체</button>
                            <button data-case="single_struct_ksc">KSC 단일 구조체</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer 개발 노트 섹션 -->
    <footer class="footer-devnote">
        <div class="footer-main">
            <p class="_x7k2m9" id="_c4r8d1"></p>
            <button class="devnote-toggle" id="devnote-toggle">
                <span>📋 개발 노트</span>
                <span class="toggle-icon">▼</span>
            </button>
        </div>
        
        <div class="devnote-panel" id="devnote-panel" style="display: none;">
            <div class="devnote-container">
                <div class="devnote-header">
                    <h3>📋 개발 히스토리</h3>
                    <div class="devnote-stats">
                        <span class="stat-item">📦 PR 116+</span>
                        <span class="stat-item">💻 커밋 260+</span>
                        <span class="stat-item">🚀 2025</span>
                    </div>
                </div>

                <div class="devnote-timeline">
                    <!-- 최신 업데이트 -->
                    <div class="timeline-section">
                        <div class="timeline-marker latest">🆕</div>
                        <div class="timeline-content">
                            <h4>최신 업데이트</h4>
                            <span class="timeline-date">PR #113~116</span>
                            <ul class="feature-list">
                                <li><span class="tag fix">Fix</span> 구조체 파싱 CRLF 데이터 보존</li>
                                <li><span class="tag fix">Fix</span> kubun 매칭 우선순위 개선</li>
                                <li><span class="tag fix">Fix</span> KSC 혼용모드 공백/ASCII 처리</li>
                            </ul>
                        </div>
                    </div>

                    <!-- 개발 노트 & Footer -->
                    <div class="timeline-section">
                        <div class="timeline-marker feature">📋</div>
                        <div class="timeline-content">
                            <h4>개발 노트 & Footer</h4>
                            <span class="timeline-date">PR #105~112</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> 개발 노트 섹션 (Footer)</li>
                                <li><span class="tag improve">Improve</span> Footer 크레딧 난독화</li>
                                <li><span class="tag fix">Fix</span> KSC-5601 디코딩 통합</li>
                            </ul>
                        </div>
                    </div>

                    <!-- KSC & 구조체 개선 -->
                    <div class="timeline-section">
                        <div class="timeline-marker feature">🔧</div>
                        <div class="timeline-content">
                            <h4>KSC & 구조체 개선</h4>
                            <span class="timeline-date">PR #100~104</span>
                            <ul class="feature-list">
                                <li><span class="tag fix">Fix</span> C언어 구조체 파싱 개선</li>
                                <li><span class="tag improve">Improve</span> KSC 토글 방식 전환</li>
                                <li><span class="tag feature">Feature</span> 전체 접기/펼치기 버튼</li>
                            </ul>
                        </div>
                    </div>

                    <!-- KSC-5601 인코딩 -->
                    <div class="timeline-section">
                        <div class="timeline-marker feature">🔤</div>
                        <div class="timeline-content">
                            <h4>KSC-5601 한글 인코딩</h4>
                            <span class="timeline-date">PR #77~99</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> FULL 타입 2바이트 완성형</li>
                                <li><span class="tag feature">Feature</span> 도움말 모달, 입력 검증</li>
                                <li><span class="tag fix">Fix</span> 전각 문자/IME 변환</li>
                            </ul>
                        </div>
                    </div>

                    <!-- 전문 생성 모드 -->
                    <div class="timeline-section">
                        <div class="timeline-marker feature">✏️</div>
                        <div class="timeline-content">
                            <h4>전문 생성 모드</h4>
                            <span class="timeline-date">PR #61~76</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> XML/구조체 전문 생성</li>
                                <li><span class="tag feature">Feature</span> 레코드 목록, 내보내기</li>
                                <li><span class="tag feature">Feature</span> 실시간 미리보기</li>
                            </ul>
                        </div>
                    </div>

                    <!-- 테스트 & 검증 -->
                    <div class="timeline-section">
                        <div class="timeline-marker ux">🧪</div>
                        <div class="timeline-content">
                            <h4>테스트 & 검증</h4>
                            <span class="timeline-date">PR #50~60</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> 테스트 케이스 모달</li>
                                <li><span class="tag feature">Feature</span> 길이 검증 뱃지</li>
                                <li><span class="tag improve">Improve</span> 에러 레코드 처리</li>
                            </ul>
                        </div>
                    </div>

                    <!-- UX 개선 -->
                    <div class="timeline-section">
                        <div class="timeline-marker ux">🎨</div>
                        <div class="timeline-content">
                            <h4>UX/UI 개선</h4>
                            <span class="timeline-date">PR #37~49</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> 다크모드, 단축키</li>
                                <li><span class="tag feature">Feature</span> 드래그앤드롭, 로컬 저장</li>
                                <li><span class="tag feature">Feature</span> CRLF 인식 옵션</li>
                            </ul>
                        </div>
                    </div>

                    <!-- 파싱 기능 고도화 -->
                    <div class="timeline-section">
                        <div class="timeline-marker feature">⚙️</div>
                        <div class="timeline-content">
                            <h4>파싱 기능 고도화</h4>
                            <span class="timeline-date">PR #25~36</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> 라인/연속 파싱 분리</li>
                                <li><span class="tag feature">Feature</span> 구분값 자동 매칭</li>
                                <li><span class="tag feature">Feature</span> TSV 복사 기능</li>
                            </ul>
                        </div>
                    </div>

                    <!-- C 구조체 파싱 -->
                    <div class="timeline-section">
                        <div class="timeline-marker feature">📦</div>
                        <div class="timeline-content">
                            <h4>C 구조체 파싱</h4>
                            <span class="timeline-date">PR #11~24</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> typedef struct 파싱</li>
                                <li><span class="tag feature">Feature</span> 다중 구조체 카드 UI</li>
                                <li><span class="tag feature">Feature</span> 복사 버튼, 요약 정보</li>
                            </ul>
                        </div>
                    </div>

                    <!-- 초기 개발 -->
                    <div class="timeline-section">
                        <div class="timeline-marker start">🎯</div>
                        <div class="timeline-content">
                            <h4>프로젝트 시작</h4>
                            <span class="timeline-date">PR #1~10</span>
                            <ul class="feature-list">
                                <li><span class="tag feature">Feature</span> XML 규격/통전문 파싱</li>
                                <li><span class="tag feature">Feature</span> 결과 테이블, 샘플 로드</li>
                                <li><span class="tag feature">Feature</span> 에러 표시, 초기화</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- 기술 스택 -->
                <div class="tech-stack-section">
                    <div class="tech-badges">
                        <span class="tech-badge html">HTML5</span>
                        <span class="tech-badge css">CSS3</span>
                        <span class="tech-badge js">JavaScript</span>
                        <span class="tech-badge tool">Cursor AI</span>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <script>
        /**
         * =====================================================
         * 전역 변수
         * =====================================================
         */
        let structCardIndex = 0;

        /**
         * =====================================================
         * 정규식 캐싱 - 성능 최적화를 위해 정규식을 미리 컴파일
         * =====================================================
         */
        const REGEX_CACHE = {
            // 한줄 주석 제거: // 부터 줄 끝까지 매칭
            singleLineComment: /\/\/.*$/gm,
            
            // 블록 주석 제거: /* 부터 */ 까지 (비탐욕적 매칭)
            blockComment: /\/\*[\s\S]*?\*\//g,
            
            // typedef struct 블록 추출:
            // - typedef\s+struct: "typedef struct" 키워드
            // - (\w+)?: 선택적 구조체 이름 (캡처 그룹 1)
            // - \s*\{([^}]+)\}: 중괄호와 내용 (캡처 그룹 2)
            // - \s*(\w+)\s*;: typedef 별칭 이름 (캡처 그룹 3)
            structPattern: /typedef\s+struct\s+(\w+)?\s*\{([^}]+)\}\s*(\w+)\s*;/g,
            
            // 일반 struct 블록 추출 (typedef 없음):
            // - struct\s+(\w+): "struct 이름" 키워드와 구조체명 (캡처 그룹 1)
            // - \s*\{([^}]+)\}: 중괄호와 내용 (캡처 그룹 2)
            // - \s*;: 세미콜론으로 종료
            plainStructPattern: /struct\s+(\w+)\s*\{([^}]+)\}\s*;/g,
            
            // 필드 추출:
            // - (unsigned\s+)?: 선택적 unsigned 키워드 (캡처 그룹 1)
            // - (\w+): 기본 타입 (char, int 등) (캡처 그룹 2)
            // - \s+(\w+): 필드명 (캡처 그룹 3)
            // - \s*\[\s*(\d+)\s*\]: 배열 크기 (캡처 그룹 4)
            fieldPattern: /(unsigned\s+)?(\w+)\s+(\w+)\s*\[\s*(\d+)\s*\]/g,
            
            // 구조체명에서 숫자 추출: 문자열 끝의 연속된 숫자
            trailingNumber: /(\d+)$/
        };

        /**
         * 정규식 패턴을 복제하여 반환
         * 정규식은 상태를 가지므로(lastIndex), 사용 전 복제 필요
         * @param {string} name - REGEX_CACHE의 키 이름
         * @returns {RegExp} 복제된 정규식 객체
         */
        function getRegex(name) {
            const original = REGEX_CACHE[name];
            return new RegExp(original.source, original.flags);
        }

        /**
         * =====================================================
         * KSC-5601 (EUC-KR) 인코딩/디코딩 유틸리티
         * FULL 타입 처리를 위한 2바이트 완성형 한글 코드 변환
         * =====================================================
         */
        const KSC5601 = {
            /**
             * KSC-5601 바이트 배열을 문자열로 디코딩
             * @param {Uint8Array|string} bytes - 바이트 배열 또는 Latin1 문자열
             * @returns {string} 디코딩된 문자열
             */
            decode: function(bytes) {
                try {
                    // 문자열인 경우 바이트 배열로 변환
                    let byteArray;
                    if (typeof bytes === 'string') {
                        byteArray = new Uint8Array(bytes.length);
                        for (let i = 0; i < bytes.length; i++) {
                            byteArray[i] = bytes.charCodeAt(i) & 0xFF;
                        }
                    } else {
                        byteArray = bytes;
                    }
                    
                    // TextDecoder를 사용하여 EUC-KR 디코딩
                    const decoder = new TextDecoder('euc-kr');
                    return decoder.decode(byteArray);
                } catch (e) {
                    console.warn('KSC5601.decode 오류:', e.message);
                    return bytes;
                }
            },

            /**
             * 문자열을 KSC-5601 2바이트 완성형 바이트 배열로 인코딩
             * 모든 문자가 2바이트로 변환됨 (전각 문자)
             * @param {string} str - 인코딩할 문자열
             * @returns {Uint8Array} KSC-5601 바이트 배열
             */
            encode: function(str) {
                if (!str || str.length === 0) {
                    return new Uint8Array(0);
                }

                const result = [];
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    let code = char.charCodeAt(0);
                    
                    // ============================================
                    // 유니코드 전각 문자를 반각(ASCII)으로 정규화
                    // 한글 IME 상태에서 영문 입력 시 전각으로 들어올 수 있음
                    // ============================================
                    // 전각 공백 (U+3000) → 반각 공백
                    if (code === 0x3000) {
                        code = 0x20;
                    }
                    // 전각 ASCII (U+FF01~U+FF5E) → 반각 ASCII (0x21~0x7E)
                    else if (code >= 0xFF01 && code <= 0xFF5E) {
                        code = code - 0xFF01 + 0x21;
                    }
                    // 전각 숫자 0-9 (U+FF10~U+FF19) → 반각 숫자 (별도 처리 불필요, 위에서 처리됨)
                    // 전각 대문자 A-Z (U+FF21~U+FF3A) → 반각 대문자 (별도 처리 불필요, 위에서 처리됨)
                    // 전각 소문자 a-z (U+FF41~U+FF5A) → 반각 소문자 (별도 처리 불필요, 위에서 처리됨)
                    
                    // ============================================
                    // 정규화된 코드로 KSC-5601 인코딩
                    // ============================================
                    // 공백 → 전각 공백 (0xA1A1)
                    if (code === 0x20) {
                        result.push(0xA1);
                        result.push(0xA1);
                    }
                    // 숫자 0-9 → 전각 숫자 (0xA3B0-0xA3B9)
                    else if (code >= 0x30 && code <= 0x39) {
                        result.push(0xA3);
                        result.push(0xB0 + (code - 0x30));
                    }
                    // 대문자 A-Z → 전각 대문자 (0xA3C1-0xA3DA)
                    else if (code >= 0x41 && code <= 0x5A) {
                        result.push(0xA3);
                        result.push(0xC1 + (code - 0x41));
                    }
                    // 소문자 a-z → 전각 소문자 (0xA3E1-0xA3FA)
                    else if (code >= 0x61 && code <= 0x7A) {
                        result.push(0xA3);
                        result.push(0xE1 + (code - 0x61));
                    }
                    // 기타 ASCII 특수문자 → 전각 특수문자
                    else if (code >= 0x21 && code <= 0x7E) {
                        const fullwidthCode = this.asciiToFullwidth(code);
                        if (fullwidthCode) {
                            result.push((fullwidthCode >> 8) & 0xFF);
                            result.push(fullwidthCode & 0xFF);
                        } else {
                            // 변환 불가 시 전각 물음표
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 한글 완성형 (가-힣: 0xAC00-0xD7A3)
                    else if (code >= 0xAC00 && code <= 0xD7A3) {
                        const kscCode = this.unicodeToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            // 변환 불가 시 전각 물음표 대체
                            console.warn(`KSC-5601 변환 불가: '${char}' (U+${code.toString(16).toUpperCase()}) → 물음표로 대체`);
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 한글 자모 (ㄱ-ㅎ, ㅏ-ㅣ)
                    else if ((code >= 0x3131 && code <= 0x3163)) {
                        const kscCode = this.unicodeJamoToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 기타 2바이트 문자
                    else if (code > 0x7F) {
                        // 특수문자 등의 변환 시도
                        const kscCode = this.unicodeSpecialToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            // 변환 불가 시 전각 물음표 대체
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 제어 문자 등 → 전각 공백으로 대체
                    else {
                        result.push(0xA1);
                        result.push(0xA1);
                    }
                }
                
                return new Uint8Array(result);
            },
            
            /**
             * ASCII 특수문자를 KSC-5601 전각 코드로 변환
             * @param {number} ascii - ASCII 코드 (0x21-0x7E)
             * @returns {number|null} KSC-5601 전각 코드 또는 null
             */
            asciiToFullwidth: function(ascii) {
                // KSC-5601 전각 특수문자 매핑 (0xA3xx 영역)
                const asciiToKsc = {
                    0x21: 0xA3A1, // !
                    0x22: 0xA3A2, // "
                    0x23: 0xA3A3, // #
                    0x24: 0xA3A4, // $
                    0x25: 0xA3A5, // %
                    0x26: 0xA3A6, // &
                    0x27: 0xA3A7, // '
                    0x28: 0xA3A8, // (
                    0x29: 0xA3A9, // )
                    0x2A: 0xA3AA, // *
                    0x2B: 0xA3AB, // +
                    0x2C: 0xA3AC, // ,
                    0x2D: 0xA3AD, // -
                    0x2E: 0xA3AE, // .
                    0x2F: 0xA3AF, // /
                    0x3A: 0xA3BA, // :
                    0x3B: 0xA3BB, // ;
                    0x3C: 0xA3BC, // <
                    0x3D: 0xA3BD, // =
                    0x3E: 0xA3BE, // >
                    0x3F: 0xA3BF, // ?
                    0x40: 0xA3C0, // @
                    0x5B: 0xA3DB, // [
                    0x5C: 0xA3DC, // \
                    0x5D: 0xA3DD, // ]
                    0x5E: 0xA3DE, // ^
                    0x5F: 0xA3DF, // _
                    0x60: 0xA3E0, // `
                    0x7B: 0xA3FB, // {
                    0x7C: 0xA3FC, // |
                    0x7D: 0xA3FD, // }
                    0x7E: 0xA3FE  // ~
                };
                return asciiToKsc[ascii] || null;
            },

            /**
             * KSC-5601 바이트를 Latin1 문자열로 변환 (통전문 생성용)
             * @param {string} str - 인코딩할 문자열
             * @returns {string} Latin1 인코딩된 문자열
             */
            encodeToString: function(str) {
                const bytes = this.encode(str);
                let result = '';
                for (let i = 0; i < bytes.length; i++) {
                    result += String.fromCharCode(bytes[i]);
                }
                return result;
            },

            /**
             * KSC-5601 2바이트 완성형 인코딩된 문자열의 바이트 길이 계산
             * 모든 문자가 2바이트로 처리됨
             * @param {string} str - 문자열
             * @returns {number} 바이트 길이
             */
            getByteLength: function(str) {
                if (!str) return 0;
                // KSC-5601 완성형에서는 모든 문자가 2바이트
                return str.length * 2;
            },

            /**
             * Unicode 한글 완성형을 KSC-5601 코드로 변환
             * @param {number} unicode - Unicode 코드 포인트
             * @returns {number|null} KSC-5601 코드 또는 null
             */
            unicodeToKSC5601: function(unicode) {
                // 한글 완성형 변환 테이블 (가-힣)
                // KSC-5601 한글 완성형은 0xB0A1 ~ 0xC8FE 범위
                // 유니코드 한글 완성형은 0xAC00 ~ 0xD7A3 (11172자)
                // KSC-5601은 2350자만 수록
                
                // KSC-5601 한글 배치표 기반 변환 (테이블 사용)
                if (!this._kscTable) {
                    this._initKSCTable();
                }
                
                return this._kscTable[unicode] || null;
            },

            /**
             * Unicode 자모를 KSC-5601 코드로 변환
             * @param {number} unicode - Unicode 자모 코드
             * @returns {number|null} KSC-5601 코드 또는 null
             */
            unicodeJamoToKSC5601: function(unicode) {
                // 한글 자모 변환 (ㄱ-ㅣ)
                const jamoTable = {
                    0x3131: 0xA4A1, // ㄱ
                    0x3132: 0xA4A2, // ㄲ
                    0x3133: 0xA4A3, // ㄳ
                    0x3134: 0xA4A4, // ㄴ
                    0x3135: 0xA4A5, // ㄵ
                    0x3136: 0xA4A6, // ㄶ
                    0x3137: 0xA4A7, // ㄷ
                    0x3138: 0xA4A8, // ㄸ
                    0x3139: 0xA4A9, // ㄹ
                    0x313A: 0xA4AA, // ㄺ
                    0x313B: 0xA4AB, // ㄻ
                    0x313C: 0xA4AC, // ㄼ
                    0x313D: 0xA4AD, // ㄽ
                    0x313E: 0xA4AE, // ㄾ
                    0x313F: 0xA4AF, // ㄿ
                    0x3140: 0xA4B0, // ㅀ
                    0x3141: 0xA4B1, // ㅁ
                    0x3142: 0xA4B2, // ㅂ
                    0x3143: 0xA4B3, // ㅃ
                    0x3144: 0xA4B4, // ㅄ
                    0x3145: 0xA4B5, // ㅅ
                    0x3146: 0xA4B6, // ㅆ
                    0x3147: 0xA4B7, // ㅇ
                    0x3148: 0xA4B8, // ㅈ
                    0x3149: 0xA4B9, // ㅉ
                    0x314A: 0xA4BA, // ㅊ
                    0x314B: 0xA4BB, // ㅋ
                    0x314C: 0xA4BC, // ㅌ
                    0x314D: 0xA4BD, // ㅍ
                    0x314E: 0xA4BE, // ㅎ
                    0x314F: 0xA4BF, // ㅏ
                    0x3150: 0xA4C0, // ㅐ
                    0x3151: 0xA4C1, // ㅑ
                    0x3152: 0xA4C2, // ㅒ
                    0x3153: 0xA4C3, // ㅓ
                    0x3154: 0xA4C4, // ㅔ
                    0x3155: 0xA4C5, // ㅕ
                    0x3156: 0xA4C6, // ㅖ
                    0x3157: 0xA4C7, // ㅗ
                    0x3158: 0xA4C8, // ㅘ
                    0x3159: 0xA4C9, // ㅙ
                    0x315A: 0xA4CA, // ㅚ
                    0x315B: 0xA4CB, // ㅛ
                    0x315C: 0xA4CC, // ㅜ
                    0x315D: 0xA4CD, // ㅝ
                    0x315E: 0xA4CE, // ㅞ
                    0x315F: 0xA4CF, // ㅟ
                    0x3160: 0xA4D0, // ㅠ
                    0x3161: 0xA4D1, // ㅡ
                    0x3162: 0xA4D2, // ㅢ
                    0x3163: 0xA4D3  // ㅣ
                };
                return jamoTable[unicode] || null;
            },

            /**
             * Unicode 특수문자를 KSC-5601 코드로 변환
             * @param {number} unicode - Unicode 코드
             * @returns {number|null} KSC-5601 코드 또는 null
             */
            unicodeSpecialToKSC5601: function(unicode) {
                // 일부 특수문자 매핑
                const specialTable = {
                    0x00A0: 0xA1A1, // Non-breaking space
                    0x00B7: 0xA1A4, // ·
                    0x2025: 0xA1A5, // ‥
                    0x2026: 0xA1A6, // …
                    0x00A8: 0xA1A7, // ¨
                    0x3001: 0xA1A2, // 、
                    0x3002: 0xA1A3, // 。
                    0xFF01: 0xA3A1, // ！
                    0xFF1F: 0xA3BF  // ？
                };
                return specialTable[unicode] || null;
            },

            /**
             * KSC-5601 한글 변환 테이블 초기화
             * 완성형 한글 2350자를 Unicode -> KSC-5601 매핑
             * 정확한 [유니코드, KSC코드] 쌍 사용
             */
            _initKSCTable: function() {
                this._kscTable = {};
                
                // =====================================================
                // 완전한 KSC-5601 매핑 테이블 동적 생성
                // TextDecoder('euc-kr')를 활용하여 역매핑 테이블 구축
                // 한글 2350자 + 특수문자/기호 완전 지원
                // =====================================================
                
                const decoder = new TextDecoder('euc-kr');
                
                // KSC-5601 한글 영역: 0xB0A1 ~ 0xC8FE
                // 첫째 바이트: 0xB0 ~ 0xC8, 둘째 바이트: 0xA1 ~ 0xFE
                for (let high = 0xB0; high <= 0xC8; high++) {
                    for (let low = 0xA1; low <= 0xFE; low++) {
                        try {
                            const bytes = new Uint8Array([high, low]);
                            const decoded = decoder.decode(bytes);
                            
                            // 유효한 한글 문자인지 확인 (1글자, 유니코드 한글 범위)
                            if (decoded.length === 1) {
                                const unicode = decoded.charCodeAt(0);
                                // 한글 완성형 범위 (가-힣: 0xAC00-0xD7A3)
                                if (unicode >= 0xAC00 && unicode <= 0xD7A3) {
                                    const kscCode = (high << 8) | low;
                                    this._kscTable[unicode] = kscCode;
                                }
                            }
                        } catch (e) {
                            // 디코딩 실패 시 무시
                        }
                    }
                }
                
                // KSC-5601 전각 기호 영역: 0xA1A1 ~ 0xACFE
                // (전각 공백, 전각 숫자, 전각 영문 등)
                for (let high = 0xA1; high <= 0xAC; high++) {
                    for (let low = 0xA1; low <= 0xFE; low++) {
                        try {
                            const bytes = new Uint8Array([high, low]);
                            const decoded = decoder.decode(bytes);
                            
                            if (decoded.length === 1) {
                                const unicode = decoded.charCodeAt(0);
                                // 이미 등록되지 않은 경우에만 추가
                                if (!this._kscTable[unicode] && unicode > 0x7F) {
                                    const kscCode = (high << 8) | low;
                                    this._kscTable[unicode] = kscCode;
                                }
                            }
                        } catch (e) {
                            // 디코딩 실패 시 무시
                        }
                    }
                }
                
                // 전각 숫자 (0~9) 명시적 추가: 0xFF10-0xFF19 → A3B0-A3B9
                for (let i = 0; i <= 9; i++) {
                    this._kscTable[0xFF10 + i] = 0xA3B0 + i;
                }
                
                // 전각 대문자 (A~Z) 명시적 추가: 0xFF21-0xFF3A → A3C1-A3DA
                for (let i = 0; i < 26; i++) {
                    this._kscTable[0xFF21 + i] = 0xA3C1 + i;
                }
                
                // 전각 소문자 (a~z) 명시적 추가: 0xFF41-0xFF5A → A3E1-A3FA
                for (let i = 0; i < 26; i++) {
                    this._kscTable[0xFF41 + i] = 0xA3E1 + i;
                }
                
                // 반각 숫자/영문을 전각으로 변환하는 매핑 추가 (0~9, A~Z, a~z)
                // 전각 모드에서 반각 입력 시 자동 변환용
                for (let i = 0; i <= 9; i++) {
                    if (!this._kscTable[0x30 + i]) {
                        this._kscTable[0x30 + i] = 0xA3B0 + i;  // '0'-'9' → 전각
                    }
                }
                for (let i = 0; i < 26; i++) {
                    if (!this._kscTable[0x41 + i]) {
                        this._kscTable[0x41 + i] = 0xA3C1 + i;  // 'A'-'Z' → 전각
                    }
                    if (!this._kscTable[0x61 + i]) {
                        this._kscTable[0x61 + i] = 0xA3E1 + i;  // 'a'-'z' → 전각
                    }
                }
                
                console.log('KSC-5601 테이블 초기화 완료: ' + Object.keys(this._kscTable).length + '개 매핑');
            },

            /**
             * FULL 타입 필드의 패딩 처리 (바이트 단위)
             * @param {string} value - 입력값
             * @param {number} byteSize - 목표 바이트 크기
             * @returns {string} 패딩된 Latin1 문자열
             */
            padToByteSize: function(value, byteSize) {
                const encoded = this.encodeToString(value);
                const currentByteLength = encoded.length;
                
                if (currentByteLength > byteSize) {
                    // 바이트 단위로 자르기 (2바이트 단위로 정렬)
                    return this.truncateToByteSize(value, byteSize);
                }
                
                if (currentByteLength < byteSize) {
                    // 우측 전각 공백 패딩 (0xA1A1 = 2바이트)
                    // 전각 공백: String.fromCharCode(0xA1, 0xA1)
                    const fullwidthSpace = String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                    const remainingBytes = byteSize - currentByteLength;
                    const paddingCount = Math.floor(remainingBytes / 2);
                    let result = encoded;
                    
                    for (let i = 0; i < paddingCount; i++) {
                        result += fullwidthSpace;
                    }
                    
                    // 홀수 바이트가 남으면 반각 공백으로 채움 (비정상 케이스)
                    if (remainingBytes % 2 === 1) {
                        result += ' ';
                    }
                    
                    return result;
                }
                
                return encoded;
            },

            /**
             * 바이트 크기로 문자열 자르기 (2바이트 경계 유지)
             * @param {string} str - 원본 문자열
             * @param {number} maxBytes - 최대 바이트 수
             * @returns {string} 잘린 Latin1 문자열
             */
            truncateToByteSize: function(str, maxBytes) {
                // 2바이트 경계로 조정 (짝수로 내림)
                const adjustedMaxBytes = Math.floor(maxBytes / 2) * 2;
                
                let result = '';
                let currentBytes = 0;
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    const encoded = this.encodeToString(char);
                    const charBytes = encoded.length; // 항상 2바이트
                    
                    if (currentBytes + charBytes > adjustedMaxBytes) {
                        break;
                    }
                    
                    result += encoded;
                    currentBytes += charBytes;
                }
                
                return result;
            }
        };

        /**
         * =====================================================
         * 구조체 카드 생성 함수
         * 구조체 입력을 위한 카드 DOM 요소 생성
         * - 접기/펼치기 기능 지원
         * - 드래그 앤 드롭 재정렬 지원
         * =====================================================
         * @param {number} index - 구조체 인덱스 번호
         * @returns {HTMLElement} div.struct-card DOM 요소
         */
        function createStructCard(index) {
            // 1. div 생성, class="struct-card", data-index="${index}"
            const div = document.createElement('div');
            div.className = 'struct-card';
            div.setAttribute('data-index', index);
            div.setAttribute('draggable', 'true'); // 드래그 앤 드롭 활성화

            // 2. 내부 HTML 설정 (접기/펼치기 아이콘 및 드래그 핸들 포함)
            div.innerHTML = `
                <div class="struct-card-header">
                    <div class="struct-header-left">
                        <span class="collapse-icon">▼</span>
                        <span class="struct-number">구조체 #${index + 1}</span>
                        <span class="struct-preview"></span>
                    </div>
                    <div class="struct-card-header-actions">
                        <span class="drag-handle" title="드래그하여 순서 변경">⋮⋮</span>
                        <button class="remove-struct-btn" data-index="${index}">✕ 삭제</button>
                    </div>
                </div>
                
                <div class="struct-card-body">
                    <div class="input-row">
                        <label>구조체명 (선택)</label>
                        <input type="text" class="struct-name" placeholder="예: DHF_H, HeaderRecord" />
                    </div>
                    
                    <div class="input-row">
                        <label>구분값 (선택)</label>
                        <input type="text" class="struct-kubun" maxlength="5" placeholder="예: H, 01, HEADER" />
                        <small>여러 구조체 사용 시 필수. 데이터 첫 글자로 구조체 식별</small>
                    </div>
                    
                    <div class="input-row">
                        <label>구조체 정의</label>
                        <textarea class="struct-definition" rows="8" placeholder="typedef struct { ... } 구조체명;"></textarea>
                    </div>
                    
                    <div class="input-row ksc-hint-section">
                        <div class="ksc-hint">
                            <span class="hint-icon">💡</span>
                            <span class="hint-text">
                                <strong>KSC-5601 (한글) 필드</strong>가 있나요?
                                입력 인코딩을 <em>자동 감지</em>하면 KSC-5601 데이터 여부를 판단하고,
                                감지 시 모든 필드를 <code>KSC 전각</code>으로 기본 표시합니다.
                                파싱 결과에서 필드별로 <code>ASCII</code> / <code>KSC 전각</code> / <code>KSC 혼용</code> 변경 가능합니다.
                            </span>
                            <button type="button" class="help-icon-btn" data-help="ksc5601" title="KSC-5601 도움말">
                                <span class="help-icon">?</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // 3. 요소 반환
            return div;
        }

        /**
         * =====================================================
         * XML 규격 파싱 함수
         * XML 문자열을 파싱하여 col 요소 배열로 변환
         * =====================================================
         * @param {string} xmlString - XML 규격 문자열
         * @returns {Array|null} col 요소 배열 또는 null (에러 시)
         */
        function parseXMLSpec(xmlString) {
            // 입력값 유효성 검사
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: 입력값이 문자열이 아닙니다.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: 빈 문자열이 입력되었습니다.');
                return null;
            }

            // DOMParser를 사용해 XML 문서로 변환
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML 파싱 오류:', e.message);
                return null;
            }

            // parsererror 체크
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML 파싱 오류:', parseError.textContent);
                return null;
            }

            // 모든 col 요소 선택
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col 요소를 찾을 수 없습니다.');
                return [];
            }

            // 유효한 col 요소들을 담을 배열
            const result = [];

            // 각 col 요소 처리
            colElements.forEach((col, index) => {
                // 속성 추출
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // 필수 속성 검증
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소에 필수 속성이 누락되었습니다: ${missingAttrs.join(', ')}`
                    );
                    return; // 해당 요소 건너뛰기
                }

                // size를 정수로 변환
                const size = parseInt(sizeAttr, 10);

                // size가 유효한 정수인지 검증
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소의 size 속성이 유효한 숫자가 아닙니다: "${sizeAttr}"`
                    );
                    return; // 해당 요소 건너뛰기
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소의 size 속성이 음수입니다: ${size}`
                    );
                    return; // 해당 요소 건너뛰기
                }

                // 유효한 col 정보를 결과 배열에 추가
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        /**
         * =====================================================
         * 통전문 파싱 함수
         * 통전문 문자열을 XML 규격에 맞게 분리
         * =====================================================
         * @param {string} telegramString - 통전문 문자열
         * @param {Array} xmlSpec - parseXMLSpec의 결과 배열
         * @returns {Array} 파싱된 결과 배열
         */
        /**
         * 입력 데이터가 이미 KSC-5601로 인코딩된 Latin1인지 유니코드인지 감지
         * @param {string} str - 검사할 문자열
         * @returns {boolean} true면 Latin1 (이미 인코딩됨), false면 유니코드
         */
        function isLatin1Encoded(str) {
            // 문자열 내 모든 문자가 0x00-0xFF 범위인지 확인
            for (let i = 0; i < str.length; i++) {
                if (str.charCodeAt(i) > 0xFF) {
                    return false; // 유니코드 문자 발견
                }
            }
            return true;
        }

        /**
         * =====================================================
         * KSC-5601 인코딩 데이터 감지 함수
         * 입력 데이터가 KSC-5601(EUC-KR) 바이트 데이터인지 판단
         * =====================================================
         * 
         * [감지 기준]
         * 1. 모든 문자가 0x00-0xFF 범위 (Latin1 범위)
         * 2. 0x80 이상 바이트가 존재
         * 3. high-byte 쌍이 KSC-5601 범위에 맞는지 확인
         *    - 한글 영역: 첫 바이트 0xB0-0xC8, 둘째 바이트 0xA1-0xFE
         *    - 특수문자 영역: 첫 바이트 0xA1-0xAC, 둘째 바이트 0xA1-0xFE
         *    - 전각 공백: 0xA1 0xA1
         * 
         * @param {string} str - 검사할 문자열
         * @returns {Object} { isKSC5601: boolean, confidence: number, details: string }
         */
        function detectKSC5601Encoding(str) {
            if (!str || str.length === 0) {
                return { isKSC5601: false, confidence: 0, details: '빈 문자열' };
            }

            // 1. 먼저 Latin1 범위 확인 (유니코드 한글이 있으면 KSC-5601 바이트가 아님)
            let hasHighByte = false;
            let hasUnicode = false;
            
            for (let i = 0; i < str.length; i++) {
                const code = str.charCodeAt(i);
                if (code > 0xFF) {
                    hasUnicode = true;
                    break;
                }
                if (code >= 0x80) {
                    hasHighByte = true;
                }
            }

            // 유니코드 문자가 있으면 KSC-5601 바이트 데이터가 아님
            if (hasUnicode) {
                return { 
                    isKSC5601: false, 
                    confidence: 0, 
                    details: '유니코드 문자 발견 - ASCII 또는 UTF-8 데이터' 
                };
            }

            // 0x80 이상 바이트가 없으면 순수 ASCII
            if (!hasHighByte) {
                return { 
                    isKSC5601: false, 
                    confidence: 0, 
                    details: '순수 ASCII 데이터 (0x80 이상 바이트 없음)' 
                };
            }

            // 2. KSC-5601 바이트 패턴 분석
            let ksc5601Pairs = 0;      // 유효한 KSC-5601 바이트 쌍 수
            let invalidPairs = 0;       // 유효하지 않은 바이트 쌍 수
            let hangulPairs = 0;        // 한글 영역 바이트 쌍
            let specialPairs = 0;       // 특수문자/기호 영역 바이트 쌍
            let fullwidthSpaces = 0;    // 전각 공백 (0xA1A1)

            for (let i = 0; i < str.length - 1; i++) {
                const byte1 = str.charCodeAt(i);
                const byte2 = str.charCodeAt(i + 1);

                // high-byte (0x80 이상)로 시작하는 경우만 검사
                if (byte1 >= 0x80) {
                    // 전각 공백 확인 (0xA1 0xA1)
                    if (byte1 === 0xA1 && byte2 === 0xA1) {
                        fullwidthSpaces++;
                        ksc5601Pairs++;
                        i++; // 다음 바이트 건너뛰기
                        continue;
                    }

                    // 한글 영역 확인 (0xB0A1 ~ 0xC8FE)
                    if (byte1 >= 0xB0 && byte1 <= 0xC8 && byte2 >= 0xA1 && byte2 <= 0xFE) {
                        hangulPairs++;
                        ksc5601Pairs++;
                        i++; // 다음 바이트 건너뛰기
                        continue;
                    }

                    // 특수문자/기호 영역 확인 (0xA1A1 ~ 0xACFE)
                    if (byte1 >= 0xA1 && byte1 <= 0xAC && byte2 >= 0xA1 && byte2 <= 0xFE) {
                        specialPairs++;
                        ksc5601Pairs++;
                        i++; // 다음 바이트 건너뛰기
                        continue;
                    }

                    // 한자 영역 (0xCAA1 ~ 0xFDFE)
                    if (byte1 >= 0xCA && byte1 <= 0xFD && byte2 >= 0xA1 && byte2 <= 0xFE) {
                        ksc5601Pairs++;
                        i++; // 다음 바이트 건너뛰기
                        continue;
                    }

                    // 기타 확장 영역 (0xA4A1 ~ 0xA4FE: 한글 자모)
                    if (byte1 === 0xA4 && byte2 >= 0xA1 && byte2 <= 0xFE) {
                        ksc5601Pairs++;
                        i++; // 다음 바이트 건너뛰기
                        continue;
                    }

                    // 유효하지 않은 high-byte 쌍
                    if (byte1 >= 0x80 && byte2 >= 0x80) {
                        invalidPairs++;
                        i++; // 다음 바이트 건너뛰기
                    }
                }
            }

            // 3. 신뢰도 계산
            const totalHighBytePairs = ksc5601Pairs + invalidPairs;
            let confidence = 0;
            let details = '';

            if (totalHighBytePairs > 0) {
                confidence = Math.round((ksc5601Pairs / totalHighBytePairs) * 100);
            }

            // 전각 공백만 있어도 KSC-5601일 가능성 높음
            if (fullwidthSpaces > 0 && invalidPairs === 0) {
                confidence = Math.max(confidence, 80);
            }

            // 한글이 있으면 거의 확실히 KSC-5601
            if (hangulPairs > 0) {
                confidence = Math.max(confidence, 90);
            }

            // 상세 정보 생성
            details = `전각공백: ${fullwidthSpaces}개, 한글: ${hangulPairs}쌍, 특수문자: ${specialPairs}쌍, 유효: ${ksc5601Pairs}쌍, 무효: ${invalidPairs}쌍`;

            // 신뢰도 70% 이상이면 KSC-5601로 판단
            return {
                isKSC5601: confidence >= 70,
                confidence,
                details,
                stats: {
                    fullwidthSpaces,
                    hangulPairs,
                    specialPairs,
                    validPairs: ksc5601Pairs,
                    invalidPairs
                }
            };
        }

        /**
         * =====================================================
         * 필드별 KSC-5601 인코딩 감지 함수
         * 개별 필드의 바이트 데이터가 KSC-5601인지 판단
         * =====================================================
         * 
         * @param {string} fieldBytes - 필드의 바이트 문자열 (Latin1)
         * @param {string} fieldName - 필드명 (로깅용)
         * @returns {Object} { isKSC: boolean, encodingMode: string|null, confidence: number }
         */
        function detectFieldEncoding(fieldBytes, fieldName) {
            // CRLF 필드는 ASCII
            if (fieldName && fieldName.toLowerCase().match(/crlf|cr_lf|newline/)) {
                return { isKSC: false, encodingMode: null, confidence: 0 };
            }

            // 빈 필드 또는 공백만 있는 필드
            if (!fieldBytes || fieldBytes.trim().length === 0) {
                // 전각 공백 체크 (0xA1A1)
                let hasFullwidthSpace = false;
                for (let i = 0; i < fieldBytes.length - 1; i++) {
                    const b1 = fieldBytes.charCodeAt(i);
                    const b2 = fieldBytes.charCodeAt(i + 1);
                    if (b1 === 0xA1 && b2 === 0xA1) {
                        hasFullwidthSpace = true;
                        break;
                    }
                }
                if (hasFullwidthSpace) {
                    return { isKSC: true, encodingMode: 'fullwidth', confidence: 80 };
                }
                return { isKSC: false, encodingMode: null, confidence: 0 };
            }

            // KSC-5601 감지 실행
            const detection = detectKSC5601Encoding(fieldBytes);
            
            if (detection.isKSC5601) {
                // 혼용 모드인지 전각 모드인지 판단
                // ASCII 문자가 섞여있고, 한글이 있으면 혼용 가능성
                let hasAscii = false;
                let hasKSCChar = false;
                
                for (let i = 0; i < fieldBytes.length; i++) {
                    const code = fieldBytes.charCodeAt(i);
                    if (code >= 0x20 && code <= 0x7E) {
                        hasAscii = true;
                    }
                    if (code >= 0x80) {
                        hasKSCChar = true;
                    }
                }
                
                // 기본적으로 전각 모드 (금융/통신 전문 표준)
                // 혼용 모드는 사용자가 필요 시 변경
                return { 
                    isKSC: true, 
                    encodingMode: 'fullwidth',
                    confidence: detection.confidence
                };
            }

            return { isKSC: false, encodingMode: null, confidence: 0 };
        }

        /**
         * =====================================================
         * 입력 데이터 인코딩 타입 자동 감지 및 처리
         * =====================================================
         * 
         * @param {string} dataText - 입력 데이터
         * @returns {Object} { 
         *   type: 'ASCII'|'KSC5601'|'UNICODE', 
         *   data: string,  // 정규화된 데이터 
         *   info: string   // 감지 정보
         * }
         */
        function detectAndNormalizeEncoding(dataText) {
            const detection = detectKSC5601Encoding(dataText);
            
            if (detection.isKSC5601) {
                return {
                    type: 'KSC5601',
                    data: dataText,  // 이미 바이트 데이터이므로 그대로 사용
                    info: `KSC-5601 감지됨 (신뢰도: ${detection.confidence}%) - ${detection.details}`,
                    detection
                };
            }

            // 유니코드 한글이 있는지 확인
            const hasUnicodeHangul = /[\uAC00-\uD7A3]/.test(dataText);
            if (hasUnicodeHangul) {
                return {
                    type: 'UNICODE',
                    data: dataText,
                    info: '유니코드 한글 데이터 감지됨',
                    detection
                };
            }

            return {
                type: 'ASCII',
                data: dataText,
                info: '순수 ASCII 데이터',
                detection
            };
        }

        /**
         * 유니코드 문자열을 KSC-5601 인코딩된 Latin1 문자열로 변환
         * FULL 타입이 아닌 필드는 그대로 유지, FULL 타입만 변환
         * @param {string} telegramString - 원본 통전문
         * @param {Array} xmlSpec - XML 규격 배열
         * @returns {string} 변환된 통전문 (Latin1)
         */
        function convertToKSC5601Telegram(telegramString, xmlSpec) {
            let result = '';
            let unicodePos = 0;
            
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];
                
                if (spec.type === 'FULL') {
                    // FULL 타입: 유니코드 문자를 KSC-5601 바이트로 변환
                    // 바이트 크기 / 2 = 문자 수 (모든 문자가 2바이트)
                    const charCount = Math.floor(spec.size / 2);
                    const unicodeValue = telegramString.substring(unicodePos, unicodePos + charCount);
                    
                    // KSC-5601로 인코딩 후 패딩
                    const encoded = KSC5601.padToByteSize(unicodeValue, spec.size);
                    result += encoded;
                    
                    unicodePos += unicodeValue.length;
                } else {
                    // 일반 타입: 그대로 추출
                    const value = telegramString.substring(unicodePos, unicodePos + spec.size);
                    result += value;
                    unicodePos += spec.size;
                }
            }
            
            return result;
        }

        function parseTelegram(telegramString, xmlSpec) {
            // 현재 위치 초기화
            let currentPos = 0;

            // 빈 결과 배열 생성
            const result = [];
            
            // 입력 데이터가 유니코드인지 이미 인코딩된 Latin1인지 감지
            const isEncoded = isLatin1Encoded(telegramString);
            
            // 유니코드 입력인 경우 FULL 타입 필드가 있으면 변환 필요
            let processedTelegram = telegramString;
            const hasFullType = xmlSpec.some(spec => spec.type === 'FULL');
            
            if (!isEncoded && hasFullType) {
                // 유니코드 입력 + FULL 타입 존재: 변환 수행
                processedTelegram = convertToKSC5601Telegram(telegramString, xmlSpec);
                console.log('parseTelegram: 유니코드 입력을 KSC-5601로 변환했습니다.');
            }

            // xmlSpec 배열 순회
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // 시작/종료 위치 계산
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substring으로 값 추출 (인덱스 범위 초과해도 오류 없이 처리됨)
                const value = processedTelegram.substring(startPos, endPos);

                // 결과 배열에 추가
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // 현재 위치 이동
                currentPos += spec.size;
            }

            // 통전문 전체 길이와 예상 길이 비교
            if (processedTelegram.length !== currentPos) {
                console.warn(
                    `parseTelegram: 통전문 길이(${processedTelegram.length})와 예상 길이(${currentPos})가 일치하지 않습니다.`
                );
            }

            return result;
        }

        /**
         * =====================================================
         * 값 패딩 함수
         * 값을 지정된 크기에 맞게 패딩 (공백으로 채움)
         * =====================================================
         * @param {string} value - 패딩할 값
         * @param {number} size - 목표 크기
         * @param {string} fieldName - 필드명 (로깅용)
         * @returns {string} 패딩된 값
         */
        function padValue(value, size, fieldName) {
            // 값이 없으면 빈 문자열로 설정
            if (value === null || value === undefined) {
                value = '';
            }
            
            // 문자열로 변환
            value = String(value);
            
            // 값이 크기보다 크면 자르기
            if (value.length > size) {
                console.warn('padValue: 필드 "' + fieldName + '"의 값이 크기(' + size + ')를 초과합니다. 값을 자릅니다.');
                return value.substring(0, size);
            }
            
            // 값이 크기보다 작으면 패딩
            if (value.length < size) {
                // 숫자 필드: 좌측 0 패딩
                if (isNumericField(fieldName)) {
                    return value.padStart(size, '0');
                }
                // 문자 필드: 우측 공백 패딩
                return value.padEnd(size, ' ');
            }
            
            // 정확히 일치
            return value;
        }

        /**
         * =====================================================
         * 통전문 생성 함수 (29단계)
         * 필드 배열을 받아서 통전문 문자열 생성
         * CRLF 필드는 개행 인식 옵션에 따라 자동 처리
         * =====================================================
         * @param {Array} fields - 필드 배열 [{name, value, size}, ...]
         * @returns {string} 생성된 통전문 문자열
         */
        function generateTelegram(fields) {
            // 개행문자 인식 옵션 확인
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // 결과 통전문 문자열
            let telegram = '';
            
            // 각 필드 처리
            for (let i = 0; i < fields.length; i++) {
                const field = fields[i];
                
                // CRLF 필드 여부 확인
                if (field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                    // CRLF 필드 자동 처리
                    if (recognizeCRLF) {
                        telegram += '\r\n';  // 무조건 CRLF
                    } else {
                        // 개행 인식 비활성화 시에도 필드는 채워야 함
                        telegram += '  ';    // 공백 2개
                        console.warn('CRLF 필드를 공백으로 채웁니다 (개행 인식 비활성화됨)');
                    }
                } else {
                    // 일반 필드 처리
                    telegram += padValue(field.value, field.size, field.name);
                }
            }
            
            return telegram;
        }

        /**
         * =====================================================
         * C 구조체 정의 파싱 함수
         * 구조체 정의 문자열을 파싱하여 구조체 배열로 변환
         * =====================================================
         * @param {string} structText - C 구조체 정의 문자열
         * @returns {Array|null} 구조체 배열 또는 null (에러 시)
         */
        function parseStructDefinitions(structText) {
            // 입력값 유효성 검사
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 주석 제거 처리 - 캐시된 정규식 사용
            let cleanedText = structText.replace(getRegex('singleLineComment'), '');
            cleanedText = cleanedText.replace(getRegex('blockComment'), '');

            // 2. typedef struct 블록 추출 - 캐시된 정규식 사용
            const structPattern = getRegex('structPattern');
            
            // 타입별 크기 정의 (바이트)
            const typeSizes = {
                'char': 1,
                'unsigned char': 1,
                'short': 2,
                'unsigned short': 2,
                'int': 4,
                'unsigned int': 4,
                'long': 4,
                'unsigned long': 4
            };
            
            // 결과 배열
            const result = [];
            
            /**
             * 필드 추출 헬퍼 함수
             * @param {string} fieldsContent - 중괄호 안의 필드 정의 문자열
             * @param {string} structName - 구조체명 (로깅용)
             * @returns {Array} 필드 배열
             */
            function extractFields(fieldsContent, structName) {
                const fields = [];
                const fieldPattern = getRegex('fieldPattern');
                let fieldMatch;
                
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    const unsignedPrefix = fieldMatch[1] ? fieldMatch[1].trim() : '';
                    const baseType = fieldMatch[2];
                    const fieldName = fieldMatch[3];
                    const arraySize = parseInt(fieldMatch[4], 10);
                    
                    // 전체 타입명 구성
                    const fullType = unsignedPrefix ? unsignedPrefix + ' ' + baseType : baseType;
                    
                    // 타입별 크기 계산
                    let typeSize = typeSizes[fullType] || typeSizes[baseType] || 1;
                    
                    // char 외의 타입은 경고 출력 (하지만 char 기준으로 처리)
                    if (baseType !== 'char') {
                        console.warn('parseStructDefinitions: "' + structName + '"의 필드 "' + fieldName + '"의 타입 "' + fullType + '"은 char로 처리됩니다. 크기 계산이 정확하지 않을 수 있습니다.');
                        // char 기준으로 처리 (배열 크기만 사용)
                        typeSize = 1;
                    }
                    
                    fields.push({
                        name: fieldName,
                        type: fullType,
                        size: arraySize * typeSize
                    });
                }
                
                return fields;
            }
            
            // === 1. typedef struct 블록들 추출 ===
            let structMatch;
            while ((structMatch = structPattern.exec(cleanedText)) !== null) {
                const fieldsContent = structMatch[2]; // 중괄호 안의 내용
                const structName = structMatch[3];    // typedef 구조체명 (마지막 이름)
                
                // 필드 추출
                const fields = extractFields(fieldsContent, structName);
                
                // 빈 구조체 검증 - fields가 0개인 구조체는 제외
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: 구조체 "' + structName + '"에 유효한 필드가 없어 제외됩니다.');
                    continue;
                }
                
                // 구조체 객체 추가
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // === 2. 일반 struct Name {...}; 블록들 추출 ===
            const plainStructPattern = getRegex('plainStructPattern');
            while ((structMatch = plainStructPattern.exec(cleanedText)) !== null) {
                const structName = structMatch[1];    // struct 바로 뒤의 이름
                const fieldsContent = structMatch[2]; // 중괄호 안의 내용
                
                // 이미 typedef로 파싱된 구조체명인지 확인 (중복 방지)
                const isDuplicate = result.some(function(r) { return r.name === structName; });
                if (isDuplicate) {
                    continue;
                }
                
                // 필드 추출
                const fields = extractFields(fieldsContent, structName);
                
                // 빈 구조체 검증 - fields가 0개인 구조체는 제외
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: 구조체 "' + structName + '"에 유효한 필드가 없어 제외됩니다.');
                    continue;
                }
                
                // 구조체 객체 추가
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // 구조체가 하나도 없으면 null 반환
            if (result.length === 0) {
                console.error('parseStructDefinitions: 파싱된 구조체가 없습니다.');
                return null;
            }
            
            // 파싱된 구조체 개수 출력
            console.log('parseStructDefinitions: ' + result.length + '개의 구조체가 파싱되었습니다.');
            
            return result;
        }

        /**
         * =====================================================
         * 단일 C 구조체 정의 파싱 함수
         * 하나의 구조체 정의 문자열을 파싱하여 필드 배열로 변환
         * char 타입만 지원 (unsigned char도 char로 처리)
         * =====================================================
         * @param {string} structText - 단일 C 구조체 정의 문자열
         * @returns {Object|null} { fields: [...], totalSize: number } 또는 null (에러 시)
         */
        function parseStructDefinition(structText) {
            // 입력값 유효성 검사
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinition: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 주석 제거
            // // 주석 제거
            let cleanedText = structText.replace(/\/\/.*$/gm, '');
            // /* */ 주석 제거
            cleanedText = cleanedText.replace(/\/\*[\s\S]*?\*\//g, '');

            // 2. 필드 추출 정규식
            // char 또는 unsigned char 타입의 배열 필드 매칭
            // unsigned char도 char로 처리
            const fieldPattern = /char\s+(\w+)\s*\[\s*(\d+)\s*\]/g;

            // 3. matchAll로 모든 매칭 결과 순회
            const matches = cleanedText.matchAll(fieldPattern);
            const fields = [];

            for (const match of matches) {
                const fieldName = match[1];
                const size = parseInt(match[2], 10);

                // 필드 정보를 fields 배열에 추가
                fields.push({
                    name: fieldName,
                    size: size
                });
            }

            // 4. fields가 비어있으면 null 반환
            if (fields.length === 0) {
                console.error('parseStructDefinition: 유효한 필드가 없습니다.');
                return null;
            }

            // 5. 총 크기 계산
            const totalSize = fields.reduce((sum, f) => sum + f.size, 0);

            // 6. 결과 반환
            return { fields, totalSize };
        }

        /**
         * =====================================================
         * 구조체 정의 수집 함수
         * 모든 구조체 카드에서 정의를 수집하여 배열로 반환
         * =====================================================
         * @returns {Array|null} 구조체 정보 배열 또는 null (에러 시)
         */
        function collectStructDefinitions() {
            // 1. 모든 .struct-card 요소 선택
            const cards = document.querySelectorAll('.struct-card');

            // 2. 빈 배열 structDefs = []
            const structDefs = [];

            // 3. 각 카드마다 처리
            for (let index = 0; index < cards.length; index++) {
                const card = cards[index];

                // a. .struct-name 값 가져오기 (trim)
                const structNameInput = card.querySelector('.struct-name');
                const structName = structNameInput ? structNameInput.value.trim() : '';

                // b. .struct-kubun 값 가져오기 (trim)
                const kubunInput = card.querySelector('.struct-kubun');
                const kubunValue = kubunInput ? kubunInput.value.trim() : '';

                // c. .struct-definition 값 가져오기 (trim)
                const definitionInput = card.querySelector('.struct-definition');
                const definitionText = definitionInput ? definitionInput.value.trim() : '';

                // d. 구조체 정의가 비어있으면 해당 카드 건너뛰기
                if (definitionText === '') {
                    continue;
                }

                // e. parseStructDefinition(정의 텍스트) 호출
                const parsed = parseStructDefinition(definitionText);

                // f. 파싱 성공 시 structDefs에 추가
                if (parsed !== null) {
                    // CRLF 필드 존재 확인
                    const hasCRLFField = parsed.fields.some(function(f) {
                        return f.name.toLowerCase().match(/crlf|cr_lf|newline/);
                    });
                    
                    // 옵션과 일치 여부 확인
                    const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                    const currentName = structName || ('구조체' + (index + 1));
                    
                    if (recognizeCRLF && !hasCRLFField) {
                        console.warn('구조체 "' + currentName + '": 개행 인식 활성화되었으나 crlf 필드 없음');
                    }
                    
                    if (!recognizeCRLF && hasCRLFField) {
                        console.warn('구조체 "' + currentName + '": crlf 필드가 있으나 개행 인식 비활성화됨');
                    }
                    
                    // 필드 정보 매핑
                    // 입력 인코딩 설정에 따라 기본값 결정
                    const inputEncodingSelect = document.getElementById('input-encoding');
                    const inputEncoding = inputEncodingSelect ? inputEncodingSelect.value : 'auto';
                    
                    const fields = parsed.fields.map(function(field) {
                        // 기본값: ASCII, 인코딩 감지 결과에 따라 파싱 시 변경됨
                        return {
                            name: field.name,
                            size: field.size,
                            isKSC: false,
                            encodingMode: null
                        };
                    });
                    
                    structDefs.push({
                        name: currentName,
                        kubun: kubunValue || null,
                        fields: fields,
                        totalSize: parsed.totalSize,
                        hasCRLFField: hasCRLFField
                    });
                } else {
                    // g. 파싱 실패 시 에러 표시 후 null 반환
                    displayError('구조체 #' + (index + 1) + ' 파싱 실패', 'struct-result-container');
                    return null;
                }
            }

            // 4. structDefs가 비어있으면 에러 표시 후 null 반환
            if (structDefs.length === 0) {
                displayError('유효한 구조체가 없습니다', 'struct-result-container');
                return null;
            }

            // 5. 입력 검증 강화
            for (let i = 0; i < structDefs.length; i++) {
                const def = structDefs[i];
                
                // 구조체명에 특수문자 있으면 경고 (영문, 숫자, 언더스코어만 허용)
                if (def.name && !/^[a-zA-Z0-9_가-힣]+$/.test(def.name)) {
                    console.warn('collectStructDefinitions: 구조체 "' + def.name + '"의 이름에 특수문자가 포함되어 있습니다. 예상치 못한 동작이 발생할 수 있습니다.');
                }
                
                // 구분값이 너무 길면 (10자 이상) 경고
                if (def.kubun && def.kubun.length >= 10) {
                    console.warn('collectStructDefinitions: 구조체 "' + def.name + '"의 구분값이 ' + def.kubun.length + '자로 너무 깁니다. 10자 미만을 권장합니다.');
                }
            }

            // 6. 구분값 검증
            if (structDefs.length >= 2) {
                // 구조체가 2개 이상인데 kubun이 null인 것이 있으면 경고
                const hasNullKubun = structDefs.some(function(def) {
                    return def.kubun === null;
                });
                
                if (hasNullKubun) {
                    console.warn('collectStructDefinitions: 여러 구조체 중 구분값이 없는 것이 있습니다. 데이터 매칭이 정확하지 않을 수 있습니다.');
                }

                // 중복된 kubun 값이 있으면 에러
                const kubunValues = structDefs
                    .filter(function(def) { return def.kubun !== null; })
                    .map(function(def) { return def.kubun; });
                
                const duplicates = kubunValues.filter(function(value, idx, arr) {
                    return arr.indexOf(value) !== idx;
                });

                if (duplicates.length > 0) {
                    displayError('중복된 구분값이 있습니다: ' + duplicates.join(', '), 'struct-result-container');
                    return null;
                }

                // 구분값 길이 일관성 검사 (모두 같은 길이 권장)
                const kubunLengths = kubunValues.map(function(k) { return k.length; });
                const uniqueLengths = kubunLengths.filter(function(len, idx, arr) {
                    return arr.indexOf(len) === idx;
                });
                
                if (uniqueLengths.length > 1) {
                    console.warn('collectStructDefinitions: 구분값 길이가 일관되지 않습니다. 길이: ' + uniqueLengths.join(', ') + '. 모두 같은 길이로 통일하는 것을 권장합니다.');
                }
            }

            // 7. structDefs 반환
            console.log('collectStructDefinitions: ' + structDefs.length + '개의 구조체가 수집되었습니다.');
            return structDefs;
        }

        /**
         * =====================================================
         * kubun 기반 구조체 찾기 함수
         * 데이터의 첫 부분을 kubun 값과 비교하여 구조체 탐색
         * =====================================================
         * @param {string} data - 현재 위치부터의 데이터
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object|null} 매칭된 구조체 또는 null
         */
        function findStructByKubun(data, structDefs) {
            // 입력값 유효성 검사
            if (!data || !Array.isArray(structDefs) || structDefs.length === 0) {
                return null;
            }

            // 1. kubun이 있는 구조체들을 kubun 길이 내림차순으로 정렬하여 매칭
            // (긴 kubun을 먼저 매칭해야 "H"와 "HD"가 있을 때 "HD"가 우선 매칭됨)
            const structsWithKubun = structDefs
                .filter(function(s) { return s.kubun !== null && s.kubun !== undefined; })
                .sort(function(a, b) { return b.kubun.length - a.kubun.length; });

            // 2. 정렬된 순서대로 매칭 시도 (긴 kubun부터)
            for (let i = 0; i < structsWithKubun.length; i++) {
                const structDef = structsWithKubun[i];
                const kubun = structDef.kubun;

                // kubun 길이만큼 data에서 추출하여 비교
                const kubunLength = kubun.length;
                const dataKubun = data.substring(0, kubunLength);

                // 매칭되면 해당 구조체 반환
                if (dataKubun === kubun) {
                    return structDef;
                }
            }

            // 3. 모두 실패 시 kubun이 null인 구조체 반환 (fallback)
            for (let i = 0; i < structDefs.length; i++) {
                if (structDefs[i].kubun === null || structDefs[i].kubun === undefined) {
                    return structDefs[i];
                }
            }

            // 4. fallback도 없으면 null 반환
            return null;
        }

        /**
         * =====================================================
         * 매칭 구조체 찾기 함수
         * 데이터 라인의 첫 글자로 매칭되는 구조체 탐색
         * =====================================================
         * @param {string} line - 데이터 라인
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object|null} 매칭된 구조체 또는 null
         */
        function findMatchingStruct(line, structDefs) {
            // 입력값 유효성 검사
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 구조체가 1개만 있으면 그것 반환
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. 여러 개일 경우 매칭 로직
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // 필드가 없으면 건너뛰기
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // 첫 번째 필드의 size만큼 line에서 추출
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // 구조체명에서 구분 패턴 추출
                // 예: DHF_H → 'H', DHF_D → 'D', ST_HEADER_1 → '1'
                const structName = structDef.name;
                
                // 구조체명 마지막 부분 추출 (언더스코어 뒤 또는 마지막 문자/숫자)
                let structIdentifier = '';
                
                // 언더스코어로 분리하여 마지막 부분 추출
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // 마지막 부분이 단일 문자 또는 숫자인 경우
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // 마지막 부분에서 숫자 추출 시도 - 캐시된 정규식 사용
                    const numMatch = lastPart.match(getRegex('trailingNumber'));
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // 마지막 문자 사용
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // 구조체명 마지막 문자/숫자와 line 첫 문자 비교
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // 첫 필드 값과 구조체 식별자 비교
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. 매칭 실패 시 null 반환, 콘솔에 경고
            console.warn('findMatchingStruct: 라인 "' + line.substring(0, 20) + '..."에 매칭되는 구조체를 찾을 수 없습니다.');
            return null;
        }

        /**
         * =====================================================
         * 구조체 데이터 파싱 함수 (메인 진입점)
         * =====================================================
         * 
         * [기능 설명]
         * 개행문자 인식 옵션(recognize-crlf)에 따라 파싱 모드를 결정합니다.
         * 
         * [파싱 모드]
         * 1. 라인 기반 파싱 (개행 인식 ON)
         *    - 각 줄을 독립적인 레코드로 처리
         *    - 줄 끝에 CRLF(2 bytes) 자동 추가
         *    - 길이 부족 시 다음 라인 침범 안 함
         * 
         * 2. 연속 데이터 파싱 (개행 인식 OFF)
         *    - 모든 줄바꿈 제거 후 연속 데이터로 처리
         *    - 구분값(kubun) 기반으로 레코드 분리
         *    - CRLF 필드 없는 구조체 사용
         * 
         * @param {string} dataText - 파싱할 통 데이터 텍스트
         * @param {Array} structDefs - 구조체 정의 배열 [{name, kubun, fields, totalSize}, ...]
         * @returns {Object} 파싱 결과
         *   - records: 파싱된 레코드 배열
         *   - stats: 통계 정보 {totalBytes, parsedBytes, recordCount, errorBytes, mode}
         */
        function parseStructData(dataText, structDefs) {
            // 입력값 유효성 검사
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: 데이터 텍스트가 유효하지 않습니다.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: 구조체 정의가 유효하지 않습니다.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            // =====================================================
            // 재생성된 바이트 데이터 우선 사용 (KSC-5601 데이터 손실 방지)
            // 입력창에 적용 후 바로 재파싱하는 경우 바이트 데이터 사용
            // =====================================================
            if (window.structAppliedFromRegenerate && window.structRegeneratedBytes) {
                // 바이트 데이터를 Latin-1 문자열로 변환하여 파싱에 사용
                let byteData = '';
                for (let i = 0; i < window.structRegeneratedBytes.length; i++) {
                    byteData += String.fromCharCode(window.structRegeneratedBytes[i]);
                }
                dataText = byteData;
                console.log('📌 재생성된 바이트 데이터 사용 (KSC-5601 바이트 보존)');
                console.log(`📌 바이트 길이: ${window.structRegeneratedBytes.length}`);
                
                // 플래그 초기화 (한 번만 사용)
                window.structAppliedFromRegenerate = false;
            }

            // 1. 옵션 읽기
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            const inputEncodingSelect = document.getElementById('input-encoding');
            const inputEncoding = inputEncodingSelect ? inputEncodingSelect.value : 'auto';

            // 2. 인코딩 감지 (자동 감지 모드인 경우)
            let encodingInfo = { type: 'ASCII', info: '순수 ASCII 데이터' };
            
            if (inputEncoding === 'auto') {
                // 자동 감지
                encodingInfo = detectAndNormalizeEncoding(dataText);
                console.log(`🔤 인코딩 자동 감지: ${encodingInfo.type} - ${encodingInfo.info}`);
            } else if (inputEncoding === 'ksc5601') {
                // 수동으로 KSC-5601 선택
                encodingInfo = { 
                    type: 'KSC5601', 
                    info: 'KSC-5601 (수동 선택)',
                    data: dataText
                };
                console.log('🔤 인코딩 수동 선택: KSC-5601');
            } else {
                // ASCII 선택
                encodingInfo = { 
                    type: 'ASCII', 
                    info: 'ASCII (수동 선택)',
                    data: dataText
                };
                console.log('🔤 인코딩 수동 선택: ASCII');
            }

            // 3. 필드별 인코딩 자동 감지로 변경
            //    전체 데이터 감지 결과는 참고용으로만 사용
            //    각 필드는 파싱 시 개별적으로 인코딩 감지됨
            if (encodingInfo.type === 'KSC5601') {
                console.log('📌 KSC-5601 데이터 감지됨: 필드별로 개별 인코딩 감지를 수행합니다.');
            }
            // 주의: 모든 필드를 강제로 KSC로 설정하지 않음
            // 필드별 감지는 parseLineByLine/parseContinuous에서 수행

            // 4. 데이터 전처리 및 파싱 분기
            let result;
            if (recognizeCRLF) {
                // === 라인 기반 파싱 ===
                result = parseLineByLine(dataText, structDefs, encodingInfo);
            } else {
                // === 연속 데이터 파싱 ===
                result = parseContinuous(dataText, structDefs, encodingInfo);
            }

            // 5. 인코딩 정보를 결과에 추가
            result.stats.encodingType = encodingInfo.type;
            result.stats.encodingInfo = encodingInfo.info;
            
            // structDefs도 결과에 포함 (필드별 인코딩 설정 정보 유지)
            result.structDefs = structDefs;

            return result;
        }

        /**
         * =====================================================
         * KSC-5601 전각 디코딩 함수
         * EUC-KR 인코딩된 바이트를 유니코드 문자열로 변환
         * (decodeToKSCFullwidth의 래퍼 - 통합된 디코딩 함수 사용)
         * =====================================================
         * @param {string} bytes - 디코딩할 바이트 문자열
         * @returns {string} 디코딩된 문자열
         */
        function decodeKSC5601Fullwidth(bytes) {
            return decodeToKSCFullwidth(bytes);
        }

        /**
         * =====================================================
         * KSC-5601 혼용 디코딩 함수
         * 한글은 2바이트, ASCII는 1바이트로 처리
         * (decodeToKSCMixed의 래퍼 - 통합된 디코딩 함수 사용)
         * =====================================================
         * @param {string} bytes - 디코딩할 바이트 문자열
         * @returns {string} 디코딩된 문자열
         */
        function decodeKSC5601Mixed(bytes) {
            return decodeToKSCMixed(bytes);
        }

        /**
         * =====================================================
         * KSC-5601 혼용 모드 바이트 계산 함수
         * 한글은 2바이트, ASCII는 1바이트로 계산
         * =====================================================
         * @param {string} str - 계산할 문자열
         * @returns {number} 바이트 수
         */
        function calculateKSCMixedBytes(str) {
            let bytes = 0;
            for (let i = 0; i < str.length; i++) {
                const code = str.charCodeAt(i);
                // 한글 (가-힣) 또는 기타 멀티바이트
                if ((code >= 0xAC00 && code <= 0xD7A3) || code > 0x7F) {
                    bytes += 2;
                } else {
                    bytes += 1;
                }
            }
            return bytes;
        }

        /**
         * =====================================================
         * KSC-5601 전각 패딩 함수
         * 모든 문자를 2바이트로 처리하여 패딩
         * =====================================================
         * @param {string} value - 패딩할 문자열
         * @param {number} size - 목표 바이트 크기
         * @returns {string} 패딩된 문자열
         */
        function padKSC5601Fullwidth(value, size) {
            const maxChars = Math.floor(size / 2);
            if (value.length > maxChars) {
                return value.substring(0, maxChars);
            }
            if (value.length < maxChars) {
                // 부족한 글자 수만큼 공백 (전각 공백 또는 일반 공백 2개)
                const paddingChars = maxChars - value.length;
                return value + ' '.repeat(paddingChars * 2);
            }
            return value;
        }

        /**
         * =====================================================
         * KSC-5601 혼용 패딩 함수
         * 한글 2바이트, ASCII 1바이트로 계산하여 패딩
         * =====================================================
         * @param {string} value - 패딩할 문자열
         * @param {number} size - 목표 바이트 크기
         * @returns {string} 패딩된 문자열
         */
        function padKSC5601Mixed(value, size) {
            const byteLength = calculateKSCMixedBytes(value);
            if (byteLength > size) {
                // 바이트 단위로 자르기
                return truncateByKSCBytes(value, size);
            }
            if (byteLength < size) {
                // ASCII 공백으로 패딩
                return value + ' '.repeat(size - byteLength);
            }
            return value;
        }

        /**
         * =====================================================
         * KSC-5601 바이트 단위 문자열 자르기
         * 멀티바이트 문자 경계를 고려하여 자름
         * =====================================================
         * @param {string} str - 자를 문자열
         * @param {number} maxBytes - 최대 바이트 수
         * @returns {string} 잘린 문자열
         */
        function truncateByKSCBytes(str, maxBytes) {
            let bytes = 0;
            let result = '';
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                const code = char.charCodeAt(0);
                const charBytes = ((code >= 0xAC00 && code <= 0xD7A3) || code > 0x7F) ? 2 : 1;
                
                if (bytes + charBytes <= maxBytes) {
                    result += char;
                    bytes += charBytes;
                } else {
                    break;
                }
            }
            return result;
        }

        /**
         * =====================================================
         * 라인 기반 파싱 함수 (개행 인식 ON 모드)
         * =====================================================
         * 
         * [처리 흐름]
         * 1. 이스케이프 처리 (\\r\\n → \r\n)
         * 2. 줄 단위 분리 (CRLF/LF 기준)
         * 3. 각 라인별 구조체 매칭 (구분값 기반)
         * 4. 필드별 데이터 추출
         * 5. 길이 검증 (부족/초과 시 경고)
         * 
         * [특징]
         * - 각 라인은 독립적으로 처리 (다음 라인 침범 안 함)
         * - 라인 끝에 CRLF(2 bytes) 자동 추가됨
         * - 매칭 실패 시 에러 레코드로 기록
         * - 길이 부족 시 경고만 표시하고 파싱은 진행
         * 
         * [에러 처리]
         * - 구조체 매칭 실패: 에러 레코드 생성, 다음 라인으로 진행
         * - 길이 부족/초과: 콘솔 경고, 가능한 만큼 파싱
         * 
         * @param {string} dataText - 통 데이터 텍스트 (줄바꿈 포함)
         * @param {Array} structDefs - 구조체 정의 배열
         * @param {Object} encodingInfo - 인코딩 정보 { type: 'ASCII'|'KSC5601'|'UNICODE', info: string }
         * @returns {Object} { records: [...], stats: {...} } 형식의 파싱 결과
         */
        function parseLineByLine(dataText, structDefs, encodingInfo) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            const isKSC5601Mode = encodingInfo && encodingInfo.type === 'KSC5601';
            
            // 1. 이스케이프 처리
            let processedText = dataText
                .replace(/\\r\\n/g, '\r\n')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r');

            // 2. 줄 단위로 분리
            // 주의: trimEnd()로 우측 공백이 제거되면 고정 길이 레코드의 경우
            // 길이 불일치 경고가 발생할 수 있음 (파싱은 정상 진행됨)
            const lines = processedText.split(/\r?\n/)
                .map(line => line.replace(/\r+$/, ''))  // 줄 끝 캐리지 리턴만 제거 (공백 유지)
                .filter(line => line.length > 0);  // 빈 줄 제거

            console.log(`라인 기반 파싱: 총 ${lines.length}개 라인`);
            
            // 디버그 모드: 초기 정보 로깅
            if (isDebugMode) {
                console.group('🔍 파싱 디버그 - Line By Line 모드');
                console.log('📋 모드:', 'line-by-line');
                console.log('🔤 인코딩:', encodingInfo ? `${encodingInfo.type} - ${encodingInfo.info}` : 'ASCII (기본)');
                console.log('📊 전체 라인 수:', lines.length);
                console.log('📐 정의된 구조체:', structDefs.map(s => `${s.name}(구분값:${s.kubun})`).join(', '));
                console.log('---');
                
                lines.forEach((line, i) => {
                    console.log(`📝 라인 ${i+1}:`, {
                        length: line.length,
                        kubun: line[0] || '(없음)',
                        preview: line.substring(0, 30) + (line.length > 30 ? '...' : ''),
                        hex: Array.from(line.substring(0, 10)).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ')
                    });
                });
                console.log('---');
            }
            
            // KSC-5601 모드일 때 안내 메시지
            if (isKSC5601Mode) {
                console.log('📌 KSC-5601 바이트 데이터 모드: 필드 크기는 바이트 단위로 처리됩니다.');
            }

            // 3. 변수 초기화
            const records = [];
            let recordIndex = 0;
            let totalBytes = 0;
            let parsedBytes = 0;
            let errorLines = 0;

            // 4. 각 라인 순회
            lines.forEach((line, lineIndex) => {
                totalBytes += line.length + 2;  // +2 for CRLF

                // 구조체 매칭
                const matched = findStructByKubun(line, structDefs);

                if (!matched) {
                    console.warn(`라인 ${lineIndex + 1}: 매칭 실패 - "${line.substring(0, 20)}..."`);
                    errorLines++;
                    
                    // 디버그: 매칭 실패 상세 정보
                    if (isDebugMode) {
                        console.warn(`  ❌ 구분값 '${line[0]}'에 해당하는 구조체 없음`);
                        console.warn(`  📋 등록된 구분값들:`, structDefs.map(s => s.kubun));
                    }

                    // 에러 레코드 추가
                    records.push({
                        error: true,
                        lineNumber: lineIndex + 1,
                        lineData: line,
                        message: '매칭되는 구조체 없음'
                    });
                    return;  // 다음 라인으로
                }

                // 디버그: 매칭된 구조체 정보
                if (isDebugMode) {
                    console.group(`✅ 라인 ${lineIndex + 1} → ${matched.name}`);
                    console.log('📌 구분값:', matched.kubun);
                    console.log('📏 필드 수:', matched.fields.length);
                }

                // 길이 검증
                const expectedSize = matched.totalSize;
                const actualSize = line.length + 2;  // CRLF 포함

                // 디버그: 길이 비교
                if (isDebugMode) {
                    const lengthStatus = actualSize === expectedSize ? '✅ 일치' : 
                                        actualSize < expectedSize ? '⚠️ 부족' : '⚠️ 초과';
                    console.log(`📐 길이 비교: 예상=${expectedSize}, 실제=${actualSize} ${lengthStatus}`);
                }

                if (actualSize < expectedSize) {
                    console.warn(
                        `라인 ${lineIndex + 1}: 길이 부족 ` +
                        `(예상: ${expectedSize}, 실제: ${actualSize})`
                    );
                } else if (actualSize > expectedSize) {
                    console.warn(
                        `라인 ${lineIndex + 1}: 길이 초과 ` +
                        `(예상: ${expectedSize}, 실제: ${actualSize})`
                    );
                }

                // 라인 데이터에 CRLF 추가
                const lineWithCRLF = line + '\r\n';

                // 필드별 파싱
                let fieldOffset = 0;
                
                // 디버그: 필드 파싱 시작
                if (isDebugMode) {
                    console.log('📋 필드별 추출:');
                }
                
                matched.fields.forEach(field => {
                    const startPos = fieldOffset;
                    const endPos = startPos + field.size;
                    const rawBytes = lineWithCRLF.substring(startPos, endPos);
                    
                    // 필드별 인코딩 자동 감지
                    let fieldIsKSC = field.isKSC;
                    let fieldEncodingMode = field.encodingMode;
                    
                    // 1. 먼저 저장된 타입 오버라이드 확인 (재파싱 시 타입 유지)
                    const overrideKey = matched.name + '_' + field.name;
                    if (window.structFieldTypeOverrides && window.structFieldTypeOverrides[overrideKey]) {
                        const savedType = window.structFieldTypeOverrides[overrideKey];
                        if (savedType.startsWith('KSC-5601')) {
                            fieldIsKSC = true;
                            fieldEncodingMode = savedType.includes('전각') ? 'fullwidth' : 'mixed';
                            if (isDebugMode) {
                                console.log(`  📌 필드 "${field.name}" 타입 복원: ${savedType}`);
                            }
                        }
                    }
                    // 2. 구조체 정의에서 명시적으로 설정되지 않은 경우에만 자동 감지
                    else if (!field.isKSC) {
                        const fieldDetection = detectFieldEncoding(rawBytes, field.name);
                        if (fieldDetection.isKSC) {
                            fieldIsKSC = true;
                            fieldEncodingMode = fieldDetection.encodingMode;
                            if (isDebugMode) {
                                console.log(`  🔍 필드 "${field.name}" KSC-5601 자동 감지 (신뢰도: ${fieldDetection.confidence}%)`);
                            }
                        }
                    }
                    
                    // 표시용 값
                    let displayValue = rawBytes;
                    
                    // 입력 데이터가 유니코드인지 확인 (한글 유니코드 범위: 0xAC00-0xD7A3)
                    const isUnicodeInput = rawBytes.split('').some(c => {
                        const code = c.charCodeAt(0);
                        return code >= 0xAC00 && code <= 0xD7A3;
                    });
                    
                    // KSC-5601 필드 처리 (자동 감지 또는 명시적 설정)
                    if (fieldIsKSC && !isUnicodeInput) {
                        // 바이트 데이터인 경우에만 디코딩
                        if (fieldEncodingMode === 'fullwidth') {
                            // 전각 전용: 모든 문자 2 bytes
                            displayValue = decodeKSC5601Fullwidth(rawBytes);
                        } else if (fieldEncodingMode === 'mixed') {
                            // 혼용: 한글 2 bytes, ASCII 1 byte
                            displayValue = decodeKSC5601Mixed(rawBytes);
                        }
                    }
                    // 유니코드 입력인 경우 그대로 표시 (이미 디코딩된 상태)
                    
                    // 디버그: 각 필드 값 로깅
                    if (isDebugMode) {
                        const hexValue = Array.from(rawBytes).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
                        const debugDisplay = rawBytes.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                        console.log(`  📍 ${field.name}[${field.size}]: "${debugDisplay}" | HEX: ${hexValue}${fieldIsKSC ? ' | KSC: "' + displayValue + '"' : ''}${isUnicodeInput ? ' (유니코드)' : ''}`);
                    }

                    records.push({
                        recordIndex,
                        lineNumber: lineIndex + 1,
                        structName: matched.name,
                        kubun: matched.kubun,
                        fieldName: field.name,
                        fieldSize: field.size,
                        fieldType: fieldIsKSC 
                            ? 'KSC-5601 (' + (fieldEncodingMode === 'fullwidth' ? '전각' : '혼용') + ')'
                            : 'ASCII',
                        value: displayValue.trim(),
                        rawValue: isUnicodeInput ? null : rawBytes,  // 유니코드 입력 시 rawValue는 null (재생성 시 새로 인코딩)
                        startPos,
                        endPos,
                        isKSC: fieldIsKSC,
                        encodingMode: fieldEncodingMode
                    });

                    fieldOffset += field.size;
                });
                
                // 디버그: 그룹 종료
                if (isDebugMode) {
                    console.groupEnd();
                }

                parsedBytes += Math.min(actualSize, expectedSize);
                recordIndex++;
            });

            // 5. 통계 계산
            const stats = {
                totalBytes,
                parsedBytes,
                recordCount: recordIndex,
                errorLines,
                mode: 'line-by-line'
            };
            
            // 디버그: 최종 통계 로깅
            if (isDebugMode) {
                console.log('---');
                console.log('📊 파싱 완료 통계:', {
                    모드: stats.mode,
                    전체바이트: stats.totalBytes,
                    파싱바이트: stats.parsedBytes,
                    레코드수: stats.recordCount,
                    에러라인: stats.errorLines
                });
                console.groupEnd();
            }

            // 6. 반환
            return { records, stats };
        }

        /**
         * =====================================================
         * 연속 데이터 파싱 함수 (개행 인식 OFF 모드)
         * =====================================================
         * 
         * [처리 흐름]
         * 1. 전처리: 모든 줄바꿈 제거 (\r, \n)
         * 2. 현재 위치에서 구조체 매칭 (구분값 기반)
         * 3. 매칭 성공: 필드별 데이터 추출, 구조체 크기만큼 이동
         * 4. 매칭 실패: 1바이트 스킵, 에러 바이트 카운트 증가
         * 5. 데이터 끝까지 반복
         * 
         * [특징]
         * - 줄바꿈이 완전히 무시됨
         * - 구조체에 CRLF 필드가 없어야 함
         * - 구분값으로 레코드 시작점 탐지
         * - 연속된 여러 레코드 자동 분리
         * 
         * [에러 처리]
         * - 구조체 매칭 실패: 1바이트 스킵 후 재시도
         * - 에러 바이트 수 통계에 누적
         * - 과도한 에러 로그 방지 (최대 10개까지만 출력)
         * 
         * [사용 예시]
         * - CRLF 없는 구조체: "H881234567D1234567890123456..." 형태
         * - 구분값 H, D, T 등으로 레코드 분리
         * 
         * @param {string} dataText - 통 데이터 텍스트 (줄바꿈 포함 가능)
         * @param {Array} structDefs - 구조체 정의 배열 (CRLF 필드 없음)
         * @param {Object} encodingInfo - 인코딩 정보 { type: 'ASCII'|'KSC5601'|'UNICODE', info: string }
         * @returns {Object} { records: [...], stats: {...} } 형식의 파싱 결과
         */
        function parseContinuous(dataText, structDefs, encodingInfo) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            const isKSC5601Mode = encodingInfo && encodingInfo.type === 'KSC5601';
            
            // 1. 전처리: 모든 개행 제거
            const processedData = dataText.replace(/[\r\n]/g, '');
            console.log(`연속 파싱: 총 ${processedData.length} bytes`);
            
            // KSC-5601 모드일 때 안내 메시지
            if (isKSC5601Mode) {
                console.log('📌 KSC-5601 바이트 데이터 모드: 필드 크기는 바이트 단위로 처리됩니다.');
            }
            
            // 디버그 모드: 초기 정보 로깅
            if (isDebugMode) {
                console.group('🔍 파싱 디버그 - Continuous 모드');
                console.log('📋 모드:', 'continuous');
                console.log('🔤 인코딩:', encodingInfo ? `${encodingInfo.type} - ${encodingInfo.info}` : 'ASCII (기본)');
                console.log('📊 전체 데이터 길이:', processedData.length, 'bytes');
                console.log('📐 정의된 구조체:', structDefs.map(s => `${s.name}(구분값:${s.kubun}, 크기:${s.totalSize})`).join(', '));
                console.log('📝 데이터 미리보기:', processedData.substring(0, 50) + (processedData.length > 50 ? '...' : ''));
                console.log('📝 HEX 미리보기:', Array.from(processedData.substring(0, 20)).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' '));
                console.log('---');
            }

            // 2. 변수 초기화
            const records = [];
            let currentPos = 0;
            let recordIndex = 0;
            let errorBytes = 0;

            // 3. 메인 루프
            while (currentPos < processedData.length) {
                const remainingData = processedData.substring(currentPos);

                // 구조체 매칭
                const matched = findStructByKubun(remainingData, structDefs);

                if (!matched) {
                    // 디버그: 매칭 실패 정보
                    if (isDebugMode && errorBytes < 10) { // 너무 많은 로그 방지
                        console.warn(`  ❌ 위치 ${currentPos}: 구분값 '${remainingData[0]}'에 매칭 실패, 1바이트 스킵`);
                    }
                    errorBytes++;
                    currentPos++;
                    continue;
                }
                
                // 디버그: 매칭된 구조체 정보
                if (isDebugMode) {
                    console.group(`✅ 레코드 ${recordIndex + 1} (위치: ${currentPos}) → ${matched.name}`);
                    console.log('📌 구분값:', matched.kubun);
                    console.log('📏 구조체 크기:', matched.totalSize, 'bytes');
                    
                    // 길이 비교
                    const remainingLength = processedData.length - currentPos;
                    const lengthStatus = remainingLength >= matched.totalSize ? '✅ 충분' : '⚠️ 부족';
                    console.log(`📐 길이 비교: 필요=${matched.totalSize}, 남은 데이터=${remainingLength} ${lengthStatus}`);
                    console.log('📋 필드별 추출:');
                }

                // 필드 파싱
                let fieldOffset = 0;
                matched.fields.forEach(field => {
                    const startPos = currentPos + fieldOffset;
                    const endPos = startPos + field.size;
                    const rawBytes = processedData.substring(startPos, endPos);
                    
                    // 필드별 인코딩 자동 감지
                    let fieldIsKSC = field.isKSC;
                    let fieldEncodingMode = field.encodingMode;
                    
                    // 1. 먼저 저장된 타입 오버라이드 확인 (재파싱 시 타입 유지)
                    const overrideKey = matched.name + '_' + field.name;
                    if (window.structFieldTypeOverrides && window.structFieldTypeOverrides[overrideKey]) {
                        const savedType = window.structFieldTypeOverrides[overrideKey];
                        if (savedType.startsWith('KSC-5601')) {
                            fieldIsKSC = true;
                            fieldEncodingMode = savedType.includes('전각') ? 'fullwidth' : 'mixed';
                            if (isDebugMode) {
                                console.log(`  📌 필드 "${field.name}" 타입 복원: ${savedType}`);
                            }
                        }
                    }
                    // 2. 구조체 정의에서 명시적으로 설정되지 않은 경우에만 자동 감지
                    else if (!field.isKSC) {
                        const fieldDetection = detectFieldEncoding(rawBytes, field.name);
                        if (fieldDetection.isKSC) {
                            fieldIsKSC = true;
                            fieldEncodingMode = fieldDetection.encodingMode;
                            if (isDebugMode) {
                                console.log(`  🔍 필드 "${field.name}" KSC-5601 자동 감지 (신뢰도: ${fieldDetection.confidence}%)`);
                            }
                        }
                    }
                    
                    // 표시용 값
                    let displayValue = rawBytes;
                    
                    // 입력 데이터가 유니코드인지 확인 (한글 유니코드 범위: 0xAC00-0xD7A3)
                    const isUnicodeInput = rawBytes.split('').some(c => {
                        const code = c.charCodeAt(0);
                        return code >= 0xAC00 && code <= 0xD7A3;
                    });
                    
                    // KSC-5601 필드 처리 (자동 감지 또는 명시적 설정)
                    if (fieldIsKSC && !isUnicodeInput) {
                        // 바이트 데이터인 경우에만 디코딩
                        if (fieldEncodingMode === 'fullwidth') {
                            // 전각 전용: 모든 문자 2 bytes
                            displayValue = decodeKSC5601Fullwidth(rawBytes);
                        } else if (fieldEncodingMode === 'mixed') {
                            // 혼용: 한글 2 bytes, ASCII 1 byte
                            displayValue = decodeKSC5601Mixed(rawBytes);
                        }
                    }
                    // 유니코드 입력인 경우 그대로 표시 (이미 디코딩된 상태)
                    
                    // 디버그: 각 필드 값 로깅
                    if (isDebugMode) {
                        const hexValue = Array.from(rawBytes).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
                        const debugDisplay = rawBytes.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                        console.log(`  📍 ${field.name}[${field.size}]: "${debugDisplay}" | HEX: ${hexValue}${fieldIsKSC ? ' | KSC: "' + displayValue + '"' : ''}${isUnicodeInput ? ' (유니코드)' : ''}`);
                    }

                    records.push({
                        recordIndex,
                        structName: matched.name,
                        kubun: matched.kubun,
                        fieldName: field.name,
                        fieldSize: field.size,
                        fieldType: fieldIsKSC 
                            ? 'KSC-5601 (' + (fieldEncodingMode === 'fullwidth' ? '전각' : '혼용') + ')'
                            : 'ASCII',
                        value: displayValue.trim(),
                        rawValue: isUnicodeInput ? null : rawBytes,  // 유니코드 입력 시 rawValue는 null (재생성 시 새로 인코딩)
                        isKSC: fieldIsKSC,
                        encodingMode: fieldEncodingMode,
                        startPos,
                        endPos
                    });

                    fieldOffset += field.size;
                });
                
                // 디버그: 그룹 종료
                if (isDebugMode) {
                    console.groupEnd();
                }

                currentPos += matched.totalSize;
                recordIndex++;
            }

            // 4. 통계
            const stats = {
                totalBytes: processedData.length,
                parsedBytes: processedData.length - errorBytes,
                recordCount: recordIndex,
                errorBytes,
                mode: 'continuous'
            };
            
            // 디버그: 최종 통계 로깅
            if (isDebugMode) {
                console.log('---');
                console.log('📊 파싱 완료 통계:', {
                    모드: stats.mode,
                    전체바이트: stats.totalBytes,
                    파싱바이트: stats.parsedBytes,
                    레코드수: stats.recordCount,
                    에러바이트: stats.errorBytes
                });
                if (errorBytes > 0) {
                    console.warn(`⚠️ ${errorBytes}바이트가 매칭되지 않았습니다.`);
                }
                console.groupEnd();
            }

            // 5. 반환
            return { records, stats };
        }

        /**
         * =====================================================
         * 에러 메시지 표시 함수
         * 지정된 컨테이너에 에러 메시지 표시
         * =====================================================
         * @param {string} message - 에러 메시지
         * @param {string} targetContainer - 타겟 컨테이너 ID (기본: struct-result-container)
         */
        function displayError(message, targetContainer) {
            // 1. targetContainer 가져오기 (기본값: struct-result-container)
            const containerId = targetContainer || 'struct-result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTML을 에러 메시지로 설정
            container.innerHTML = `<div class="error-message">⚠️ ${message}</div>`;
        }

        /**
         * =====================================================
         * XML 파싱 결과 표시 함수
         * DocumentFragment를 사용하여 DOM 조작 최적화
         * 편집 가능한 값 셀 및 통데이터 재생성 기능 포함
         * =====================================================
         * @param {Array} parsedData - parseTelegram의 결과 배열
         */
        function displayResults(parsedData) {
            // 1. result-container 요소 가져오기
            const container = document.getElementById('result-container');

            // 2. innerHTML 초기화
            container.innerHTML = '';

            // 원본 데이터 저장 (재생성 시 사용)
            window.xmlParsedDataOriginal = JSON.parse(JSON.stringify(parsedData));
            window.xmlParsedDataCurrent = parsedData;

            // DocumentFragment 생성 - DOM 조작 최적화
            const fragment = document.createDocumentFragment();

            // 편집 힌트 추가
            const hintDiv = document.createElement('div');
            hintDiv.className = 'edit-hint';
            hintDiv.innerHTML = '<span class="hint-icon">💡</span> <span>값 셀을 클릭하여 직접 수정할 수 있습니다. FULL 타입(KSC-5601)은 수정이 제한됩니다.</span>';
            fragment.appendChild(hintDiv);

            // 3. table 요소 생성
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead 생성 후 tr 추가, th 7개
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['순번', '필드명', '타입', '크기', '시작', '종료', '값'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody 생성
            const tbody = document.createElement('tbody');

            // 6. parsedData 배열 순회
            parsedData.forEach(function(item, index) {
                // tr 생성
                const tr = document.createElement('tr');
                tr.setAttribute('data-field-index', index);

                // FULL 타입인 경우 값을 KSC-5601 디코딩
                let displayValue = item.value;
                let decodedValue = null;
                
                if (item.type === 'FULL' && item.value) {
                    try {
                        decodedValue = KSC5601.decode(item.value);
                    } catch (e) {
                        console.warn('KSC-5601 디코딩 실패:', e);
                    }
                }

                // td 7개 생성
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    displayValue
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    
                    // 값 컬럼 (마지막 컬럼)
                    if (tdIndex === 6) {
                        // FULL 타입: 편집 불가 (인코딩 문제)
                        if (item.type === 'FULL') {
                            td.classList.add('readonly-value');
                            if (decodedValue) {
                                // 디코딩된 한글 텍스트 표시
                                const decodedSpan = document.createElement('span');
                                decodedSpan.textContent = decodedValue;
                                decodedSpan.style.fontWeight = 'bold';
                                decodedSpan.style.color = '#6f42c1';
                                td.appendChild(decodedSpan);
                                
                                // HEX 값 (작은 글씨로)
                                const hexSpan = document.createElement('small');
                                hexSpan.style.display = 'block';
                                hexSpan.style.color = '#666';
                                hexSpan.style.fontSize = '11px';
                                const hexValue = Array.from(item.value.substring(0, 20))
                                    .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                                    .join(' ');
                                hexSpan.textContent = 'HEX: ' + hexValue + (item.value.length > 20 ? '...' : '');
                                td.appendChild(hexSpan);
                                
                                // FULL 타입 편집 불가 안내
                                const infoSpan = document.createElement('small');
                                infoSpan.style.display = 'block';
                                infoSpan.style.color = '#999';
                                infoSpan.style.fontSize = '10px';
                                infoSpan.textContent = '(FULL 타입: 편집 불가)';
                                td.appendChild(infoSpan);
                            } else {
                                td.textContent = value;
                            }
                        } else {
                            // 일반 타입: 편집 가능
                            td.classList.add('editable-value');
                            td.setAttribute('contenteditable', 'true');
                            td.setAttribute('data-field-index', index);
                            td.setAttribute('data-original-value', value);
                            td.setAttribute('data-field-size', item.size);
                            td.setAttribute('data-field-type', item.type);
                            td.textContent = value;
                            
                            // 수정 감지 이벤트
                            td.addEventListener('input', function() {
                                const originalValue = this.getAttribute('data-original-value');
                                const currentValue = this.textContent;
                                
                                if (currentValue !== originalValue) {
                                    this.classList.add('modified');
                                    // 현재 파싱 데이터 업데이트
                                    const fieldIndex = parseInt(this.getAttribute('data-field-index'));
                                    window.xmlParsedDataCurrent[fieldIndex].value = currentValue;
                                } else {
                                    this.classList.remove('modified');
                                }
                                
                                // 수정 카운터 업데이트
                                updateXMLModifiedCount();
                            });
                            
                            // 포커스 아웃 시 길이 검증
                            td.addEventListener('blur', function() {
                                const fieldSize = parseInt(this.getAttribute('data-field-size'));
                                const fieldType = this.getAttribute('data-field-type');
                                let currentValue = this.textContent;
                                
                                // 길이 초과 시 자르기
                                if (currentValue.length > fieldSize) {
                                    currentValue = currentValue.substring(0, fieldSize);
                                    this.textContent = currentValue;
                                }
                                
                                // N 타입이면서 숫자가 아닌 경우 경고
                                if (fieldType === 'N' && currentValue && !/^[0-9]*$/.test(currentValue)) {
                                    this.style.borderColor = '#ffc107';
                                    this.title = '숫자 타입 필드입니다. 숫자만 입력하세요.';
                                } else {
                                    this.style.borderColor = '';
                                    this.title = '';
                                }
                                
                                // 현재 파싱 데이터 업데이트
                                const fieldIndex = parseInt(this.getAttribute('data-field-index'));
                                window.xmlParsedDataCurrent[fieldIndex].value = currentValue;
                            });
                        }
                        
                        // value가 공백만 있으면 class="empty-value" 추가
                        if (typeof value === 'string' && value.trim() === '') {
                            td.classList.add('empty-value');
                        }
                    } else {
                        td.textContent = value;
                    }

                    tr.appendChild(td);
                });

                // tbody에 tr 추가
                tbody.appendChild(tr);
            });

            // 7. table에 thead, tbody 추가
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. 반응형을 위한 wrapper div 생성
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. fragment에 추가
            fragment.appendChild(wrapper);

            // 10. 수정 반영 컨트롤 추가
            const reflectContainer = document.createElement('div');
            reflectContainer.className = 'reflect-changes-container';
            reflectContainer.id = 'xml-reflect-container';
            reflectContainer.innerHTML = `
                <div class="reflect-info">
                    <span>수정된 필드:</span>
                    <span class="modified-count no-changes" id="xml-modified-count">0개</span>
                </div>
                <div class="reflect-buttons">
                    <button class="btn-reset-changes" id="xml-reset-changes-btn" disabled>
                        ↩️ 원래대로
                    </button>
                    <button class="btn-reflect" id="xml-reflect-btn" disabled>
                        ✅ 통데이터 재생성
                    </button>
                </div>
            `;
            fragment.appendChild(reflectContainer);

            // 11. 재생성된 통데이터 표시 영역 (초기에는 숨김)
            const regeneratedContainer = document.createElement('div');
            regeneratedContainer.className = 'regenerated-data-container';
            regeneratedContainer.id = 'xml-regenerated-container';
            regeneratedContainer.style.display = 'none';
            fragment.appendChild(regeneratedContainer);

            // 12. 한 번에 DOM 업데이트
            container.appendChild(fragment);

            // 13. 버튼 이벤트 연결
            attachXMLReflectEvents();
        }

        /**
         * XML 파싱 결과 수정 카운터 업데이트
         */
        function updateXMLModifiedCount() {
            const modifiedCells = document.querySelectorAll('#result-table .editable-value.modified');
            const countSpan = document.getElementById('xml-modified-count');
            const reflectBtn = document.getElementById('xml-reflect-btn');
            const resetBtn = document.getElementById('xml-reset-changes-btn');
            
            if (countSpan) {
                countSpan.textContent = modifiedCells.length + '개';
                
                if (modifiedCells.length > 0) {
                    countSpan.classList.remove('no-changes');
                    reflectBtn.disabled = false;
                    resetBtn.disabled = false;
                } else {
                    countSpan.classList.add('no-changes');
                    reflectBtn.disabled = true;
                    resetBtn.disabled = true;
                }
            }
        }

        /**
         * XML 파싱 결과 수정 반영 이벤트 연결
         */
        function attachXMLReflectEvents() {
            // 원래대로 버튼
            const resetBtn = document.getElementById('xml-reset-changes-btn');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    // 원본 데이터로 복원
                    window.xmlParsedDataCurrent = JSON.parse(JSON.stringify(window.xmlParsedDataOriginal));
                    
                    // 수정된 셀 초기화
                    const modifiedCells = document.querySelectorAll('#result-table .editable-value.modified');
                    modifiedCells.forEach(function(cell) {
                        const originalValue = cell.getAttribute('data-original-value');
                        cell.textContent = originalValue;
                        cell.classList.remove('modified');
                    });
                    
                    // 카운터 업데이트
                    updateXMLModifiedCount();
                    
                    // 재생성 결과 숨기기
                    document.getElementById('xml-regenerated-container').style.display = 'none';
                    
                    showTemporaryMessage('✓ 원래 값으로 복원되었습니다.');
                });
            }
            
            // 통데이터 재생성 버튼
            const reflectBtn = document.getElementById('xml-reflect-btn');
            if (reflectBtn) {
                reflectBtn.addEventListener('click', function() {
                    regenerateXMLTelegram();
                });
            }
        }

        /**
         * XML 파싱 결과를 기반으로 통데이터 재생성
         */
        /**
         * XML 파싱 결과를 기반으로 통데이터 재생성
         * KSC-5601 (FULL 타입) 필드의 글자 깨짐 방지를 위해 바이트 배열 기반으로 처리
         */
        function regenerateXMLTelegram() {
            const parsedData = window.xmlParsedDataCurrent;
            
            if (!parsedData || parsedData.length === 0) {
                showTemporaryMessage('재생성할 데이터가 없습니다.');
                return;
            }
            
            // 바이트 배열로 데이터 생성 (KSC-5601 깨짐 방지)
            const byteArrays = [];
            let totalBytes = 0;
            let hasFullType = false;
            
            // 각 필드를 순서대로 조합
            parsedData.forEach(function(field) {
                let value = field.value || '';
                const size = field.size;
                const type = field.type;
                
                // FULL 타입: KSC-5601 인코딩 적용
                if (type === 'FULL') {
                    hasFullType = true;
                    // 원본 바이트 데이터를 Uint8Array로 변환
                    const bytes = new Uint8Array(size);
                    for (let i = 0; i < value.length && i < size; i++) {
                        bytes[i] = value.charCodeAt(i) & 0xFF;
                    }
                    // 전각 공백(0xA1A1)으로 패딩
                    let pos = value.length;
                    while (pos + 2 <= size) {
                        bytes[pos] = 0xA1;
                        bytes[pos + 1] = 0xA1;
                        pos += 2;
                    }
                    if (pos < size) {
                        bytes[pos] = 0x20;
                    }
                    byteArrays.push(bytes);
                    totalBytes += size;
                    return;
                }
                
                // 패딩 처리
                if (value.length < size) {
                    if (type === 'N') {
                        // 숫자 타입: 왼쪽 0 패딩
                        value = '0'.repeat(size - value.length) + value;
                    } else {
                        // 문자 타입: 오른쪽 공백 패딩
                        value = value + ' '.repeat(size - value.length);
                    }
                } else if (value.length > size) {
                    // 길이 초과 시 자르기
                    value = value.substring(0, size);
                }
                
                // ASCII 바이트 배열로 변환
                const bytes = new Uint8Array(size);
                for (let i = 0; i < value.length && i < size; i++) {
                    bytes[i] = value.charCodeAt(i) & 0xFF;
                }
                byteArrays.push(bytes);
                totalBytes += size;
            });
            
            // 모든 바이트 배열을 하나로 합치기
            const regeneratedBytes = new Uint8Array(totalBytes);
            let offset = 0;
            byteArrays.forEach(function(bytes) {
                regeneratedBytes.set(bytes, offset);
                offset += bytes.length;
            });
            
            // Latin-1 문자열로 변환 (입력창에 적용할 때 사용)
            let regeneratedData = '';
            for (let i = 0; i < regeneratedBytes.length; i++) {
                regeneratedData += String.fromCharCode(regeneratedBytes[i]);
            }
            
            // 표시용 데이터 생성 (KSC-5601 디코딩하여 한글로 표시)
            let displayText = '';
            if (hasFullType) {
                // FULL 타입이 있으면 디코딩하여 표시
                displayText = KSC5601.decode(regeneratedBytes);
            } else {
                // ASCII 전용이면 그대로 표시
                displayText = regeneratedData;
            }
            
            // 결과 표시
            const container = document.getElementById('xml-regenerated-container');
            container.style.display = 'block';
            container.innerHTML = `
                <h4>✅ 재생성된 통데이터</h4>
                <div class="regenerated-data-content" id="xml-regenerated-data">${escapeHtml(displayText)}</div>
                <div style="margin-top: 10px; font-size: 13px; color: #666;">
                    총 ${totalBytes} bytes
                    ${hasFullType ? ' | <span style="color: #7b1fa2;">KSC-5601 (FULL) 포함</span>' : ''}
                </div>
                <div class="regenerated-actions">
                    <button class="btn-copy-regenerated" id="copy-xml-regenerated">
                        📋 클립보드에 복사
                    </button>
                    <button class="btn-apply-to-input" id="apply-xml-to-input">
                        📥 입력창에 적용
                    </button>
                    <button class="btn-download-regenerated" id="download-xml-regenerated" style="background: #6c757d;">
                        💾 파일로 저장
                    </button>
                </div>
            `;
            
            // 바이트 배열을 전역에 저장 (복사/다운로드용)
            window.xmlRegeneratedBytes = regeneratedBytes;
            window.xmlRegeneratedData = regeneratedData;
            
            // 복사 버튼 이벤트
            document.getElementById('copy-xml-regenerated').addEventListener('click', function() {
                navigator.clipboard.writeText(regeneratedData).then(function() {
                    showTemporaryMessage('✓ 클립보드에 복사되었습니다. (바이트 데이터 유지)');
                }).catch(function(err) {
                    console.error('클립보드 복사 실패:', err);
                    showTemporaryMessage('⚠️ 복사 실패. 파일로 저장을 이용해주세요.');
                });
            });
            
            // 입력창에 적용 버튼 이벤트
            document.getElementById('apply-xml-to-input').addEventListener('click', function() {
                const telegramInput = document.getElementById('telegram-input');
                if (telegramInput) {
                    telegramInput.value = regeneratedData;
                    showTemporaryMessage('✓ 통데이터 입력창에 적용되었습니다.');
                }
            });
            
            // 파일 다운로드 버튼 이벤트 (바이너리 데이터 정확히 저장)
            document.getElementById('download-xml-regenerated').addEventListener('click', function() {
                const blob = new Blob([regeneratedBytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'telegram_data.dat';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTemporaryMessage('✓ 파일로 저장되었습니다. (바이트 데이터 정확히 보존)');
            });
            
            // 스크롤 이동
            container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        /**
         * =====================================================
         * calculateRecordLength(record, mode)
         * =====================================================
         * 레코드의 실제 길이를 계산
         * @param {Object} record - 레코드 객체 (fields 배열 포함)
         * @param {string} mode - 파싱 모드 ('line-by-line' 또는 'continuous')
         * @returns {number} 레코드의 실제 바이트 길이
         */
        function calculateRecordLength(record, mode) {
            if (!record || !record.fields || !Array.isArray(record.fields)) {
                return 0;
            }
            
            // 모든 필드 크기 합계
            let totalSize = record.fields.reduce(function(sum, field) {
                return sum + (field.fieldSize || 0);
            }, 0);
            
            return totalSize;
        }

        /**
         * =====================================================
         * getExpectedLength(structName, structDefs)
         * =====================================================
         * 구조체 정의에서 예상 길이를 가져옴
         * @param {string} structName - 구조체 이름
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {number} 예상 바이트 길이
         */
        function getExpectedLength(structName, structDefs) {
            if (!structName || !Array.isArray(structDefs)) {
                return 0;
            }
            
            const struct = structDefs.find(function(s) {
                return s.name === structName;
            });
            
            return struct ? struct.totalSize : 0;
        }

        /**
         * =====================================================
         * escapeHtml(text)
         * =====================================================
         * HTML 특수문자를 이스케이프 처리 (XSS 방지)
         * 
         * @param {string} text - 이스케이프할 텍스트
         * @returns {string} 이스케이프된 텍스트
         */
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * =====================================================
         * escapeForDisplay(str)
         * =====================================================
         * 문자열의 특수문자를 표시용 이스케이프 시퀀스로 변환
         * 
         * @param {string} str - 변환할 문자열
         * @returns {string} 이스케이프된 문자열
         */
        function escapeForDisplay(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/\r/g, '\\r')
                .replace(/\n/g, '\\n')
                .replace(/\t/g, '\\t');
        }

        /**
         * =====================================================
         * toHexPreview(str)
         * =====================================================
         * 문자열의 앞부분을 HEX로 변환하여 미리보기 생성
         * 
         * @param {string} str - 변환할 문자열
         * @returns {string} HEX 미리보기 문자열 (최대 16바이트)
         */
        function toHexPreview(str) {
            if (typeof str !== 'string') return '';
            const hex = Array.from(str.substring(0, 16))
                .map(function(c) {
                    return c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                })
                .join(' ');
            
            return hex + (str.length > 16 ? ' ...' : '');
        }

        /**
         * =====================================================
         * formatFieldValue(value, isCRLFField)
         * =====================================================
         * 필드 값을 표시용으로 포맷팅
         * - CRLF 필드: 특수문자를 이스케이프 시퀀스로 표시 (\r\n)
         * - 일반 필드: 공백 여부만 확인
         * 
         * @param {string} value - 필드 값
         * @param {boolean} isCRLFField - CRLF 필드 여부
         * @returns {string} 포맷팅된 값
         */
        function formatFieldValue(value, isCRLFField) {
            if (typeof value !== 'string') {
                return value;
            }
            
            // CRLF 필드인 경우 특수문자를 이스케이프 표시
            if (isCRLFField) {
                // \r\n → "\\r\\n" 형태로 표시
                return value
                    .replace(/\r/g, '\\r')
                    .replace(/\n/g, '\\n');
            }
            
            // 일반 필드: 그대로 반환
            return value;
        }

        /**
         * =====================================================
         * createLengthBadge(record, structDefs, mode)
         * =====================================================
         * 길이 검증 뱃지 HTML을 생성
         * @param {Object} record - 레코드 객체
         * @param {Array} structDefs - 구조체 정의 배열
         * @param {string} mode - 파싱 모드
         * @returns {string} 뱃지 HTML 문자열
         */
        function createLengthBadge(record, structDefs, mode) {
            const actualLength = calculateRecordLength(record, mode);
            const expectedLength = getExpectedLength(record.structName, structDefs);
            
            if (expectedLength === 0) {
                return '<span class="length-badge warning">? 길이 정보 없음</span>';
            }
            
            if (actualLength === expectedLength) {
                return '<span class="length-badge success">\u2713 ' + actualLength + 'B</span>';
            } else if (actualLength < expectedLength) {
                return '<span class="length-badge warning">\u26a0\ufe0f ' + actualLength + 'B / ' + expectedLength + 'B (부족)</span>';
            } else {
                return '<span class="length-badge error">\u26a0\ufe0f ' + actualLength + 'B / ' + expectedLength + 'B (초과)</span>';
            }
        }

        /**
         * =====================================================
         * 구조체 파싱 결과 표시 함수
         * DocumentFragment를 사용하여 DOM 조작 최적화
         * 편집 가능한 값 셀 및 통데이터 재생성 기능 포함
         * =====================================================
         * @param {Object} parseResult - { records, stats, structDefs } 형식의 파싱 결과
         *   - records: 레코드 배열 (각 레코드: { recordIndex, structName, kubun, fields })
         *   - stats: 통계 정보 { totalBytes, parsedBytes, recordCount, errorBytes }
         *   - structDefs: 구조체 정의 배열
         */

        /**
         * 필드 디코딩 모드 드롭다운 HTML 생성 함수
         * @param {string} fieldType - 현재 필드 타입 ('ASCII', 'KSC-5601 (전각)', 'KSC-5601 (혼용)')
         * @param {number} recordIndex - 레코드 인덱스
         * @param {number} fieldIndex - 필드 인덱스
         * @returns {string} 드롭다운 HTML
         */
        function createDecodingModeDropdown(fieldType, recordIndex, fieldIndex) {
            // 현재 선택된 값 결정
            let currentValue = 'ascii';
            if (fieldType && fieldType.startsWith('KSC-5601')) {
                currentValue = fieldType.includes('전각') ? 'fullwidth' : 'mixed';
            }
            
            return `
                <select class="decoding-mode-select" 
                        data-record-index="${recordIndex}" 
                        data-field-index="${fieldIndex}">
                    <option value="ascii" ${currentValue === 'ascii' ? 'selected' : ''}>ASCII</option>
                    <option value="fullwidth" ${currentValue === 'fullwidth' ? 'selected' : ''}>KSC 전각</option>
                    <option value="mixed" ${currentValue === 'mixed' ? 'selected' : ''}>KSC 혼용</option>
                </select>
            `;
        }

        /**
         * KSC-5601 전각 모드 디코딩 (결과 화면용)
         * @param {string} rawBytes - 원본 바이트 문자열
         * @returns {string} 디코딩된 문자열
         */
        function decodeToKSCFullwidth(rawBytes) {
            try {
                // 문자열을 바이트 배열로 변환
                const bytes = new Uint8Array(rawBytes.length);
                for (let i = 0; i < rawBytes.length; i++) {
                    bytes[i] = rawBytes.charCodeAt(i) & 0xFF;
                }
                
                // EUC-KR 디코딩
                const decoder = new TextDecoder('euc-kr');
                return decoder.decode(bytes);
            } catch (e) {
                console.error('KSC 전각 디코딩 실패:', e);
                return rawBytes;
            }
        }

        /**
         * KSC-5601 혼용 모드 디코딩 (결과 화면용)
         * @param {string} rawBytes - 원본 바이트 문자열
         * @returns {string} 디코딩된 문자열
         */
        function decodeToKSCMixed(rawBytes) {
            try {
                let result = '';
                let i = 0;
                
                while (i < rawBytes.length) {
                    const byte1 = rawBytes.charCodeAt(i) & 0xFF;
                    
                    // 한글 바이트 범위 (EUC-KR: 0xB0-0xC8 첫 바이트, 0xA1-0xFE 두번째)
                    // 또는 확장 범위 (0x81-0xFE)
                    if (byte1 >= 0x81 && byte1 <= 0xFE && i + 1 < rawBytes.length) {
                        const byte2 = rawBytes.charCodeAt(i + 1) & 0xFF;
                        if (byte2 >= 0x41) {
                            // 2바이트 문자로 처리
                            const bytes = new Uint8Array([byte1, byte2]);
                            const decoder = new TextDecoder('euc-kr');
                            result += decoder.decode(bytes);
                            i += 2;
                            continue;
                        }
                    }
                    
                    // ASCII 문자 (1바이트)
                    result += rawBytes.charAt(i);
                    i++;
                }
                
                return result;
            } catch (e) {
                console.error('KSC 혼용 디코딩 실패:', e);
                return rawBytes;
            }
        }

        /**
         * 디코딩 모드에 따라 값을 재해석
         * @param {string} rawBytes - 원본 바이트 문자열
         * @param {string} mode - 디코딩 모드 ('ascii', 'fullwidth', 'mixed')
         * @returns {string} 디코딩된 값
         */
        function decodeByMode(rawBytes, mode) {
            if (!rawBytes) return '';
            
            switch (mode) {
                case 'fullwidth':
                    return decodeToKSCFullwidth(rawBytes);
                case 'mixed':
                    return decodeToKSCMixed(rawBytes);
                case 'ascii':
                default:
                    return rawBytes;
            }
        }

        /**
         * 필드 타입에 따른 바이트 길이 계산
         * @param {string} text - 계산할 문자열
         * @param {string} fieldType - 필드 타입 ('ASCII', 'KSC-5601 (전각)', 'KSC-5601 (혼용)')
         * @returns {number} 바이트 길이
         */
        function calculateByteLength(text, fieldType) {
            if (!text) return 0;
            
            if (fieldType && fieldType.startsWith('KSC-5601')) {
                if (fieldType.includes('전각')) {
                    // KSC-5601 전각: 모든 문자 2바이트
                    return text.length * 2;
                } else {
                    // KSC-5601 혼용: 한글/특수 2바이트, ASCII 1바이트
                    let bytes = 0;
                    for (let i = 0; i < text.length; i++) {
                        const code = text.charCodeAt(i);
                        if (code < 0x80) {
                            // ASCII (공백 포함)
                            if (code === 0x20) {
                                bytes += 2;  // 공백은 전각 공백으로 2바이트
                            } else {
                                bytes += 1;
                            }
                        } else {
                            bytes += 2;  // 한글, 특수문자 등
                        }
                    }
                    return bytes;
                }
            }
            
            // ASCII: 1바이트
            return text.length;
        }

        /**
         * 필드 타입에 따라 바이트 단위로 문자열 자르기
         * @param {string} text - 자를 문자열
         * @param {number} maxBytes - 최대 바이트 수
         * @param {string} fieldType - 필드 타입
         * @returns {string} 잘린 문자열
         */
        function truncateToByteSize(text, maxBytes, fieldType) {
            if (!text) return '';
            
            if (fieldType && fieldType.startsWith('KSC-5601')) {
                if (fieldType.includes('전각')) {
                    // KSC-5601 전각: 모든 문자 2바이트
                    const maxChars = Math.floor(maxBytes / 2);
                    return text.substring(0, maxChars);
                } else {
                    // KSC-5601 혼용: 바이트 단위로 계산하며 자르기
                    let result = '';
                    let bytes = 0;
                    
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        const code = char.charCodeAt(0);
                        let charBytes;
                        
                        if (code < 0x80) {
                            charBytes = (code === 0x20) ? 2 : 1;
                        } else {
                            charBytes = 2;
                        }
                        
                        if (bytes + charBytes > maxBytes) break;
                        
                        result += char;
                        bytes += charBytes;
                    }
                    return result;
                }
            }
            
            // ASCII: 문자 = 바이트
            return text.substring(0, maxBytes);
        }

        /**
         * 유니코드 한글을 EUC-KR 바이트로 변환 (혼용 모드용)
         * 한글만 EUC-KR로 변환, ASCII는 처리하지 않음
         * @param {string} char - 단일 문자
         * @returns {string|null} EUC-KR 2바이트 문자열 또는 null
         */
        function unicodeToEUCKR(char) {
            try {
                const code = char.charCodeAt(0);
                
                // 한글 완성형 (가-힣: 0xAC00-0xD7A3)
                if (code >= 0xAC00 && code <= 0xD7A3) {
                    const kscCode = KSC5601.unicodeToKSC5601(code);
                    if (kscCode) {
                        return String.fromCharCode((kscCode >> 8) & 0xFF) + 
                               String.fromCharCode(kscCode & 0xFF);
                    }
                }
                
                // 한글 자모 (ㄱ-ㅣ: 0x3131-0x3163)
                if (code >= 0x3131 && code <= 0x3163) {
                    const kscCode = KSC5601.unicodeJamoToKSC5601(code);
                    if (kscCode) {
                        return String.fromCharCode((kscCode >> 8) & 0xFF) + 
                               String.fromCharCode(kscCode & 0xFF);
                    }
                }
                
                return null;
            } catch (e) {
                console.warn('unicodeToEUCKR 변환 실패:', char, e);
                return null;
            }
        }

        /**
         * KSC-5601 전각 모드 인코딩 (재생성용)
         * KSC5601 라이브러리를 사용하여 유니코드 문자열을 EUC-KR 바이트로 인코딩
         * @param {string} text - 인코딩할 문자열
         * @param {number} size - 필드 크기 (바이트)
         * @returns {string} 인코딩된 바이트 문자열
         */
        function encodeToKSCFullwidth(text, size) {
            try {
                // KSC5601 라이브러리의 padToByteSize 사용 (전각 모드)
                return KSC5601.padToByteSize(text, size);
            } catch (e) {
                console.error('KSC 전각 인코딩 실패:', e);
                return text.padEnd(size, ' ').substring(0, size);
            }
        }

        /**
         * KSC-5601 혼용 모드 인코딩 (재생성용)
         * 한글은 2바이트 (EUC-KR), ASCII는 1바이트로 인코딩
         * 단, 공백은 전각 공백(A1A1, 2바이트)으로 처리 (KSC-5601 표준)
         * @param {string} text - 인코딩할 문자열
         * @param {number} size - 필드 크기 (바이트)
         * @returns {string} 인코딩된 바이트 문자열
         */
        function encodeToKSCMixed(text, size) {
            try {
                let result = '';
                let byteCount = 0;
                
                for (let i = 0; i < text.length && byteCount < size; i++) {
                    const char = text[i];
                    const code = char.charCodeAt(0);
                    
                    // 공백: 전각 공백 A1A1 (2바이트) - KSC-5601 표준
                    if (code === 0x20) {
                        if (byteCount + 2 <= size) {
                            result += String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                            byteCount += 2;
                        }
                    } else if (code < 0x80) {
                        // 기타 ASCII (숫자, 영문 등): 1바이트 그대로
                        if (byteCount + 1 <= size) {
                            result += char;
                            byteCount += 1;
                        }
                    } else if (code >= 0xAC00 && code <= 0xD7A3) {
                        // 한글 완성형: KSC5601 테이블로 EUC-KR 2바이트 인코딩
                        if (byteCount + 2 <= size) {
                            const kscCode = KSC5601.unicodeToKSC5601(code);
                            if (kscCode) {
                                // 상위 바이트, 하위 바이트
                                result += String.fromCharCode((kscCode >> 8) & 0xFF);
                                result += String.fromCharCode(kscCode & 0xFF);
                            } else {
                                // 변환 불가 시 전각 공백 (EUC-KR에 없는 한글)
                                result += String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                                console.warn('KSC-5601에 없는 한글:', char, '(U+' + code.toString(16).toUpperCase() + ')');
                            }
                            byteCount += 2;
                        }
                    } else if (code >= 0x3131 && code <= 0x3163) {
                        // 한글 자모 (ㄱ-ㅣ): KSC5601 자모 테이블로 인코딩
                        if (byteCount + 2 <= size) {
                            const kscCode = KSC5601.unicodeJamoToKSC5601(code);
                            if (kscCode) {
                                result += String.fromCharCode((kscCode >> 8) & 0xFF);
                                result += String.fromCharCode(kscCode & 0xFF);
                            } else {
                                result += String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                            }
                            byteCount += 2;
                        }
                    } else {
                        // 기타 비ASCII 문자: 2바이트로 처리
                        if (byteCount + 2 <= size) {
                            // KSC5601 전각으로 시도
                            const encoded = KSC5601.encodeToString(char);
                            if (encoded && encoded.length === 2) {
                                result += encoded;
                            } else {
                                // 변환 불가 시 전각 공백
                                result += String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                            }
                            byteCount += 2;
                        }
                    }
                }
                
                // 패딩 처리 (전각 공백 A1A1으로)
                while (byteCount + 2 <= size) {
                    result += String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                    byteCount += 2;
                }
                // 홀수 바이트 남으면 ASCII 공백으로 (비정상 케이스)
                if (byteCount < size) {
                    result += ' ';
                    byteCount++;
                }
                
                return result;
            } catch (e) {
                console.error('KSC 혼용 인코딩 실패:', e);
                return text.padEnd(size, ' ').substring(0, size);
            }
        }

        /**
         * 인코딩 모드에 따라 값을 인코딩 (재생성용)
         * @param {string} value - 인코딩할 값
         * @param {string} fieldType - 필드 타입 ('ASCII', 'KSC-5601 (전각)', 'KSC-5601 (혼용)')
         * @param {number} size - 필드 크기
         * @param {string} rawValue - 원본 바이트 값 (KSC 필드의 경우)
         * @returns {string} 인코딩된 바이트 문자열
         */
        function encodeByFieldType(value, fieldType, size, rawValue) {
            // KSC 필드 처리 (rawValue 유무와 관계없이)
            if (fieldType && fieldType.startsWith('KSC-5601')) {
                const mode = fieldType.includes('전각') ? 'fullwidth' : 'mixed';
                
                // rawValue가 있고 값이 변경되지 않았으면 원본 바이트 사용
                if (rawValue) {
                    const originalDecoded = decodeByMode(rawValue, mode).trim();
                    
                    if (value === originalDecoded) {
                        // 원본 바이트 길이 맞추기
                        if (rawValue.length < size) {
                            if (mode === 'fullwidth') {
                                let padded = rawValue;
                                while (padded.length < size) {
                                    if (padded.length + 2 <= size) {
                                        padded += String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                                    } else {
                                        padded += ' ';
                                    }
                                }
                                return padded.substring(0, size);
                            } else {
                                return rawValue + ' '.repeat(size - rawValue.length);
                            }
                        } else if (rawValue.length > size) {
                            return rawValue.substring(0, size);
                        }
                        return rawValue;
                    }
                }
                
                // 값이 변경되었거나 rawValue가 없는 경우: 새로 인코딩
                console.log(`KSC 인코딩: mode=${mode}, value="${value}", size=${size}`);
                if (mode === 'fullwidth') {
                    return encodeToKSCFullwidth(value, size);
                } else {
                    return encodeToKSCMixed(value, size);
                }
            }
            
            // ASCII 모드 (기본)
            if (value.length < size) {
                return value + ' '.repeat(size - value.length);
            } else if (value.length > size) {
                return value.substring(0, size);
            }
            return value;
        }

        /**
         * 인코딩 모드에 따라 값을 바이트 배열로 인코딩 (재생성용)
         * KSC-5601 필드의 글자 깨짐 방지를 위해 Uint8Array 반환
         * @param {string} value - 인코딩할 값
         * @param {string} fieldType - 필드 타입 ('ASCII', 'KSC-5601 (전각)', 'KSC-5601 (혼용)')
         * @param {number} size - 필드 크기
         * @param {string} rawValue - 원본 바이트 값 (KSC 필드의 경우)
         * @returns {Uint8Array} 인코딩된 바이트 배열
         */
        function encodeByFieldTypeToBytes(value, fieldType, size, rawValue) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            
            // KSC 필드 처리
            if (fieldType && fieldType.startsWith('KSC-5601')) {
                const mode = fieldType.includes('전각') ? 'fullwidth' : 'mixed';
                
                if (isDebugMode) {
                    console.log(`🔄 인코딩: "${value}" (타입: ${fieldType}, 크기: ${size}, rawValue: ${rawValue ? '있음' : '없음'})`);
                }
                
                // rawValue가 있고 값이 변경되지 않았으면 원본 바이트 사용
                if (rawValue) {
                    const originalDecoded = decodeByMode(rawValue, mode).trim();
                    
                    if (value === originalDecoded) {
                        // 원본 바이트를 Uint8Array로 변환
                        const bytes = new Uint8Array(size);
                        for (let i = 0; i < rawValue.length && i < size; i++) {
                            bytes[i] = rawValue.charCodeAt(i) & 0xFF;
                        }
                        // 패딩 처리
                        if (rawValue.length < size) {
                            if (mode === 'fullwidth') {
                                // 전각 공백 (0xA1A1)으로 패딩
                                let pos = rawValue.length;
                                while (pos + 2 <= size) {
                                    bytes[pos] = 0xA1;
                                    bytes[pos + 1] = 0xA1;
                                    pos += 2;
                                }
                                // 홀수 바이트가 남으면 ASCII 공백
                                if (pos < size) {
                                    bytes[pos] = 0x20;
                                }
                            } else {
                                // ASCII 공백으로 패딩
                                for (let i = rawValue.length; i < size; i++) {
                                    bytes[i] = 0x20;
                                }
                            }
                        }
                        return bytes;
                    }
                }
                
                // 값이 변경되었거나 rawValue가 없는 경우: 새로 인코딩
                if (mode === 'fullwidth') {
                    return encodeToKSCFullwidthBytes(value, size);
                } else {
                    return encodeToKSCMixedBytes(value, size);
                }
            }
            
            // ASCII 모드 (기본)
            const bytes = new Uint8Array(size);
            let bytePos = 0;
            
            for (let i = 0; i < value.length && bytePos < size; i++) {
                const code = value.charCodeAt(i);
                
                // 유니코드 전각 문자를 반각 ASCII로 변환
                let asciiCode = code;
                if (code === 0x3000) {
                    // 전각 공백 → 반각 공백
                    asciiCode = 0x20;
                } else if (code >= 0xFF01 && code <= 0xFF5E) {
                    // 전각 ASCII → 반각 ASCII
                    asciiCode = code - 0xFF01 + 0x21;
                } else if (code >= 0xAC00 && code <= 0xD7A3) {
                    // 한글 → 건너뛰기 (ASCII 필드에 한글은 넣을 수 없음)
                    if (isDebugMode) {
                        console.warn(`ASCII 필드에 한글 '${value[i]}' 제외`);
                    }
                    continue;
                } else if (code > 0x7F) {
                    // 기타 비-ASCII 문자 → 건너뛰기
                    if (isDebugMode) {
                        console.warn(`ASCII 필드에 비-ASCII 문자 '${value[i]}' (U+${code.toString(16)}) 제외`);
                    }
                    continue;
                }
                
                bytes[bytePos] = asciiCode & 0x7F;  // ASCII는 7비트만 사용
                bytePos++;
            }
            
            // ASCII 공백으로 패딩
            for (let i = bytePos; i < size; i++) {
                bytes[i] = 0x20;
            }
            return bytes;
        }

        /**
         * KSC-5601 전각 모드 인코딩 - 바이트 배열 반환 (재생성용)
         * @param {string} text - 인코딩할 문자열
         * @param {number} size - 필드 크기 (바이트)
         * @returns {Uint8Array} 인코딩된 바이트 배열
         */
        function encodeToKSCFullwidthBytes(text, size) {
            try {
                const encoded = KSC5601.encode(text);
                const bytes = new Uint8Array(size);
                
                // 인코딩된 데이터 복사
                const copyLen = Math.min(encoded.length, size);
                for (let i = 0; i < copyLen; i++) {
                    bytes[i] = encoded[i];
                }
                
                // 전각 공백 (0xA1A1)으로 패딩
                let pos = copyLen;
                while (pos + 2 <= size) {
                    bytes[pos] = 0xA1;
                    bytes[pos + 1] = 0xA1;
                    pos += 2;
                }
                // 홀수 바이트가 남으면 ASCII 공백
                if (pos < size) {
                    bytes[pos] = 0x20;
                }
                
                return bytes;
            } catch (e) {
                console.error('KSC 전각 바이트 인코딩 실패:', e);
                const bytes = new Uint8Array(size);
                for (let i = 0; i < text.length && i < size; i++) {
                    bytes[i] = text.charCodeAt(i) & 0xFF;
                }
                for (let i = text.length; i < size; i++) {
                    bytes[i] = 0x20;
                }
                return bytes;
            }
        }

        /**
         * KSC-5601 혼용 모드 인코딩 - 바이트 배열 반환 (재생성용)
         * @param {string} text - 인코딩할 문자열
         * @param {number} size - 필드 크기 (바이트)
         * @returns {Uint8Array} 인코딩된 바이트 배열
         */
        function encodeToKSCMixedBytes(text, size) {
            try {
                const result = [];
                
                for (let i = 0; i < text.length && result.length < size; i++) {
                    const char = text[i];
                    const code = char.charCodeAt(0);
                    
                    // 공백: 전각 공백 A1A1 (2바이트)
                    if (code === 0x20) {
                        if (result.length + 2 <= size) {
                            result.push(0xA1, 0xA1);
                        }
                    } else if (code < 0x80) {
                        // ASCII: 1바이트 그대로
                        if (result.length + 1 <= size) {
                            result.push(code);
                        }
                    } else if (code >= 0xAC00 && code <= 0xD7A3) {
                        // 한글 완성형: KSC5601로 2바이트 인코딩
                        if (result.length + 2 <= size) {
                            const kscCode = KSC5601.unicodeToKSC5601(code);
                            if (kscCode) {
                                result.push((kscCode >> 8) & 0xFF, kscCode & 0xFF);
                            } else {
                                result.push(0xA1, 0xA1); // 변환 불가 시 전각 공백
                            }
                        }
                    } else if (code >= 0x3131 && code <= 0x3163) {
                        // 한글 자모
                        if (result.length + 2 <= size) {
                            const kscCode = KSC5601.unicodeJamoToKSC5601(code);
                            if (kscCode) {
                                result.push((kscCode >> 8) & 0xFF, kscCode & 0xFF);
                            } else {
                                result.push(0xA1, 0xA1);
                            }
                        }
                    } else {
                        // 기타 비ASCII 문자: 2바이트로 처리
                        if (result.length + 2 <= size) {
                            const encoded = KSC5601.encode(char);
                            if (encoded && encoded.length === 2) {
                                result.push(encoded[0], encoded[1]);
                            } else {
                                result.push(0xA1, 0xA1);
                            }
                        }
                    }
                }
                
                // 전각 공백으로 패딩
                while (result.length + 2 <= size) {
                    result.push(0xA1, 0xA1);
                }
                // 홀수 바이트가 남으면 ASCII 공백
                if (result.length < size) {
                    result.push(0x20);
                }
                
                return new Uint8Array(result);
            } catch (e) {
                console.error('KSC 혼용 바이트 인코딩 실패:', e);
                const bytes = new Uint8Array(size);
                for (let i = 0; i < text.length && i < size; i++) {
                    bytes[i] = text.charCodeAt(i) & 0xFF;
                }
                for (let i = text.length; i < size; i++) {
                    bytes[i] = 0x20;
                }
                return bytes;
            }
        }

        function displayStructResults(parseResult) {
            // 1. struct-result-container 초기화
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // 입력값 유효성 검사
            if (!parseResult || !parseResult.records) {
                container.innerHTML = '<div class="error-message">⚠️ 파싱 결과가 없습니다.</div>';
                return;
            }

            const { records, stats, structDefs } = parseResult;

            // 파싱 설정 정보 가져오기
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // DocumentFragment 생성 - DOM 조작 최적화
            const fragment = document.createDocumentFragment();

            // 파싱 설정 정보 표시
            const settingsDiv = document.createElement('div');
            settingsDiv.className = 'parse-settings-info';
            
            // 인코딩 타입에 따른 표시 스타일
            const encodingType = stats.encodingType || 'ASCII';
            const encodingInfo = stats.encodingInfo || '순수 ASCII 데이터';
            const encodingClass = encodingType === 'KSC5601' ? 'ksc5601' : (encodingType === 'UNICODE' ? 'unicode' : 'ascii');
            const encodingIcon = encodingType === 'KSC5601' ? '🔤' : (encodingType === 'UNICODE' ? '🌏' : '📝');
            
            settingsDiv.innerHTML = `
                <h4>⚙️ 파싱 설정</h4>
                <div class="setting-item">
                    <span class="setting-label">파싱 모드:</span>
                    <span class="setting-value mode-${stats.mode}">
                        ${stats.mode === 'line-by-line' ? '📄 라인 단위' : '🔗 연속 데이터'}
                    </span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">개행문자 인식:</span>
                    <span class="setting-value ${recognizeCRLF ? 'enabled' : 'disabled'}">
                        ${recognizeCRLF ? '✓ 활성' : '✗ 비활성'}
                    </span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">입력 인코딩:</span>
                    <span class="setting-value encoding-${encodingClass}" title="${encodingInfo}">
                        ${encodingIcon} ${encodingType}
                    </span>
                </div>
                ${stats.mode === 'line-by-line' ? `
                <div class="setting-item">
                    <span class="setting-label">처리 라인:</span>
                    <span class="setting-value">${stats.recordCount}개 라인</span>
                </div>
                ` : ''}
            `;
            fragment.appendChild(settingsDiv);

            // 2. 통계 정보 표시
            if (stats) {
                const percent = stats.totalBytes > 0 
                    ? ((stats.parsedBytes / stats.totalBytes) * 100).toFixed(1) 
                    : 0;

                const statsDiv = document.createElement('div');
                statsDiv.className = 'parse-stats';

                // 모드에 따라 에러 통계 표시 (line-by-line: errorLines, continuous: errorBytes)
                const errorDisplay = stats.mode === 'line-by-line' 
                    ? `${stats.errorLines || 0} lines`
                    : `${stats.errorBytes || 0} bytes`;

                statsDiv.innerHTML = `
                    <h3>📊 파싱 통계</h3>
                    <div class="stats-grid">
                        <div>전체: ${stats.totalBytes} bytes</div>
                        <div>파싱: ${stats.parsedBytes} bytes (${percent}%)</div>
                        <div>레코드: ${stats.recordCount}개</div>
                        <div>오류: ${errorDisplay}</div>
                    </div>
                `;

                fragment.appendChild(statsDiv);
            }

            // 레코드가 없으면 메시지 표시
            if (records.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'error-message';
                noDataDiv.textContent = '⚠️ 파싱된 레코드가 없습니다.';
                fragment.appendChild(noDataDiv);
                container.appendChild(fragment);
                return;
            }

            // 편집 힌트 추가
            const hintDiv = document.createElement('div');
            hintDiv.className = 'edit-hint';
            hintDiv.innerHTML = '<span class="hint-icon">💡</span> <span>값 셀을 클릭하여 직접 수정할 수 있습니다. CRLF 필드는 수정이 제한됩니다.</span>';
            fragment.appendChild(hintDiv);

            /**
             * 3. 레코드별 그룹화 (recordIndex 기준)
             * 
             * [최적화된 그룹화 로직]
             * - 한 번의 순회로 레코드와 필드를 동시에 그룹화
             * - 에러 레코드는 즉시 DOM에 추가
             * - 정상 레코드는 Map에 필드 배열과 함께 저장
             */
            const recordMap = new Map();
            const errorCards = [];  // 에러 카드 별도 수집
            
            records.forEach(function(record) {
                // 에러 레코드 처리
                if (record.error) {
                    errorCards.push(record);
                    return;
                }
                
                // 정상 레코드: recordIndex로 그룹화, 필드 배열 수집
                const idx = record.recordIndex;
                if (!recordMap.has(idx)) {
                    // 레코드 초기화 (필드 배열 포함)
                    recordMap.set(idx, {
                        recordIndex: record.recordIndex,
                        lineNumber: record.lineNumber,
                        structName: record.structName,
                        kubun: record.kubun,
                        fields: []  // 필드 배열 초기화
                    });
                }
                
                // 필드 추가
                // 저장된 타입 오버라이드가 있으면 적용 (입력창 적용 후 재파싱 시)
                let fieldType = record.fieldType || 'ASCII';
                let fieldValue = record.value;
                
                if (window.structFieldTypeOverrides) {
                    const overrideKey = record.structName + '_' + record.fieldName;
                    if (window.structFieldTypeOverrides[overrideKey]) {
                        const savedType = window.structFieldTypeOverrides[overrideKey];
                        // 타입이 다른 경우에만 재디코딩
                        if (savedType !== fieldType && record.rawValue) {
                            fieldType = savedType;
                            // 저장된 타입에 따라 rawValue 재디코딩
                            if (fieldType.startsWith('KSC-5601')) {
                                const mode = fieldType.includes('전각') ? 'fullwidth' : 'mixed';
                                fieldValue = decodeByMode(record.rawValue, mode).trim();
                            } else {
                                fieldValue = record.rawValue.trim();
                            }
                            console.log('타입 복원 및 재디코딩: ' + overrideKey + ' → ' + fieldType);
                        }
                    }
                }
                
                recordMap.get(idx).fields.push({
                    fieldName: record.fieldName,
                    fieldSize: record.fieldSize,
                    fieldType: fieldType,
                    value: fieldValue,
                    rawValue: record.rawValue,
                    startPos: record.startPos,
                    endPos: record.endPos
                });
            });

            // 원본 데이터 저장 (재생성 시 사용)
            window.structParsedDataOriginal = JSON.parse(JSON.stringify(Array.from(recordMap.values())));
            window.structParsedDataCurrent = Array.from(recordMap.values());
            window.structParseStats = stats;
            
            // 에러 카드 먼저 표시 (순서 보장)
            errorCards.forEach(function(errorRecord) {
                const errorCard = document.createElement('div');
                errorCard.className = 'error-record-card';
                errorCard.innerHTML = `
                    <div class="error-header">
                        <span class="error-icon">⚠️</span>
                        <span class="error-title">라인 ${errorRecord.lineNumber} 파싱 실패</span>
                    </div>
                    <div class="error-body">
                        <p class="error-message">${errorRecord.message}</p>
                        <pre class="error-data">${escapeHtml(errorRecord.lineData)}</pre>
                        <div class="error-info">
                            <small>데이터 길이: ${errorRecord.lineData.length} bytes</small>
                        </div>
                    </div>
                `;
                fragment.appendChild(errorCard);
            });

            // 4. 각 레코드마다 테이블 생성
            let globalFieldIndex = 0;  // 전역 필드 인덱스 (수정 추적용)
            
            // recordMap의 values를 배열로 변환하여 인덱스 기반으로 순회
            // (Map의 key와 배열 인덱스가 다를 수 있으므로 배열 인덱스 사용)
            const recordArray = Array.from(recordMap.values());
            recordArray.forEach(function(record, arrayIndex) {
                // arrayIndex가 실제 window.structParsedDataCurrent의 인덱스
                const recordIndex = arrayIndex;
                
                // 그룹 컨테이너 생성
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';
                groupDiv.setAttribute('data-record-index', recordIndex);

                // 레코드 헤더 생성
                const headerDiv = document.createElement('div');
                headerDiv.className = 'record-header';

                // 제목: "레코드 #N - 구조체명"
                const title = document.createElement('h3');
                title.textContent = '레코드 #' + (recordIndex + 1) + ' - ' + record.structName;
                headerDiv.appendChild(title);

                // 구분값 배지
                const kubunBadge = document.createElement('span');
                kubunBadge.className = 'kubun-badge';
                kubunBadge.textContent = '구분: ' + (record.kubun || 'N/A');
                headerDiv.appendChild(kubunBadge);

                // 길이 검증 뱃지 추가
                const lengthBadgeHtml = createLengthBadge(record, structDefs, stats.mode);
                const lengthBadgeContainer = document.createElement('span');
                lengthBadgeContainer.innerHTML = lengthBadgeHtml;
                if (lengthBadgeContainer.firstChild) {
                    headerDiv.appendChild(lengthBadgeContainer.firstChild);
                }

                // 복사 버튼
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.setAttribute('data-record', recordIndex);
                copyBtn.textContent = '📋 복사';
                headerDiv.appendChild(copyBtn);

                groupDiv.appendChild(headerDiv);

                // 테이블 생성
                const table = document.createElement('table');
                table.className = 'result-table struct-editable-table';
                table.setAttribute('data-record-index', recordIndex);

                // thead 생성
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['필드명', '타입', '크기', '시작', '종료', '값'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody 생성
                const tbody = document.createElement('tbody');

                // 해당 레코드의 모든 필드를 행으로 추가
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field, fieldIndex) {
                        const tr = document.createElement('tr');
                        tr.setAttribute('data-record-index', recordIndex);
                        tr.setAttribute('data-field-index', fieldIndex);

                        /**
                         * 필드 값 표시 처리
                         * - CRLF 필드: 특수문자를 이스케이프하여 "\r\n" 형태로 표시
                         * - 일반 필드: 그대로 표시
                         */
                        const isCRLFField = field.fieldName && 
                            field.fieldName.toLowerCase().match(/crlf|cr_lf|newline/);
                        
                        // 값 포맷팅: 특수문자 이스케이프 (가시성 향상)
                        const formattedValue = formatFieldValue(field.value, isCRLFField);

                        const values = [
                            field.fieldName,   // 필드명
                            field.fieldType || 'ASCII',  // 타입
                            field.fieldSize,   // 크기
                            field.startPos,    // 시작
                            field.endPos,      // 종료
                            formattedValue     // 값 (포맷팅 적용)
                        ];

                        values.forEach(function(value, tdIndex) {
                            const td = document.createElement('td');
                            
                            // 타입 컬럼 (두번째 컬럼) - 드롭다운으로 변경
                            if (tdIndex === 1) {
                                td.className = 'field-type-cell';
                                
                                // CRLF 필드는 드롭다운 대신 고정 배지
                                if (isCRLFField) {
                                    td.innerHTML = '<span class="type-badge crlf-badge">CRLF</span>';
                                } else {
                                    td.innerHTML = createDecodingModeDropdown(value, recordIndex, fieldIndex);
                                }
                                tr.appendChild(td);
                                return;
                            }

                            // 값 컬럼 (마지막 컬럼)
                            if (tdIndex === 5) {
                                td.className = 'field-value-cell';
                                
                                // CRLF 필드: 편집 불가
                                if (isCRLFField) {
                                    td.classList.add('readonly-value');
                                    td.classList.add('crlf-value');
                                    td.innerHTML = '<code>' + escapeHtml(value) + '</code>';
                                    td.title = 'CRLF 필드: 편집 불가';
                                } else {
                                    // 값 표시 영역 생성
                                    const valueSpan = document.createElement('span');
                                    valueSpan.className = 'editable-value';
                                    valueSpan.setAttribute('contenteditable', 'true');
                                    valueSpan.setAttribute('data-record-index', recordIndex);
                                    valueSpan.setAttribute('data-field-index', fieldIndex);
                                    valueSpan.setAttribute('data-original-value', field.value);
                                    valueSpan.setAttribute('data-field-size', field.fieldSize);
                                    valueSpan.setAttribute('data-field-name', field.fieldName);
                                    valueSpan.setAttribute('data-raw-value', field.rawValue || field.value);
                                    valueSpan.textContent = value;
                                    td.appendChild(valueSpan);
                                    
                                    // 원본 버튼 (항상 표시, rawValue 존재 시)
                                    if (field.rawValue) {
                                        const rawBtn = document.createElement('button');
                                        rawBtn.className = 'show-raw-btn';
                                        rawBtn.setAttribute('data-raw', escapeHtml(field.rawValue));
                                        rawBtn.textContent = 'HEX';
                                        rawBtn.title = '원본 바이트(HEX) 보기';
                                        td.appendChild(rawBtn);
                                    }
                                    
                                    // KSC-5601 입력기 버튼
                                    const kscInputBtn = document.createElement('button');
                                    kscInputBtn.className = 'ksc-input-btn';
                                    kscInputBtn.textContent = '🔤';
                                    kscInputBtn.title = 'KSC-5601 입력기';
                                    kscInputBtn.addEventListener('click', function() {
                                        window.openKSCInputModal(valueSpan);
                                    });
                                    td.appendChild(kscInputBtn);
                                    
                                    // 바이트 길이 표시 뱃지 추가
                                    const byteInfoBadge = document.createElement('span');
                                    byteInfoBadge.className = 'byte-info-badge';
                                    const initByteLen = calculateByteLength(field.value, fieldType);
                                    byteInfoBadge.textContent = `${initByteLen}/${field.fieldSize}B`;
                                    if (initByteLen > field.fieldSize) {
                                        byteInfoBadge.classList.add('byte-error');
                                    } else if (initByteLen > field.fieldSize * 0.9) {
                                        byteInfoBadge.classList.add('byte-warning');
                                    } else {
                                        byteInfoBadge.classList.add('byte-ok');
                                    }
                                    td.appendChild(byteInfoBadge);
                                    
                                    // 수정 감지 이벤트 (valueSpan에 바인딩)
                                    valueSpan.addEventListener('input', function() {
                                        const originalValue = this.getAttribute('data-original-value');
                                        const currentValue = this.textContent;
                                        const recIdx = parseInt(this.getAttribute('data-record-index'));
                                        const fldIdx = parseInt(this.getAttribute('data-field-index'));
                                        const fieldSize = parseInt(this.getAttribute('data-field-size'));
                                        
                                        // 현재 필드 타입 가져오기
                                        let fieldType = 'ASCII';
                                        if (window.structParsedDataCurrent[recIdx] && 
                                            window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                            fieldType = window.structParsedDataCurrent[recIdx].fields[fldIdx].fieldType || 'ASCII';
                                        }
                                        
                                        // 타입에 따른 바이트 길이 계산
                                        const byteLength = calculateByteLength(currentValue, fieldType);
                                        
                                        // 바이트 초과 경고 표시
                                        if (byteLength > fieldSize) {
                                            this.classList.add('byte-overflow');
                                            this.title = `바이트 초과: ${byteLength}/${fieldSize} bytes`;
                                        } else {
                                            this.classList.remove('byte-overflow');
                                            this.title = `${byteLength}/${fieldSize} bytes`;
                                        }
                                        
                                        // 바이트 뱃지 업데이트
                                        const badge = this.closest('td').querySelector('.byte-info-badge');
                                        if (badge) {
                                            badge.textContent = `${byteLength}/${fieldSize}B`;
                                            badge.classList.remove('byte-ok', 'byte-warning', 'byte-error');
                                            if (byteLength > fieldSize) {
                                                badge.classList.add('byte-error');
                                            } else if (byteLength > fieldSize * 0.9) {
                                                badge.classList.add('byte-warning');
                                            } else {
                                                badge.classList.add('byte-ok');
                                            }
                                        }
                                        
                                        if (currentValue !== originalValue) {
                                            this.classList.add('modified');
                                            // 현재 파싱 데이터 업데이트
                                            if (window.structParsedDataCurrent[recIdx] && 
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx].value = currentValue;
                                                // 값이 변경되었으므로 rawValue를 null로 설정 (재생성 시 새로 인코딩)
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx].rawValue = null;
                                            }
                                        } else {
                                            this.classList.remove('modified');
                                        }
                                        
                                        // 수정 카운터 업데이트
                                        updateStructModifiedCount();
                                    });
                                    
                                    // 붙여넣기 이벤트 - rawValue 무효화 및 바이트 길이 검증
                                    valueSpan.addEventListener('paste', function(e) {
                                        const recIdx = parseInt(this.getAttribute('data-record-index'));
                                        const fldIdx = parseInt(this.getAttribute('data-field-index'));
                                        const fieldSize = parseInt(this.getAttribute('data-field-size'));
                                        const self = this;
                                        
                                        // 붙여넣기 후 처리 (비동기)
                                        setTimeout(() => {
                                            let currentValue = self.textContent;
                                            const originalValue = self.getAttribute('data-original-value');
                                            
                                            // 현재 필드 타입 가져오기
                                            let fieldType = 'ASCII';
                                            if (window.structParsedDataCurrent && 
                                                window.structParsedDataCurrent[recIdx] && 
                                                window.structParsedDataCurrent[recIdx].fields && 
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                                fieldType = window.structParsedDataCurrent[recIdx].fields[fldIdx].fieldType || 'ASCII';
                                            }
                                            
                                            console.log(`붙여넣기: recIdx=${recIdx}, fldIdx=${fldIdx}, fieldType="${fieldType}"`);
                                            
                                            // ASCII 필드에만 비-ASCII 문자 필터링 적용
                                            // KSC-5601 필드는 필터링하지 않음
                                            if (fieldType === 'ASCII') {
                                                let hasNonAscii = false;
                                                let filteredValue = '';
                                                for (let i = 0; i < currentValue.length; i++) {
                                                    const code = currentValue.charCodeAt(i);
                                                    // 전각 문자를 반각으로 변환
                                                    if (code === 0x3000) {
                                                        filteredValue += ' ';
                                                    } else if (code >= 0xFF01 && code <= 0xFF5E) {
                                                        filteredValue += String.fromCharCode(code - 0xFF01 + 0x21);
                                                    } else if (code <= 0x7F) {
                                                        filteredValue += currentValue[i];
                                                    } else {
                                                        // 한글 등 비-ASCII 문자 제외
                                                        hasNonAscii = true;
                                                    }
                                                }
                                                if (hasNonAscii) {
                                                    console.warn(`ASCII 필드에 비-ASCII 문자 제외됨`);
                                                    currentValue = filteredValue;
                                                    self.textContent = currentValue;
                                                    // 시각적 피드백
                                                    self.style.animation = 'pulse-warning 0.5s ease';
                                                    setTimeout(() => { self.style.animation = ''; }, 500);
                                                }
                                            }
                                            
                                            // 바이트 길이 계산 및 자르기
                                            const byteLength = calculateByteLength(currentValue, fieldType);
                                            if (byteLength > fieldSize) {
                                                currentValue = truncateToByteSize(currentValue, fieldSize, fieldType);
                                                self.textContent = currentValue;
                                                console.log(`필드 [${fldIdx}] 붙여넣기: 바이트 초과로 자름 (${byteLength} → ${fieldSize})`);
                                            }
                                            
                                            if (window.structParsedDataCurrent[recIdx] && 
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx].value = currentValue;
                                                // 붙여넣기 시 항상 rawValue를 null로 설정 (새로 인코딩 필요)
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx].rawValue = null;
                                                console.log(`필드 [${fldIdx}] 붙여넣기: rawValue 무효화, 값="${currentValue}"`);
                                            }
                                            
                                            // 수정 표시
                                            if (currentValue !== originalValue) {
                                                self.classList.add('modified');
                                            }
                                            const finalByteLen = calculateByteLength(currentValue, fieldType);
                                            self.classList.remove('byte-overflow');
                                            self.title = `${finalByteLen}/${fieldSize} bytes`;
                                            
                                            // 바이트 뱃지 업데이트
                                            const badge = self.closest('td').querySelector('.byte-info-badge');
                                            if (badge) {
                                                badge.textContent = `${finalByteLen}/${fieldSize}B`;
                                                badge.classList.remove('byte-ok', 'byte-warning', 'byte-error');
                                                if (finalByteLen > fieldSize) {
                                                    badge.classList.add('byte-error');
                                                } else if (finalByteLen > fieldSize * 0.9) {
                                                    badge.classList.add('byte-warning');
                                                } else {
                                                    badge.classList.add('byte-ok');
                                                }
                                            }
                                            
                                            updateStructModifiedCount();
                                        }, 0);
                                    });
                                    
                                    // 포커스 아웃 시 길이 검증 (valueSpan에 바인딩)
                                    valueSpan.addEventListener('blur', function() {
                                        const fieldSize = parseInt(this.getAttribute('data-field-size'));
                                        let currentValue = this.textContent;
                                        const recIdx = parseInt(this.getAttribute('data-record-index'));
                                        const fldIdx = parseInt(this.getAttribute('data-field-index'));
                                        
                                        // 현재 필드 타입 가져오기
                                        let fieldType = 'ASCII';
                                        if (window.structParsedDataCurrent[recIdx] && 
                                            window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                            fieldType = window.structParsedDataCurrent[recIdx].fields[fldIdx].fieldType || 'ASCII';
                                        }
                                        
                                        // 타입에 따른 바이트 길이 계산 및 자르기
                                        const byteLength = calculateByteLength(currentValue, fieldType);
                                        if (byteLength > fieldSize) {
                                            // 바이트 단위로 자르기
                                            currentValue = truncateToByteSize(currentValue, fieldSize, fieldType);
                                            this.textContent = currentValue;
                                            this.classList.remove('byte-overflow');
                                            this.title = `${fieldSize}/${fieldSize} bytes (자동 자름)`;
                                        }
                                        
                                        // 현재 파싱 데이터 업데이트
                                        if (window.structParsedDataCurrent[recIdx] && 
                                            window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                            window.structParsedDataCurrent[recIdx].fields[fldIdx].value = currentValue;
                                        }
                                    });
                                }
                                
                                // value가 공백만 있으면 class="empty-value" 추가
                                if (typeof value === 'string' && value.trim() === '') {
                                    td.classList.add('empty-value');
                                }
                            } else {
                                td.textContent = value;
                            }

                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                        globalFieldIndex++;
                    });
                }

                table.appendChild(thead);
                table.appendChild(tbody);

                // 반응형 wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // fragment에 그룹 추가
                fragment.appendChild(groupDiv);
            });

            // 5. 수정 반영 컨트롤 추가
            const reflectContainer = document.createElement('div');
            reflectContainer.className = 'reflect-changes-container';
            reflectContainer.id = 'struct-reflect-container';
            reflectContainer.innerHTML = `
                <div class="reflect-info">
                    <span>수정된 필드:</span>
                    <span class="modified-count no-changes" id="struct-modified-count">0개</span>
                </div>
                <div class="reflect-buttons">
                    <button class="btn-reset-changes" id="struct-reset-changes-btn" disabled>
                        ↩️ 원래대로
                    </button>
                    <button class="btn-reflect" id="struct-reflect-btn" disabled>
                        ✅ 통데이터 재생성
                    </button>
                </div>
            `;
            fragment.appendChild(reflectContainer);

            // 6. 재생성된 통데이터 표시 영역 (초기에는 숨김)
            const regeneratedContainer = document.createElement('div');
            regeneratedContainer.className = 'regenerated-data-container';
            regeneratedContainer.id = 'struct-regenerated-container';
            regeneratedContainer.style.display = 'none';
            fragment.appendChild(regeneratedContainer);

            // 한 번에 DOM 업데이트
            container.appendChild(fragment);

            // 7. 버튼 이벤트 연결
            attachStructReflectEvents();
        }

        /**
         * 구조체 파싱 결과 수정 카운터 업데이트
         */
        function updateStructModifiedCount() {
            const modifiedCells = document.querySelectorAll('.struct-editable-table .editable-value.modified');
            const countSpan = document.getElementById('struct-modified-count');
            const reflectBtn = document.getElementById('struct-reflect-btn');
            const resetBtn = document.getElementById('struct-reset-changes-btn');
            
            if (countSpan) {
                countSpan.textContent = modifiedCells.length + '개';
                
                if (modifiedCells.length > 0) {
                    countSpan.classList.remove('no-changes');
                    reflectBtn.disabled = false;
                    resetBtn.disabled = false;
                } else {
                    countSpan.classList.add('no-changes');
                    reflectBtn.disabled = true;
                    resetBtn.disabled = true;
                }
            }
        }

        /**
         * 구조체 파싱 결과 수정 반영 이벤트 연결
         */
        function attachStructReflectEvents() {
            // 원래대로 버튼
            const resetBtn = document.getElementById('struct-reset-changes-btn');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    // 원본 데이터로 복원
                    window.structParsedDataCurrent = JSON.parse(JSON.stringify(window.structParsedDataOriginal));
                    
                    // 수정된 셀 초기화
                    const modifiedCells = document.querySelectorAll('.struct-editable-table .editable-value.modified');
                    modifiedCells.forEach(function(cell) {
                        const originalValue = cell.getAttribute('data-original-value');
                        cell.textContent = originalValue;
                        cell.classList.remove('modified');
                    });
                    
                    // 카운터 업데이트
                    updateStructModifiedCount();
                    
                    // 재생성 결과 숨기기
                    document.getElementById('struct-regenerated-container').style.display = 'none';
                    
                    showTemporaryMessage('✓ 원래 값으로 복원되었습니다.');
                });
            }
            
            // 통데이터 재생성 버튼
            const reflectBtn = document.getElementById('struct-reflect-btn');
            if (reflectBtn) {
                reflectBtn.addEventListener('click', function() {
                    regenerateStructTelegram();
                });
            }
        }

        /**
         * 구조체 파싱 결과를 기반으로 통데이터 재생성
         * KSC-5601 필드의 글자 깨짐 방지를 위해 바이트 배열 기반으로 처리
         */
        function regenerateStructTelegram() {
            const parsedData = window.structParsedDataCurrent;
            const stats = window.structParseStats;
            
            if (!parsedData || parsedData.length === 0) {
                showTemporaryMessage('재생성할 데이터가 없습니다.');
                return;
            }
            
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            const isLineByLine = stats && stats.mode === 'line-by-line';
            
            // 바이트 배열로 데이터 생성 (KSC-5601 깨짐 방지)
            const byteArrays = [];
            let totalBytes = 0;
            let hasKSCField = false;
            
            // 각 레코드를 순서대로 조합
            parsedData.forEach(function(record, recordIdx) {
                const recordBytes = [];
                
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field) {
                        let value = field.value || '';
                        const size = field.fieldSize;
                        const fieldName = field.fieldName || '';
                        const fieldType = field.fieldType || 'ASCII';
                        const rawValue = field.rawValue || '';
                        
                        // CRLF 필드 여부 확인
                        const isCRLFField = fieldName.toLowerCase().match(/crlf|cr_lf|newline/);
                        
                        if (isCRLFField) {
                            if (recognizeCRLF) {
                                // 개행문자 인식 활성화: \r\n 바이트로 변환
                                recordBytes.push(new Uint8Array([0x0D, 0x0A]));
                                totalBytes += 2;
                            } else {
                                // 개행문자 인식 비활성화: 일반 필드처럼 패딩 처리
                                const bytes = new Uint8Array(size);
                                for (let i = 0; i < value.length && i < size; i++) {
                                    bytes[i] = value.charCodeAt(i) & 0xFF;
                                }
                                for (let i = value.length; i < size; i++) {
                                    bytes[i] = 0x20;
                                }
                                recordBytes.push(bytes);
                                totalBytes += size;
                            }
                        } else {
                            // KSC 또는 ASCII 필드: 바이트 배열로 인코딩
                            if (fieldType && fieldType.startsWith('KSC-5601')) {
                                hasKSCField = true;
                            }
                            const bytes = encodeByFieldTypeToBytes(value, fieldType, size, rawValue);
                            recordBytes.push(bytes);
                            totalBytes += bytes.length;
                        }
                    });
                }
                
                byteArrays.push(...recordBytes);
                
                // 라인 단위 모드에서는 각 레코드 끝에 개행 추가 (마지막 레코드 제외)
                if (isLineByLine && recordIdx < parsedData.length - 1) {
                    // 레코드 끝에 CRLF가 이미 있는지 확인
                    const lastBytes = recordBytes[recordBytes.length - 1];
                    const hasCRLF = lastBytes && lastBytes.length >= 2 && 
                                    lastBytes[lastBytes.length - 2] === 0x0D && 
                                    lastBytes[lastBytes.length - 1] === 0x0A;
                    if (!hasCRLF) {
                        byteArrays.push(new Uint8Array([0x0D, 0x0A]));
                        totalBytes += 2;
                    }
                }
            });
            
            // 모든 바이트 배열을 하나로 합치기
            const regeneratedBytes = new Uint8Array(totalBytes);
            let offset = 0;
            byteArrays.forEach(function(bytes) {
                regeneratedBytes.set(bytes, offset);
                offset += bytes.length;
            });
            
            // Latin-1 문자열로 변환 (입력창에 적용할 때 사용)
            let regeneratedData = '';
            for (let i = 0; i < regeneratedBytes.length; i++) {
                regeneratedData += String.fromCharCode(regeneratedBytes[i]);
            }
            
            // 표시용 데이터 생성 (KSC-5601 디코딩하여 한글로 표시)
            let displayText = '';
            if (hasKSCField) {
                // KSC-5601 필드가 있으면 디코딩하여 표시
                displayText = KSC5601.decode(regeneratedBytes);
            } else {
                // ASCII 전용이면 그대로 표시
                displayText = regeneratedData;
            }
            
            // 개행문자 이스케이프 처리 (표시용)
            const displayData = displayText
                .replace(/\r/g, '\\r')
                .replace(/\n/g, '\\n');
            
            // 결과 표시
            const container = document.getElementById('struct-regenerated-container');
            container.style.display = 'block';
            
            container.innerHTML = `
                <h4>✅ 재생성된 통데이터</h4>
                <div class="regenerated-data-content" id="struct-regenerated-data">${escapeHtml(displayData)}</div>
                <div style="margin-top: 10px; font-size: 13px; color: #666;">
                    총 ${totalBytes} bytes | ${parsedData.length}개 레코드
                    ${hasKSCField ? ' | <span style="color: #7b1fa2;">KSC-5601 포함</span>' : ''}
                </div>
                <div class="regenerated-actions">
                    <button class="btn-copy-regenerated" id="copy-struct-regenerated">
                        📋 클립보드에 복사
                    </button>
                    <button class="btn-apply-to-input" id="apply-struct-to-input">
                        📥 입력창에 적용
                    </button>
                    <button class="btn-download-regenerated" id="download-struct-regenerated" style="background: #6c757d;">
                        💾 파일로 저장
                    </button>
                </div>
            `;
            
            // 바이트 배열을 전역에 저장 (복사/다운로드용)
            window.structRegeneratedBytes = regeneratedBytes;
            window.structRegeneratedData = regeneratedData;
            
            // 복사 버튼 이벤트 - Latin-1 문자열로 복사 (바이트 값 유지)
            document.getElementById('copy-struct-regenerated').addEventListener('click', function() {
                // 클립보드에 복사 시 바이트 데이터를 Latin-1 문자열로 유지
                navigator.clipboard.writeText(regeneratedData).then(function() {
                    showTemporaryMessage('✓ 클립보드에 복사되었습니다. (바이트 데이터 유지)');
                }).catch(function(err) {
                    console.error('클립보드 복사 실패:', err);
                    showTemporaryMessage('⚠️ 복사 실패. 파일로 저장을 이용해주세요.');
                });
            });
            
            // 입력창에 적용 버튼 이벤트
            document.getElementById('apply-struct-to-input').addEventListener('click', function() {
                const dataInput = document.getElementById('struct-data');
                if (dataInput) {
                    // 입력창에는 디코딩된 텍스트 표시 (한글 정상 표시)
                    // 바이트 데이터는 window.structRegeneratedBytes에 보관되어 파싱 시 사용됨
                    dataInput.value = displayText;
                    
                    // 바이트 데이터 적용 플래그 설정 (파싱 시 바이트 데이터 우선 사용)
                    window.structAppliedFromRegenerate = true;
                    window.structRegeneratedDisplayText = displayText;
                    
                    // 사용자가 변경한 필드별 타입 정보 저장 (재파싱 시 복원용)
                    if (window.structParsedDataCurrent && window.structParsedDataCurrent.length > 0) {
                        window.structFieldTypeOverrides = {};
                        window.structParsedDataCurrent.forEach(function(record, recIdx) {
                            if (record.fields) {
                                record.fields.forEach(function(field, fldIdx) {
                                    const key = record.structName + '_' + field.fieldName;
                                    if (field.fieldType) {
                                        window.structFieldTypeOverrides[key] = field.fieldType;
                                    }
                                });
                            }
                        });
                        console.log('필드 타입 정보 저장됨:', window.structFieldTypeOverrides);
                    }
                    
                    showTemporaryMessage('✓ 통데이터 입력창에 적용되었습니다. (KSC-5601 바이트 데이터 보존)');
                }
            });
            
            // 파일 다운로드 버튼 이벤트 (바이너리 데이터 정확히 저장)
            document.getElementById('download-struct-regenerated').addEventListener('click', function() {
                // Blob을 사용하여 바이너리 데이터 그대로 저장
                const blob = new Blob([regeneratedBytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'telegram_data.dat';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTemporaryMessage('✓ 파일로 저장되었습니다. (바이트 데이터 정확히 보존)');
            });
            
            // 스크롤 이동
            container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        /**
         * =====================================================
         * 신규 레코드 입력 폼 표시 함수 (33단계)
         * 구조체 필드 배열을 받아 입력 폼을 생성
         * CRLF 필드는 개행 인식 옵션에 따라 자동 처리
         * =====================================================
         * @param {Array} fields - 필드 배열 [{name, size}, ...]
         * @param {HTMLElement} container - 폼을 표시할 컨테이너 요소
         * @returns {HTMLElement} 생성된 테이블 요소
         */
        function showNewRecordForm(fields, container) {
            // 입력값 유효성 검사
            if (!Array.isArray(fields) || fields.length === 0) {
                console.error('showNewRecordForm: 유효하지 않은 필드 배열입니다.');
                return null;
            }
            
            if (!container || !(container instanceof HTMLElement)) {
                console.error('showNewRecordForm: 유효하지 않은 컨테이너입니다.');
                return null;
            }
            
            // 개행문자 인식 옵션 확인
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // 테이블 생성
            const table = document.createElement('table');
            table.className = 'result-table new-record-form';
            
            // thead 생성
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['필드명', '크기', '입력값', '미리보기'];
            
            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // tbody 생성
            const tbody = document.createElement('tbody');
            
            // 각 필드에 대해 행 생성
            fields.forEach(function(field) {
                const tr = document.createElement('tr');
                
                // CRLF 필드 여부 확인
                const isCRLFField = field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/);
                
                // 필드명 셀
                const tdName = document.createElement('td');
                tdName.textContent = field.name;
                tr.appendChild(tdName);
                
                // 크기 셀
                const tdSize = document.createElement('td');
                tdSize.textContent = field.size;
                tr.appendChild(tdSize);
                
                // 입력값 셀
                const tdInput = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                
                if (isCRLFField && recognizeCRLF) {
                    // CRLF 필드이고 개행 인식 활성화: 자동 설정
                    input.value = '\\r\\n';
                    input.disabled = true;
                    input.className = 'auto-field';
                    input.title = '자동 설정됨';
                } else {
                    // 일반 필드 또는 개행 인식 비활성화된 CRLF 필드: 수동 입력 가능
                    input.className = 'new-field-input';
                    input.setAttribute('data-field', field.name);
                    input.setAttribute('data-size', field.size);
                    input.maxLength = field.size;
                    
                    if (isCRLFField) {
                        input.placeholder = '예: CR+LF 또는 공백';
                    } else {
                        input.placeholder = field.name + ' 값 입력';
                    }
                    
                    // 입력값 변경 시 미리보기 업데이트
                    input.addEventListener('input', function() {
                        const previewCell = tr.querySelector('.preview-cell');
                        if (previewCell) {
                            previewCell.textContent = input.value || '';
                        }
                    });
                }
                
                tdInput.appendChild(input);
                tr.appendChild(tdInput);
                
                // 미리보기 셀
                const tdPreview = document.createElement('td');
                tdPreview.className = 'preview-cell';
                
                if (isCRLFField && recognizeCRLF) {
                    tdPreview.textContent = '\\r\\n';
                } else {
                    tdPreview.textContent = '';
                }
                
                tr.appendChild(tdPreview);
                tbody.appendChild(tr);
            });
            
            table.appendChild(tbody);
            
            // 컨테이너 비우고 테이블 추가
            container.innerHTML = '';
            container.appendChild(table);
            
            console.log('showNewRecordForm: ' + fields.length + '개 필드의 입력 폼이 생성되었습니다.');
            
            return table;
        }

        /**
         * =====================================================
         * 테스트 케이스 실행 함수
         * 다양한 입력 상황에 대한 자동화된 테스트
         * =====================================================
         * @returns {Object} 테스트 결과 객체 { passed, failed, results }
         */
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            /**
             * 개별 테스트 실행 헬퍼
             */
            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        passed++;
                        results.push({ name: name, passed: true });
                    } else {
                        failed++;
                        results.push({ name: name, passed: false, reason: result || '실패' });
                    }
                } catch (e) {
                    failed++;
                    results.push({ name: name, passed: false, reason: e.message });
                }
            }

            // =========================================
            // 테스트 케이스 1: 구조체 1개만 있는 경우
            // =========================================
            test('구조체 1개만 있는 경우', function() {
                const structDef = `typedef struct {
                    char field1[5];
                    char field2[10];
                } SingleStruct;`;
                
                const data = 'HELLO1234567890';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                
                const result = parseStructData(data, defs);
                if (result.records.length !== 1) return '레코드 파싱 실패';
                if (result.records[0].fields.length !== 2) return '필드 파싱 실패';
                if (result.records[0].fields[0].value !== 'HELLO') return '첫 번째 필드 값 불일치';
                if (result.records[0].fields[1].value !== '1234567890') return '두 번째 필드 값 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 2: 구조체 5개 이상인 경우
            // =========================================
            test('구조체 5개 이상인 경우', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Type_A;
                    typedef struct { char type[1]; char data[4]; } Type_B;
                    typedef struct { char type[1]; char data[4]; } Type_C;
                    typedef struct { char type[1]; char data[4]; } Type_D;
                    typedef struct { char type[1]; char data[4]; } Type_E;
                `;
                
                const data = 'AAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 5) return '구조체 개수 불일치: ' + (defs ? defs.length : 0);
                
                const result = parseStructData(data, defs);
                // 5줄 = 5개 레코드
                if (result.records.length !== 5) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                return true;
            });

            // =========================================
            // 테스트 케이스 3: 데이터 라인 100개 이상
            // =========================================
            test('데이터 라인 100개 이상', function() {
                const structDef = `typedef struct { char id[4]; char val[6]; } DataLine;`;
                
                // 100개 라인 생성
                let dataLines = [];
                for (let i = 0; i < 100; i++) {
                    const id = ('0000' + i).slice(-4);
                    dataLines.push(id + 'VALUE1');
                }
                const data = dataLines.join('\n');
                
                const defs = parseStructDefinitions(structDef);
                if (!defs) return '구조체 파싱 실패';
                
                const result = parseStructData(data, defs);
                // 100줄 = 100개 레코드
                if (result.records.length !== 100) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                // 첫 번째와 마지막 레코드 검증
                if (result.records[0].fields[0].value !== '0000') return '첫 레코드 첫 필드 불일치';
                if (result.records[99].fields[0].value !== '0099') return '마지막 레코드 첫 필드 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 4: 길이가 안 맞는 데이터
            // =========================================
            test('길이가 안 맞는 데이터 (짧음)', function() {
                const structDef = `typedef struct { char field1[10]; char field2[10]; } TestStruct;`;
                const data = 'SHORTDATA'; // 9자 (예상: 20자)
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // 파싱은 성공해야 함 (부족한 부분은 빈 문자열)
                if (result.records.length !== 1) return '레코드 파싱 실패';
                if (result.records[0].fields.length !== 2) return '필드 파싱 실패';
                if (result.records[0].fields[0].value !== 'SHORTDATA') return '첫 번째 필드 값 불일치';
                if (result.records[0].fields[1].value !== '') return '두 번째 필드가 빈 문자열이어야 함';
                
                return true;
            });

            test('길이가 안 맞는 데이터 (김)', function() {
                const structDef = `typedef struct { char field1[5]; } ShortStruct;`;
                const data = 'EXTRALONG_DATA_HERE'; // 예상보다 긴 데이터
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // 정의된 필드까지만 파싱
                if (result.records.length !== 1) return '레코드 파싱 개수 불일치';
                if (result.records[0].fields[0].value !== 'EXTRA') return '값 불일치: ' + result.records[0].fields[0].value;
                
                return true;
            });

            // =========================================
            // 테스트 케이스 5: 잘못된 구조체 문법
            // =========================================
            test('잘못된 구조체 문법 - typedef 누락', function() {
                const structDef = `struct { char field[5]; } BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // null을 반환해야 함
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('잘못된 구조체 문법 - 중괄호 누락', function() {
                const structDef = `typedef struct char field[5]; BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('잘못된 구조체 문법 - 세미콜론 누락', function() {
                const structDef = `typedef struct { char field[5]; } BadStruct`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('빈 구조체 (필드 없음)', function() {
                const structDef = `typedef struct { } EmptyStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // 빈 구조체는 제외되므로 null 반환
                if (defs !== null) return '빈 구조체인데 파싱됨';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 6: 빈 입력
            // =========================================
            test('빈 입력 - 구조체 정의', function() {
                const defs = parseStructDefinitions('');
                if (defs !== null) return '빈 입력인데 파싱됨';
                return true;
            });

            test('빈 입력 - 데이터', function() {
                const structDef = `typedef struct { char field[5]; } TestStruct;`;
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData('', defs);
                
                if (result.records.length !== 0) return '빈 데이터인데 결과 있음';
                return true;
            });

            test('공백만 있는 입력', function() {
                const defs = parseStructDefinitions('   \n\t\n   ');
                if (defs !== null) return '공백만 있는데 파싱됨';
                return true;
            });

            // =========================================
            // 테스트 케이스 7: 주석 처리
            // =========================================
            test('한줄 주석 처리', function() {
                const structDef = `typedef struct {
                    // 이것은 주석입니다
                    char field1[5]; // 필드 설명
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                if (defs[0].fields.length !== 2) return '필드 개수 불일치';
                
                return true;
            });

            test('블록 주석 처리', function() {
                const structDef = `typedef struct {
                    /* 블록 주석
                       여러 줄 */
                    char field1[5];
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                if (defs[0].fields.length !== 2) return '필드 개수 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 8: 구조체 매칭 로직
            // =========================================
            test('구조체 매칭 - 첫 글자 기준', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Record_H;
                    typedef struct { char type[1]; char data[9]; } Record_D;
                `;
                
                const data = 'H1234\nD123456789';
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // H 라인: 1레코드, D 라인: 1레코드 = 2개 레코드
                if (result.records.length !== 2) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                // 첫 라인은 Record_H
                if (result.records[0].structName !== 'Record_H') return '첫 라인 구조체 매칭 실패';
                // 두 번째 라인은 Record_D
                if (result.records[1].structName !== 'Record_D') return '두 번째 라인 구조체 매칭 실패';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 9: XML 파싱
            // =========================================
            test('XML 파싱 - 정상', function() {
                const xml = `<packet>
                    <col id="field1" type="X" size="5" />
                    <col id="field2" type="N" size="10" />
                </packet>`;
                
                const spec = parseXMLSpec(xml);
                if (!spec || spec.length !== 2) return 'XML 파싱 실패';
                if (spec[0].id !== 'field1') return '첫 번째 필드 ID 불일치';
                if (spec[1].size !== 10) return '두 번째 필드 크기 불일치';
                
                return true;
            });

            test('XML 파싱 - 빈 입력', function() {
                const spec = parseXMLSpec('');
                if (spec !== null) return '빈 입력인데 파싱됨';
                return true;
            });

            test('XML 파싱 - 잘못된 형식', function() {
                const spec = parseXMLSpec('<invalid><unclosed>');
                if (spec !== null) return '잘못된 XML인데 파싱됨';
                return true;
            });

            // =========================================
            // 테스트 케이스 10: 통전문 파싱
            // =========================================
            test('통전문 파싱 - 정상', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="3" />
                    <col id="name" type="X" size="5" />
                </packet>`;
                const telegram = 'ABCHELLO';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return '필드 개수 불일치';
                if (parsed[0].value !== 'ABC') return '첫 번째 값 불일치';
                if (parsed[1].value !== 'HELLO') return '두 번째 값 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 11: KSC-5601 인코딩/디코딩
            // =========================================
            test('KSC-5601 인코딩 - 영문자', function() {
                const encoded = KSC5601.encode('ABC');
                // 영문 대문자는 전각으로 변환: A=0xA3C1, B=0xA3C2, C=0xA3C3
                if (encoded.length !== 6) return '인코딩 길이 불일치 (예상: 6, 실제: ' + encoded.length + ')';
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xC1) return 'A 인코딩 실패';
                if (encoded[2] !== 0xA3 || encoded[3] !== 0xC2) return 'B 인코딩 실패';
                if (encoded[4] !== 0xA3 || encoded[5] !== 0xC3) return 'C 인코딩 실패';
                return true;
            });

            test('KSC-5601 인코딩 - 숫자', function() {
                const encoded = KSC5601.encode('123');
                // 숫자는 전각으로 변환: 1=0xA3B1, 2=0xA3B2, 3=0xA3B3
                if (encoded.length !== 6) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xB1) return '1 인코딩 실패';
                if (encoded[2] !== 0xA3 || encoded[3] !== 0xB2) return '2 인코딩 실패';
                if (encoded[4] !== 0xA3 || encoded[5] !== 0xB3) return '3 인코딩 실패';
                return true;
            });

            test('KSC-5601 인코딩 - 공백', function() {
                const encoded = KSC5601.encode(' ');
                // 공백은 전각 공백: 0xA1A1
                if (encoded.length !== 2) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA1 || encoded[1] !== 0xA1) return '공백 인코딩 실패';
                return true;
            });

            test('KSC-5601 디코딩 - EUC-KR', function() {
                // '가' = 0xB0A1 in EUC-KR
                const bytes = new Uint8Array([0xB0, 0xA1]);
                const decoded = KSC5601.decode(bytes);
                if (decoded !== '가') return '가 디코딩 실패 (결과: ' + decoded + ')';
                return true;
            });

            test('KSC-5601 바이트 길이 계산', function() {
                // 모든 문자가 2바이트
                const len1 = KSC5601.getByteLength('ABC');
                if (len1 !== 6) return 'ABC 길이 불일치 (예상: 6, 실제: ' + len1 + ')';
                
                const len2 = KSC5601.getByteLength('한글');
                if (len2 !== 4) return '한글 길이 불일치 (예상: 4, 실제: ' + len2 + ')';
                
                return true;
            });

            test('KSC-5601 패딩 - 바이트 단위', function() {
                // 'A'를 6바이트로 패딩
                const padded = KSC5601.padToByteSize('A', 6);
                // A(2bytes) + 전각공백 2개(4bytes) = 6bytes
                if (padded.length !== 6) return '패딩 길이 불일치 (예상: 6, 실제: ' + padded.length + ')';
                return true;
            });

            test('KSC-5601 자르기 - 바이트 경계', function() {
                // 'ABC'(6바이트)를 4바이트로 자르기
                const truncated = KSC5601.truncateToByteSize('ABC', 4);
                // 4바이트 = 2문자
                if (truncated.length !== 4) return '자르기 길이 불일치 (예상: 4, 실제: ' + truncated.length + ')';
                return true;
            });

            // =========================================
            // 테스트 케이스 12: 유니코드 입력 감지 및 변환
            // =========================================
            test('Latin1 인코딩 감지 - 이미 인코딩됨', function() {
                // KSC-5601로 인코딩된 Latin1 문자열
                const encoded = String.fromCharCode(0xB0, 0xA1, 0xB0, 0xA2); // '가각'
                if (!isLatin1Encoded(encoded)) return 'Latin1을 유니코드로 잘못 감지';
                return true;
            });

            test('Latin1 인코딩 감지 - 유니코드', function() {
                // 유니코드 한글
                const unicode = '홍길동';
                if (isLatin1Encoded(unicode)) return '유니코드를 Latin1으로 잘못 감지';
                return true;
            });

            test('유니코드 FULL 타입 파싱', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="4" />
                    <col id="name" type="FULL" size="6" />
                </packet>`;
                // 유니코드로 직접 입력: "TEST" + "홍길동"
                const telegram = 'TEST홍길동';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return '필드 개수 불일치';
                if (parsed[0].value !== 'TEST') return 'code 값 불일치';
                // FULL 필드는 KSC-5601로 변환되어 6바이트여야 함
                if (parsed[1].value.length !== 6) return 'name 바이트 길이 불일치 (예상: 6, 실제: ' + parsed[1].value.length + ')';
                
                // 디코딩해서 원본 확인
                const decoded = KSC5601.decode(parsed[1].value);
                if (decoded !== '홍길동') return 'name 디코딩 실패 (결과: ' + decoded + ')';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 13: 유니코드 전각 문자 처리
            // =========================================
            test('KSC-5601 인코딩 - 전각 영문자 정규화', function() {
                // 전각 K (U+FF2B) 입력 시 반각 K로 정규화 후 KSC-5601 인코딩
                const fullwidthK = String.fromCharCode(0xFF2B); // 'Ｋ'
                const encoded = KSC5601.encode(fullwidthK);
                
                // 반각 K와 동일하게 A3CB로 인코딩되어야 함
                if (encoded.length !== 2) return '인코딩 길이 불일치 (예상: 2, 실제: ' + encoded.length + ')';
                if (encoded[0] !== 0xA3) return '첫 번째 바이트 불일치 (예상: A3, 실제: ' + encoded[0].toString(16) + ')';
                if (encoded[1] !== 0xCB) return '두 번째 바이트 불일치 (예상: CB, 실제: ' + encoded[1].toString(16) + ')';
                
                return true;
            });

            test('KSC-5601 인코딩 - 전각 숫자 정규화', function() {
                // 전각 1 (U+FF11) 입력 시 반각 1로 정규화 후 KSC-5601 인코딩
                const fullwidth1 = String.fromCharCode(0xFF11); // '１'
                const encoded = KSC5601.encode(fullwidth1);
                
                // 반각 1과 동일하게 A3B1로 인코딩되어야 함
                if (encoded.length !== 2) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xB1) return '인코딩 값 불일치';
                
                return true;
            });

            test('KSC-5601 인코딩 - 전각 공백 정규화', function() {
                // 전각 공백 (U+3000) 입력 시 KSC-5601 전각 공백으로 인코딩
                const fullwidthSpace = String.fromCharCode(0x3000); // '　'
                const encoded = KSC5601.encode(fullwidthSpace);
                
                // A1A1 (KSC-5601 전각 공백)로 인코딩되어야 함
                if (encoded.length !== 2) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA1 || encoded[1] !== 0xA1) return '인코딩 값 불일치';
                
                return true;
            });

            test('KSC-5601 인코딩 - 반각/전각 혼합', function() {
                // 반각 'A' + 전각 'Ｂ' (U+FF22) + 한글 '가'
                const mixed = 'A' + String.fromCharCode(0xFF22) + '가';
                const encoded = KSC5601.encode(mixed);
                
                // 3문자 = 6바이트
                if (encoded.length !== 6) return '인코딩 길이 불일치 (예상: 6, 실제: ' + encoded.length + ')';
                // A: A3C1
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xC1) return 'A 인코딩 실패';
                // B: A3C2
                if (encoded[2] !== 0xA3 || encoded[3] !== 0xC2) return 'B 인코딩 실패';
                // 가: B0A1
                if (encoded[4] !== 0xB0 || encoded[5] !== 0xA1) return '가 인코딩 실패';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 14: KSC-5601 통합 검증 (한글+영문+공백 2바이트)
            // =========================================
            test('KSC-5601 전각 모드 - 한글+영문+공백 조합', function() {
                // 한글 "홍길동", 영문 "ABC", 공백 " " 모두 2바이트씩
                const testStr = '홍길동 ABC';
                const encoded = KSC5601.encode(testStr);
                
                // 7문자 × 2바이트 = 14바이트
                if (encoded.length !== 14) return '인코딩 길이 불일치 (예상: 14, 실제: ' + encoded.length + ')';
                
                // 디코딩 후 원본과 비교
                const decoded = KSC5601.decode(encoded);
                if (decoded !== testStr) return '디코딩 결과 불일치 (원본: "' + testStr + '", 결과: "' + decoded + '")';
                
                return true;
            });

            test('KSC-5601 전각 모드 - 인코딩/디코딩 왕복 검증', function() {
                // 다양한 문자 조합 테스트
                const testCases = [
                    '가나다라',           // 한글만
                    'ABCD',              // 영문만
                    '    ',              // 공백만 (4개)
                    '홍 길 동',          // 한글+공백
                    'A B C',             // 영문+공백
                    '테스트 TEST 123',   // 한글+영문+숫자+공백
                    '김철수  010'        // 한글+공백2개+숫자
                ];
                
                for (let i = 0; i < testCases.length; i++) {
                    const original = testCases[i];
                    const encoded = KSC5601.encode(original);
                    const decoded = KSC5601.decode(encoded);
                    
                    if (decoded !== original) {
                        return '케이스 ' + (i+1) + ' 실패: "' + original + '" → "' + decoded + '"';
                    }
                    
                    // 모든 문자가 2바이트인지 확인
                    if (encoded.length !== original.length * 2) {
                        return '케이스 ' + (i+1) + ' 바이트 길이 불일치: ' + original.length + '문자 → ' + encoded.length + '바이트';
                    }
                }
                
                return true;
            });

            test('KSC-5601 전각 모드 - 패딩 후 디코딩 검증', function() {
                // 10바이트 필드에 "홍길동" (6바이트) 패딩
                const padded = KSC5601.padToByteSize('홍길동', 10);
                
                if (padded.length !== 10) return '패딩 길이 불일치 (예상: 10, 실제: ' + padded.length + ')';
                
                // 디코딩 후 확인 (전각 공백 2개가 뒤에 붙음)
                const decoded = KSC5601.decode(padded);
                if (!decoded.startsWith('홍길동')) return '패딩 후 원본 손실: "' + decoded + '"';
                
                // 트림 후 원본과 비교
                if (decoded.trim() !== '홍길동') return '트림 후 불일치: "' + decoded.trim() + '"';
                
                return true;
            });

            test('KSC-5601 전각 모드 - 구조체 재생성 시뮬레이션', function() {
                // 실제 구조체 필드 시나리오: 이름(10), 주소(20)
                const name = '김철수';      // 3문자 = 6바이트
                const addr = '서울시 강남구'; // 7문자 = 14바이트
                
                // 필드 크기에 맞춰 패딩
                const encodedName = KSC5601.padToByteSize(name, 10);  // 10바이트
                const encodedAddr = KSC5601.padToByteSize(addr, 20);  // 20바이트
                
                if (encodedName.length !== 10) return '이름 필드 길이 불일치';
                if (encodedAddr.length !== 20) return '주소 필드 길이 불일치';
                
                // 통데이터 생성
                const telegram = encodedName + encodedAddr;
                if (telegram.length !== 30) return '통데이터 길이 불일치 (예상: 30, 실제: ' + telegram.length + ')';
                
                // 다시 파싱 (바이트 단위로 분리)
                const parsedName = telegram.substring(0, 10);
                const parsedAddr = telegram.substring(10, 30);
                
                // 디코딩
                const decodedName = KSC5601.decode(parsedName).trim();
                const decodedAddr = KSC5601.decode(parsedAddr).trim();
                
                if (decodedName !== name) return '이름 디코딩 실패: "' + decodedName + '"';
                if (decodedAddr !== addr) return '주소 디코딩 실패: "' + decodedAddr + '"';
                
                return true;
            });

            test('KSC-5601 혼용 모드 인코딩 검증', function() {
                // 혼용 모드: 한글 2바이트, ASCII 1바이트
                const testStr = '홍길동ABC';
                
                // encodeToKSCMixed 함수 테스트 (20바이트 필드)
                const encoded = encodeToKSCMixed(testStr, 20);
                
                // 한글 3자(6바이트) + 영문 3자(3바이트) = 9바이트 + 패딩 11바이트 = 20바이트
                if (encoded.length !== 20) return '인코딩 길이 불일치 (예상: 20, 실제: ' + encoded.length + ')';
                
                // 한글 부분 디코딩 확인 (처음 6바이트)
                const koreanPart = encoded.substring(0, 6);
                const decodedKorean = KSC5601.decode(koreanPart);
                if (decodedKorean !== '홍길동') return '한글 디코딩 실패: "' + decodedKorean + '"';
                
                // 영문 부분 확인 (다음 3바이트)
                const asciiPart = encoded.substring(6, 9);
                if (asciiPart !== 'ABC') return '영문 부분 불일치: "' + asciiPart + '"';
                
                return true;
            });

            test('KSC-5601 특수문자 인코딩 검증', function() {
                // 특수문자도 전각으로 변환되는지 확인
                const specialChars = '!@#$%';
                const encoded = KSC5601.encode(specialChars);
                
                // 5문자 × 2바이트 = 10바이트
                if (encoded.length !== 10) return '특수문자 인코딩 길이 불일치';
                
                // 디코딩 확인
                const decoded = KSC5601.decode(encoded);
                if (decoded !== specialChars) return '특수문자 디코딩 불일치: "' + decoded + '"';
                
                return true;
            });

            test('KSC-5601 수정 후 재인코딩 검증', function() {
                // 시나리오: 파싱된 값 수정 후 재생성
                const original = '홍길동';
                const modified = '김영희';
                
                // 원본 인코딩
                const encodedOriginal = KSC5601.padToByteSize(original, 10);
                
                // 수정된 값 인코딩
                const encodedModified = KSC5601.padToByteSize(modified, 10);
                
                // 길이 동일 확인
                if (encodedOriginal.length !== encodedModified.length) {
                    return '수정 전후 길이 불일치';
                }
                
                // 수정된 값 디코딩 확인
                const decodedModified = KSC5601.decode(encodedModified).trim();
                if (decodedModified !== modified) {
                    return '수정된 값 디코딩 실패: "' + decodedModified + '"';
                }
                
                return true;
            });

            // =========================================
            // 테스트 케이스 15: 바이트 배열 기반 인코딩 (통데이터 재생성용)
            // =========================================
            test('encodeToKSCFullwidthBytes - 한글 인코딩', function() {
                const bytes = encodeToKSCFullwidthBytes('홍길동', 10);
                
                // Uint8Array 타입 확인
                if (!(bytes instanceof Uint8Array)) return 'Uint8Array가 아님';
                
                // 크기 확인 (10바이트)
                if (bytes.length !== 10) return '바이트 길이 불일치 (예상: 10, 실제: ' + bytes.length + ')';
                
                // 디코딩하여 원본 확인
                const decoded = KSC5601.decode(bytes).trim();
                if (decoded !== '홍길동') return '디코딩 실패: "' + decoded + '"';
                
                return true;
            });

            test('encodeToKSCFullwidthBytes - 영문 전각 인코딩', function() {
                const bytes = encodeToKSCFullwidthBytes('ABC', 10);
                
                // 크기 확인 (10바이트)
                if (bytes.length !== 10) return '바이트 길이 불일치';
                
                // 전각 영문 확인: A = 0xA3C1, B = 0xA3C2, C = 0xA3C3
                if (bytes[0] !== 0xA3 || bytes[1] !== 0xC1) return 'A 인코딩 실패';
                if (bytes[2] !== 0xA3 || bytes[3] !== 0xC2) return 'B 인코딩 실패';
                if (bytes[4] !== 0xA3 || bytes[5] !== 0xC3) return 'C 인코딩 실패';
                
                // 나머지는 전각 공백 (0xA1A1)
                if (bytes[6] !== 0xA1 || bytes[7] !== 0xA1) return '패딩 공백 1 실패';
                if (bytes[8] !== 0xA1 || bytes[9] !== 0xA1) return '패딩 공백 2 실패';
                
                return true;
            });

            test('encodeToKSCMixedBytes - 혼용 모드 인코딩', function() {
                const bytes = encodeToKSCMixedBytes('홍ABC', 12);
                
                // 크기 확인 (12바이트)
                if (bytes.length !== 12) return '바이트 길이 불일치';
                
                // 홍 (2바이트) + A,B,C (각 1바이트) = 5바이트 + 패딩
                // 한글 '홍' 확인 (EUC-KR)
                if (bytes[0] < 0xB0 || bytes[0] > 0xC8) return '한글 첫 바이트 범위 오류';
                
                // ASCII 'A', 'B', 'C' 확인
                if (bytes[2] !== 0x41) return 'A 인코딩 실패 (실제: 0x' + bytes[2].toString(16) + ')';
                if (bytes[3] !== 0x42) return 'B 인코딩 실패';
                if (bytes[4] !== 0x43) return 'C 인코딩 실패';
                
                return true;
            });

            test('encodeByFieldTypeToBytes - ASCII 필드', function() {
                const bytes = encodeByFieldTypeToBytes('TEST', 'ASCII', 10, '');
                
                // 크기 확인
                if (bytes.length !== 10) return '바이트 길이 불일치';
                
                // ASCII 문자 확인
                if (bytes[0] !== 0x54) return 'T 인코딩 실패'; // 'T'
                if (bytes[1] !== 0x45) return 'E 인코딩 실패'; // 'E'
                if (bytes[2] !== 0x53) return 'S 인코딩 실패'; // 'S'
                if (bytes[3] !== 0x54) return 'T 인코딩 실패'; // 'T'
                
                // 나머지는 ASCII 공백 (0x20)
                for (let i = 4; i < 10; i++) {
                    if (bytes[i] !== 0x20) return '패딩 공백 실패 (위치: ' + i + ')';
                }
                
                return true;
            });

            test('encodeByFieldTypeToBytes - KSC-5601 전각 필드', function() {
                const bytes = encodeByFieldTypeToBytes('김철수', 'KSC-5601 (전각)', 10, '');
                
                // 크기 확인
                if (bytes.length !== 10) return '바이트 길이 불일치';
                
                // 디코딩하여 원본 확인
                const decoded = KSC5601.decode(bytes).trim();
                if (decoded !== '김철수') return '디코딩 실패: "' + decoded + '"';
                
                return true;
            });

            test('바이트 배열 합치기 - 통데이터 재생성 시뮬레이션', function() {
                // 여러 필드의 바이트 배열을 합치는 시뮬레이션
                const nameBytes = encodeToKSCFullwidthBytes('홍길동', 10);
                const codeBytes = encodeByFieldTypeToBytes('001', 'ASCII', 5, '');
                const addrBytes = encodeToKSCFullwidthBytes('서울', 8);
                
                // 총 바이트 수: 10 + 5 + 8 = 23
                const totalBytes = new Uint8Array(23);
                totalBytes.set(nameBytes, 0);
                totalBytes.set(codeBytes, 10);
                totalBytes.set(addrBytes, 15);
                
                if (totalBytes.length !== 23) return '총 바이트 길이 불일치';
                
                // 각 필드 분리 후 디코딩 검증
                const parsedName = KSC5601.decode(totalBytes.slice(0, 10)).trim();
                if (parsedName !== '홍길동') return '이름 필드 디코딩 실패: "' + parsedName + '"';
                
                // ASCII 코드 필드 확인
                let codeStr = '';
                for (let i = 10; i < 15; i++) {
                    codeStr += String.fromCharCode(totalBytes[i]);
                }
                if (codeStr.trim() !== '001') return '코드 필드 실패: "' + codeStr + '"';
                
                const parsedAddr = KSC5601.decode(totalBytes.slice(15, 23)).trim();
                if (parsedAddr !== '서울') return '주소 필드 디코딩 실패: "' + parsedAddr + '"';
                
                return true;
            });

            test('빈 값 패딩 - KSC-5601 전각', function() {
                // 빈 값일 때 전각 공백으로 패딩되는지 확인
                const bytes = encodeToKSCFullwidthBytes('', 10);
                
                if (bytes.length !== 10) return '패딩 길이 불일치 (예상: 10, 실제: ' + bytes.length + ')';
                
                // 모든 바이트가 전각 공백 (0xA1A1)인지 확인
                for (let i = 0; i < 10; i += 2) {
                    if (bytes[i] !== 0xA1 || bytes[i+1] !== 0xA1) {
                        return '전각 공백 패딩 실패 (위치: ' + i + ')';
                    }
                }
                
                return true;
            });

            test('빈 값 패딩 - ASCII', function() {
                // 빈 값일 때 ASCII 공백으로 패딩되는지 확인
                const bytes = encodeByFieldTypeToBytes('', 'ASCII', 10, '');
                
                if (bytes.length !== 10) return '패딩 길이 불일치';
                
                // 모든 바이트가 ASCII 공백 (0x20)인지 확인
                for (let i = 0; i < 10; i++) {
                    if (bytes[i] !== 0x20) {
                        return 'ASCII 공백 패딩 실패 (위치: ' + i + ', 값: 0x' + bytes[i].toString(16) + ')';
                    }
                }
                
                return true;
            });

            test('복사/붙여넣기 시뮬레이션 - KSC 데이터 인코딩', function() {
                // 화면에서 복사된 유니코드 텍스트가 KSC로 제대로 인코딩되는지 확인
                const copiedText = '홍길동';  // 복사된 유니코드 텍스트
                const bytes = encodeToKSCFullwidthBytes(copiedText, 10);
                
                if (bytes.length !== 10) return '바이트 길이 불일치';
                
                // 디코딩 후 원본과 비교
                const decoded = KSC5601.decode(bytes).trim();
                if (decoded !== copiedText) return '인코딩/디코딩 실패: "' + decoded + '"';
                
                return true;
            });

            return { passed: passed, failed: failed, results: results };
        }

        /**
         * =====================================================
         * 테스트 결과 표시 함수
         * 테스트 결과를 UI에 표시
         * =====================================================
         * @param {Object} testResult - runTests()의 반환값
         */
        function displayTestResults(testResult) {
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            const div = document.createElement('div');
            div.className = 'test-results ' + (testResult.failed === 0 ? 'success' : 'failure');

            const title = document.createElement('h3');
            title.textContent = '테스트 결과: ' + testResult.passed + '개 통과, ' + testResult.failed + '개 실패';
            div.appendChild(title);

            testResult.results.forEach(function(result) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                if (result.passed) {
                    item.innerHTML = '<span class="test-pass">✓</span> ' + result.name;
                } else {
                    item.innerHTML = '<span class="test-fail">✗</span> ' + result.name + 
                                   ' <small>(' + result.reason + ')</small>';
                }
                
                div.appendChild(item);
            });

            container.appendChild(div);
        }

        // =========================================
        // DOMContentLoaded 이벤트 - 이벤트 리스너 등록
        // =========================================
        document.addEventListener('DOMContentLoaded', function() {
            // =========================================
            // Footer Credit 초기화 (난독화)
            // =========================================
            (function(){var _0x=[77,97,100,101,32,98,121,32],_1x=[32,119,105,116,104,32],_2x=[67,117,114,115,111,114,32,65,73],_3x=[77,97,115,111,110,32,83,104,105,110],_e=document.getElementById('_c4r8d1');if(_e){var _s=document.createElement('span');_s.className='_h3n5v8';_s.textContent=String.fromCharCode.apply(null,_3x);_e.appendChild(document.createTextNode(String.fromCharCode.apply(null,_0x)));_e.appendChild(_s);_e.appendChild(document.createTextNode(String.fromCharCode.apply(null,_1x)+String.fromCharCode.apply(null,_2x)));}})();

            // =========================================
            // 서브 탭 (파싱/생성 모드) 전환 이벤트 - struct-tab
            // =========================================
            document.querySelectorAll('#struct-tab .sub-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    
                    // struct-tab 내 버튼 비활성화
                    document.querySelectorAll('#struct-tab .sub-tab-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    
                    // 클릭된 버튼 활성화
                    this.classList.add('active');
                    
                    // struct-tab 내 컨텐츠 숨김
                    document.querySelectorAll('#struct-tab .sub-mode-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 선택된 모드 컨텐츠 표시
                    const selectedContent = document.getElementById(`${mode}-mode-content`);
                    selectedContent.classList.add('active');
                    
                    // 결과 영역 초기화
                    document.getElementById('struct-result-container').innerHTML = '';
                    
                    console.log(`struct-tab 모드 전환: ${mode}`);
                });
            });

            // =========================================
            // 서브 탭 (파싱/생성 모드) 전환 이벤트 - xml-tab
            // =========================================
            document.querySelectorAll('#xml-tab .sub-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    
                    // xml-tab 내 버튼 비활성화
                    document.querySelectorAll('#xml-tab .sub-tab-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    
                    // 클릭된 버튼 활성화
                    this.classList.add('active');
                    
                    // xml-tab 내 컨텐츠 숨김
                    document.querySelectorAll('#xml-tab .sub-mode-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 선택된 모드 컨텐츠 표시
                    document.getElementById(`xml-${mode}-mode`).classList.add('active');
                    
                    // 결과 영역 초기화
                    document.getElementById('result-container').innerHTML = '';
                    
                    console.log(`xml-tab 모드 전환: ${mode}`);
                });
            });

            // =========================================
            // 구조체 카드 초기화 - 첫 번째 카드 자동 추가
            // =========================================
            const structContainer = document.getElementById('struct-definitions-container');
            structContainer.appendChild(createStructCard(0));
            structCardIndex = 1;

            // =========================================
            // 구조체 추가 버튼 클릭 이벤트
            // =========================================
            document.getElementById('add-struct-btn').addEventListener('click', function() {
                const newCard = createStructCard(structCardIndex);
                structContainer.appendChild(newCard);
                structCardIndex++;
            });

            // =========================================
            // 전체 접기/펼치기 버튼 클릭 이벤트
            // =========================================
            const toggleAllBtn = document.getElementById('toggle-all-structs-btn');
            toggleAllBtn.addEventListener('click', function() {
                const cards = structContainer.querySelectorAll('.struct-card');
                const isAllCollapsed = this.classList.contains('all-collapsed');
                
                cards.forEach(function(card) {
                    if (isAllCollapsed) {
                        // 전체 펼치기
                        card.classList.remove('collapsed');
                    } else {
                        // 전체 접기
                        card.classList.add('collapsed');
                    }
                    updateStructPreview(card);
                });
                
                // 버튼 상태 토글
                if (isAllCollapsed) {
                    this.classList.remove('all-collapsed');
                    this.innerHTML = '<span class="toggle-icon">▼</span> 전체 접기';
                } else {
                    this.classList.add('all-collapsed');
                    this.innerHTML = '<span class="toggle-icon">▼</span> 전체 펼치기';
                }
            });

            // =========================================
            // 구조체 삭제 버튼 이벤트 위임
            // =========================================
            structContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-struct-btn')) {
                    // 클릭된 버튼의 부모 .struct-card 찾기
                    const card = e.target.closest('.struct-card');
                    if (!card) return;

                    // 확인 대화상자
                    if (confirm('이 구조체를 삭제하시겠습니까?')) {
                        // 해당 카드 제거
                        card.remove();

                        // 남은 카드가 0개면 structCardIndex를 0으로 리셋
                        const remainingCards = structContainer.querySelectorAll('.struct-card');
                        if (remainingCards.length === 0) {
                            structCardIndex = 0;
                        }
                    }
                }
            });

            // =========================================
            // 미리보기 복사 버튼 이벤트 위임
            // =========================================
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('copy-preview-btn')) {
                    const telegram = e.target.dataset.telegram;
                    // HTML 엔티티 디코딩
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = telegram;
                    const decodedTelegram = textarea.value;
                    
                    navigator.clipboard.writeText(decodedTelegram).then(function() {
                        e.target.textContent = '✓ 복사됨';
                        setTimeout(function() {
                            e.target.textContent = '📋 복사';
                        }, 2000);
                    }).catch(function(err) {
                        console.error('복사 실패:', err);
                        // 폴백: 수동 복사 안내
                        alert('자동 복사에 실패했습니다. 텍스트를 직접 선택하여 복사해주세요.');
                    });
                }
            });

            // =========================================
            // KSC 필드 전체 선택/해제 이벤트 위임

            // 도움말 토글 이벤트
            const helpToggle = document.querySelector('.help-toggle');
            const helpContent = document.querySelector('.help-content');
            
            if (helpToggle && helpContent) {
                helpToggle.addEventListener('click', function() {
                    helpToggle.classList.toggle('expanded');
                    helpContent.classList.toggle('expanded');
                });
            }

            // 탭 전환 이벤트
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // 모든 탭 버튼에서 active 제거
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // 클릭된 버튼에 active 추가
                    this.classList.add('active');

                    // 모든 탭 콘텐츠 숨기기
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // 선택된 탭 콘텐츠 표시
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // 샘플 로드 버튼 클릭 이벤트
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML 규격 샘플 설정
                const sampleXml = `<packet id="송금전문" default=" ">
  <col id="헤더시작" type="X" size="6" />
  <col id="거래구분" type="X" size="2" />
  <col id="계좌번호" type="N" size="12" />
  <col id="송금액" type="N" size="15" />
  <col id="받는사람" type="X" size="20" />
  <col id="비고" type="FULL" size="10" />
</packet>`;
                
                // 통전문 샘플 설정 (65 bytes: 55 + 10bytes FULL)
                // FULL 타입 필드는 KSC-5601 2바이트 완성형 인코딩
                // 'OK테스트' (영문2 + 한글3 = 5글자) = 10bytes
                // O→A3CF, K→A3CB, 테→C5D7, 스→BDBA, 트→C6AE
                const kscMixed = String.fromCharCode(
                    0xA3, 0xCF,  // O (전각)
                    0xA3, 0xCB,  // K (전각)
                    0xC5, 0xD7,  // 테
                    0xBD, 0xBA,  // 스
                    0xC6, 0xAE   // 트
                );
                const sampleTelegram = 'HEADER01123456789012000000000100000Hong Gil Dong       ' + kscMixed;
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // 파싱 실행 버튼 클릭 이벤트
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-input과 telegram-input 값 가져오기
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. 둘 다 trim()해서 빈 문자열이면 에러 표시 후 return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("입력값을 확인하세요", 'result-container');
                    return;
                }

                // 3. parseXMLSpec 호출, 결과가 null이면 에러 표시 후 return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML 파싱 실패: 형식을 확인하세요", 'result-container');
                    return;
                }

                // 4. parseTelegram 호출
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults 호출
                displayResults(parsedData);
            });

            // 초기화 버튼 클릭 이벤트
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // 구조체 샘플 로드 버튼 클릭 이벤트
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // 1. recognize-crlf 체크박스 자동 체크
                document.getElementById('recognize-crlf').checked = true;
                
                // 2. 기존 모든 구조체 카드 삭제
                structContainer.innerHTML = '';
                
                // 3. structCardIndex = 0 리셋
                structCardIndex = 0;

                // 4. 구조체 3개 추가
                const sampleStructs = [
                    {
                        // 카드 1: DHF_H
                        name: 'DHF_H',
                        kubun: 'H',
                        definition: `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
  char crlf[2];
} DHF_H;`
                    },
                    {
                        // 카드 2: DHF_D
                        name: 'DHF_D',
                        kubun: 'D',
                        definition: `typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
  char crlf[2];
} DHF_D;`
                    },
                    {
                        // 카드 3: DHF_T
                        name: 'DHF_T',
                        kubun: 'T',
                        definition: `typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
  char crlf[2];
} DHF_T;`
                    }
                ];

                // 각 샘플 구조체마다 카드 생성
                sampleStructs.forEach(function(sample) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);
                    
                    // 카드 내부 입력 필드에 값 설정
                    card.querySelector('.struct-name').value = sample.name;
                    card.querySelector('.struct-kubun').value = sample.kubun;
                    card.querySelector('.struct-definition').value = sample.definition;
                    
                    structCardIndex++;
                });

                // 5. 데이터 설정
                // DHF_H: 1+2+7+2 = 12 bytes (데이터 10 + CRLF 2)
                // DHF_D: 1+16+20+2 = 39 bytes (데이터 37 + CRLF 2)
                // DHF_T: 1+10+20+2 = 33 bytes (데이터 31 + CRLF 2)
                // 일반적인 줄바꿈으로 입력, 각 줄에 \r\n 자동 추가됨
                const sampleData = `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`;

                document.getElementById('struct-data').value = sampleData;
                
                // 6. 완료 메시지 표시
                alert('✓ 샘플 로드 완료\n\n개행문자 인식이 활성화되었습니다.\n각 레코드 끝에 자동으로 CRLF가 추가됩니다.');
            });

            /**
             * =====================================================
             * 테스트 케이스 정의
             * =====================================================
             * 
             * [개행 인식 ON 모드 테스트]
             * - normal: 정상 데이터 - 각 라인이 올바른 길이
             * - short: 길이 부족 - 라인 길이가 구조체 정의보다 짧음
             * - long: 길이 초과 - 라인 길이가 구조체 정의보다 김
             * - mismatch: 매칭 실패 - 구분값에 해당하는 구조체 없음
             * - mixed: 혼합 - 다양한 에러 상황 조합
             * 
             * [개행 인식 OFF 모드 테스트]
             * - continuous: 연속 데이터 - 개행 없이 연속된 레코드
             * - continuous_multi: 연속 다중 - 여러 타입 연속 레코드
             * 
             * 테스트 시 주의사항:
             * - 개행 인식 ON: 각 줄 끝에 CRLF(2 bytes) 자동 추가
             * - 개행 인식 OFF: 모든 줄바꿈 제거 후 연속 파싱
             */
            const testCases = {
                // ========== 개행 인식 ON 테스트 케이스 ==========
                normal: {
                    name: '정상 데이터 (개행 ON)',
                    description: '각 라인 독립 파싱, CRLF 필드 정확히 표시, 길이 뱃지 녹색',
                    mode: 'line-by-line',
                    data: `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`
                },
                short: {
                    name: '길이 부족 (개행 ON)',
                    description: '경고 표시, 다음 라인 침범 안 함, 에러 카드 표시',
                    mode: 'line-by-line',
                    data: `H88123
D12345678901234560000000000000000100
T00000000020000000000000000300`
                },
                long: {
                    name: '길이 초과 (개행 ON)',
                    description: '길이 초과 경고 표시',
                    mode: 'line-by-line',
                    data: `H88123456789999
D123456789012345600000000000000001000`
                },
                mismatch: {
                    name: '매칭 실패 (개행 ON)',
                    description: '에러 카드로 표시, 다음 라인 정상 파싱',
                    mode: 'line-by-line',
                    data: `X1234567890
D123456789012345600000000000000001000`
                },
                mixed: {
                    name: '혼합 테스트 (개행 ON)',
                    description: '정상/부족/초과/매칭실패 혼합',
                    mode: 'line-by-line',
                    data: `H881234567
D123456789012345600000000000000001000
X9999999999
D12345
H88123456789999
T000000000200000000000000003000`
                },
                
                // ========== 개행 인식 OFF 테스트 케이스 ==========
                continuous: {
                    name: '연속 데이터 (개행 OFF)',
                    description: '구분값으로 자동 분리, 줄바꿈 완전 무시',
                    mode: 'continuous',
                    data: `H881234567D123456789012345600000000000000001000D987654321098765400000000000000002000T000000000200000000000000003000`
                },
                continuous_multi: {
                    name: '연속 다중 레코드 (개행 OFF)',
                    description: 'H-D-D-T 순서 연속, 여러 레코드 파싱',
                    mode: 'continuous',
                    data: `H881234567D123456789012345600000000000000001000T0000000001000000000000000010H991234567D987654321098765400000000000000002000T0000000001000000000000000020`
                },
                
                // ========== KSC-5601 테스트 케이스 ==========
                ksc_fullwidth: {
                    name: 'KSC-5601 전각 모드',
                    description: '한글/영문/숫자/공백 모두 2바이트, 타입을 KSC 전각으로 변경하여 확인',
                    mode: 'ksc-fullwidth',
                    // 데이터는 EUC-KR 인코딩된 바이트 (Latin1)
                    // 이름(10B): "홍길동  " = B8AB B1E6 B5BF A1A1 A1A1 (한글 3자 + 전각공백 2개)
                    // 나이(4B): "0025" = A3B0 A3B0 A3B2 A3B5 (전각 숫자)
                    // 등급(4B): "A1  " = A3C1 A3B1 A1A1 (전각 영문+숫자+공백)
                    // 메모(12B): "테스트 OK " = ...
                    data: String.fromCharCode(
                        // === 레코드 1 ===
                        // 구분(1B): 'H'
                        0x48,
                        // 이름(10B): "홍길동" + 전각공백 2개 = B8AB B1E6 B5BF A1A1 A1A1
                        0xC8, 0xAB, 0xB1, 0xE6, 0xB5, 0xBF, 0xA1, 0xA1, 0xA1, 0xA1,
                        // 나이(4B): "25" 전각 = A3B2 A3B5
                        0xA3, 0xB2, 0xA3, 0xB5,
                        // 등급(2B): "A" 전각 = A3C1
                        0xA3, 0xC1,
                        // CRLF
                        0x0D, 0x0A,
                        
                        // === 레코드 2 ===
                        // 구분(1B): 'D'
                        0x44,
                        // 이름(10B): "김영희" + 전각공백 2개 = B1E8 BFC5 C8F1 A1A1 A1A1
                        0xB1, 0xE8, 0xBF, 0xB5, 0xC8, 0xF1, 0xA1, 0xA1, 0xA1, 0xA1,
                        // 나이(4B): "30" 전각 = A3B3 A3B0
                        0xA3, 0xB3, 0xA3, 0xB0,
                        // 등급(2B): "B" 전각 = A3C2
                        0xA3, 0xC2,
                        // CRLF
                        0x0D, 0x0A,
                        
                        // === 레코드 3 ===
                        // 구분(1B): 'T'
                        0x54,
                        // 총원(10B): "총 2명" 전각 = C3D1 A1A1 A3B2 B8ED A1A1 A1A1 A1A1 A1A1
                        0xC3, 0xD1, 0xA1, 0xA1, 0xA3, 0xB2, 0xB8, 0xED, 0xA1, 0xA1,
                        // 평균(4B): "27" 전각 = A3B2 A3B7
                        0xA3, 0xB2, 0xA3, 0xB7,
                        // 상태(2B): "OK" 전각 = 실제로는 ASCII로
                        0x4F, 0x4B
                    )
                },
                ksc_mixed: {
                    name: 'KSC-5601 혼용 모드',
                    description: '한글 2바이트, ASCII 1바이트 혼용, 타입을 KSC 혼용으로 변경하여 확인',
                    mode: 'ksc-mixed',
                    // 혼용 모드: 한글은 EUC-KR 2바이트, ASCII는 1바이트
                    // 이름(8B): "홍길동AB" = B8AB(홍) B1E6(길) B5BF(동) 41(A) 42(B) = 6+2 = 8B
                    // 코드(6B): "ABC123" = 41 42 43 31 32 33 = 6B
                    // 비고(10B): "OK테스트 " = 4F 4B C5D7 BDBA C6AE 20 20 = 2+6+2 = 10B
                    data: String.fromCharCode(
                        // === 레코드 1 ===
                        // 구분(1B): 'H'
                        0x48,
                        // 이름(8B): "홍길동AB" 혼용 = B8AB B1E6 B5BF 41 42
                        0xC8, 0xAB, 0xB1, 0xE6, 0xB5, 0xBF, 0x41, 0x42,
                        // 코드(6B): "ABC123" ASCII
                        0x41, 0x42, 0x43, 0x31, 0x32, 0x33,
                        // 비고(10B): "OK테스트" 혼용 + 공백 = 4F 4B C5D7 BDBA C6AE 20 20
                        0x4F, 0x4B, 0xC5, 0xD7, 0xBD, 0xBA, 0xC6, 0xAE, 0x20, 0x20,
                        // CRLF
                        0x0D, 0x0A,
                        
                        // === 레코드 2 ===
                        // 구분(1B): 'D'
                        0x44,
                        // 이름(8B): "김영희CD" 혼용
                        0xB1, 0xE8, 0xBF, 0xB5, 0xC8, 0xF1, 0x43, 0x44,
                        // 코드(6B): "XYZ789" ASCII
                        0x58, 0x59, 0x5A, 0x37, 0x38, 0x39,
                        // 비고(10B): "완료 OK" 혼용 = BF..  20 4F 4B 20 20 20
                        0xBF, 0xCF, 0xB7, 0xE1, 0x20, 0x4F, 0x4B, 0x20, 0x20, 0x20,
                        // CRLF
                        0x0D, 0x0A,
                        
                        // === 레코드 3 (Trailer) ===
                        // 구분(1B): 'T'
                        0x54,
                        // 총원(8B): "총 2명" 혼용 = C3D1 20 32 B8ED 20 20
                        0xC3, 0xD1, 0x20, 0x32, 0xB8, 0xED, 0x20, 0x20,
                        // 코드(6B): "END   " ASCII
                        0x45, 0x4E, 0x44, 0x20, 0x20, 0x20,
                        // 비고(10B): "정상종료" 혼용 = C1A4 BBF3 C1BE B7E1 20 20
                        0xC1, 0xA4, 0xBB, 0xF3, 0xC1, 0xBE, 0xB7, 0xE1, 0x20, 0x20
                    )
                },
                
                // ========== 단일 구조체 테스트 케이스 ==========
                single_struct_ascii: {
                    name: 'ASCII 단일 구조체',
                    description: '구조체 1개, ASCII 데이터만 사용하는 간단한 테스트',
                    mode: 'single',
                    struct: `typedef struct {
    char name[10];     // 이름
    char age[3];       // 나이
    char grade[2];     // 등급
} PERSON;`,
                    data: 'HONG      025A1'
                },
                single_struct_ksc: {
                    name: 'KSC 단일 구조체',
                    description: '구조체 1개, KSC-5601 전각 데이터 (타입을 KSC 전각으로 변경하여 확인)',
                    mode: 'single-ksc',
                    struct: `typedef struct {
    char name[10];     // 이름 (KSC-5601 전각)
    char age[4];       // 나이 (전각 숫자 2자리)
    char grade[2];     // 등급 (전각 영문 1자리)
} PERSON;`,
                    // 이름(10B): "홍길동" + 전각공백 2개
                    // 나이(4B): "25" 전각
                    // 등급(2B): "A" 전각
                    data: String.fromCharCode(
                        0xC8, 0xAB, 0xB1, 0xE6, 0xB5, 0xBF, 0xA1, 0xA1, 0xA1, 0xA1,  // 홍길동 + 공백
                        0xA3, 0xB2, 0xA3, 0xB5,  // 25
                        0xA3, 0xC1               // A
                    )
                }
            };

            // 테스트 케이스 모달 관련 요소
            const testModal = document.getElementById('test-case-modal');
            const testBtn = document.getElementById('struct-test-btn');
            const closeTestBtn = testModal.querySelector('.close-test');
            const testButtons = testModal.querySelectorAll('.test-buttons button');

            // 테스트 케이스 버튼 클릭 시 모달 표시
            testBtn.addEventListener('click', function() {
                testModal.classList.add('show');
            });

            // 닫기 버튼 클릭 시 모달 닫기
            closeTestBtn.addEventListener('click', function() {
                testModal.classList.remove('show');
            });

            // 모달 배경 클릭 시 닫기
            testModal.addEventListener('click', function(e) {
                if (e.target === testModal) {
                    testModal.classList.remove('show');
                }
            });

            /**
             * 테스트 케이스 버튼 클릭 이벤트 핸들러
             * - 테스트 케이스 mode에 따라 개행 인식 옵션 자동 설정
             * - line-by-line: 개행 인식 ON (각 줄 독립 파싱)
             * - continuous: 개행 인식 OFF (연속 데이터 파싱)
             * - ksc-fullwidth: KSC-5601 전각 모드 (모든 문자 2바이트)
             * - ksc-mixed: KSC-5601 혼용 모드 (한글 2바이트, ASCII 1바이트)
             */
            testButtons.forEach(function(button) {
                button.addEventListener('click', function() {
                    const caseType = this.getAttribute('data-case');
                    const testCase = testCases[caseType];
                    
                    if (!testCase) return;

                    // 1. 테스트 케이스 모드에 따라 개행 인식 체크박스 설정
                    const isLineByLineMode = testCase.mode === 'line-by-line';
                    const isKSCMode = testCase.mode.startsWith('ksc-');
                    
                    // KSC 모드는 개행 인식 ON (CRLF 포함)
                    document.getElementById('recognize-crlf').checked = isLineByLineMode || isKSCMode;
                    
                    // 2. 기존 모든 구조체 카드 삭제
                    structContainer.innerHTML = '';
                    
                    // 3. structCardIndex = 0 리셋
                    structCardIndex = 0;

                    // 4. 구조체 정의 설정
                    let sampleStructs;
                    
                    // 단일 구조체 모드: testCase.struct가 있으면 직접 사용
                    if (testCase.struct) {
                        sampleStructs = [{
                            name: 'SINGLE',
                            kubun: '',
                            definition: testCase.struct
                        }];
                    } else if (testCase.mode === 'ksc-fullwidth') {
                        // === KSC-5601 전각 모드용 구조체 ===
                        sampleStructs = [
                            {
                                name: 'KSC_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분 'H' (ASCII)
  char name[10];         // 이름 (KSC전각: 한글3자+공백2개 = 10B)
  char age[4];           // 나이 (KSC전각: 숫자2자 = 4B)
  char grade[2];         // 등급 (KSC전각: 영문1자 = 2B)
  char crlf[2];          // 개행문자
} KSC_H;  // 총 19 bytes`
                            },
                            {
                                name: 'KSC_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분 'D' (ASCII)
  char name[10];         // 이름 (KSC전각: 한글3자+공백2개 = 10B)
  char age[4];           // 나이 (KSC전각: 숫자2자 = 4B)
  char grade[2];         // 등급 (KSC전각: 영문1자 = 2B)
  char crlf[2];          // 개행문자
} KSC_D;  // 총 19 bytes`
                            },
                            {
                                name: 'KSC_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분 'T' (ASCII)
  char summary[10];      // 요약 (KSC전각: "총 2명" 등 = 10B)
  char avg[4];           // 평균 (KSC전각: 숫자2자 = 4B)
  char status[2];        // 상태 (ASCII: "OK" = 2B)
} KSC_T;  // 총 17 bytes (CRLF 없음)`
                            }
                        ];
                    } else if (testCase.mode === 'ksc-mixed') {
                        // === KSC-5601 혼용 모드용 구조체 ===
                        sampleStructs = [
                            {
                                name: 'MIX_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분 'H'
  char name[8];          // 이름 (혼용: 한글3자6B + ASCII2자2B = 8B)
  char code[6];          // 코드 (ASCII: 6B)
  char memo[10];         // 비고 (혼용: "OK테스트" = 2+6+2 = 10B)
  char crlf[2];          // 개행문자
} MIX_H;  // 총 27 bytes`
                            },
                            {
                                name: 'MIX_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분 'D'
  char name[8];          // 이름 (혼용: 8B)
  char code[6];          // 코드 (ASCII: 6B)
  char memo[10];         // 비고 (혼용: 10B)
  char crlf[2];          // 개행문자
} MIX_D;  // 총 27 bytes`
                            },
                            {
                                name: 'MIX_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분 'T'
  char summary[8];       // 요약 (혼용: "총 2명" = 8B)
  char code[6];          // 코드 (ASCII: "END   " = 6B)
  char memo[10];         // 비고 (혼용: "정상종료" = 10B)
} MIX_T;  // 총 25 bytes (CRLF 없음)`
                            }
                        ];
                    } else if (isLineByLineMode) {
                        // === 개행 인식 ON용 구조체 (CRLF 필드 포함) ===
                        sampleStructs = [
                            {
                                name: 'DHF_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'H'
  char bank_cd[2];       // 은행 코드
  char cust_id[7];       // 고객 ID
  char crlf[2];          // 개행문자 (CRLF)
} DHF_H;`
                            },
                            {
                                name: 'DHF_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'D'
  char acno[16];         // 계좌번호
  char amt[20];          // 금액
  char crlf[2];          // 개행문자 (CRLF)
} DHF_D;`
                            },
                            {
                                name: 'DHF_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'T'
  char tot_cnt[10];      // 총 건수
  char tot_amt[20];      // 총 금액
  char crlf[2];          // 개행문자 (CRLF)
} DHF_T;`
                            }
                        ];
                    } else {
                        // === 개행 인식 OFF용 구조체 (CRLF 필드 제외) ===
                        sampleStructs = [
                            {
                                name: 'DHF_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'H'
  char bank_cd[2];       // 은행 코드
  char cust_id[7];       // 고객 ID
} DHF_H;  // 총 10 bytes (개행 없음)`
                            },
                            {
                                name: 'DHF_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'D'
  char acno[16];         // 계좌번호
  char amt[20];          // 금액
} DHF_D;  // 총 37 bytes (개행 없음)`
                            },
                            {
                                name: 'DHF_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'T'
  char tot_cnt[10];      // 총 건수
  char tot_amt[20];      // 총 금액
} DHF_T;  // 총 31 bytes (개행 없음)`
                            }
                        ];
                    }

                    // 각 샘플 구조체마다 카드 생성
                    sampleStructs.forEach(function(sample) {
                        const card = createStructCard(structCardIndex);
                        structContainer.appendChild(card);
                        
                        card.querySelector('.struct-name').value = sample.name;
                        card.querySelector('.struct-kubun').value = sample.kubun;
                        card.querySelector('.struct-definition').value = sample.definition;
                        
                        structCardIndex++;
                    });

                    // 5. 테스트 데이터 설정
                    document.getElementById('struct-data').value = testCase.data;
                    
                    // 6. 모달 닫기
                    testModal.classList.remove('show');
                    
                    // 7. 완료 메시지 표시 (모드 정보 포함)
                    let modeInfo;
                    if (testCase.mode === 'ksc-fullwidth') {
                        modeInfo = 'KSC-5601 전각 모드입니다.\n\n' +
                                   '※ 파싱 후 타입 컬럼의 드롭다운을 "KSC 전각"으로 변경하면\n' +
                                   '   한글이 올바르게 표시됩니다.\n\n' +
                                   '테스트 데이터:\n' +
                                   '- 이름: 홍길동, 김영희 (한글)\n' +
                                   '- 나이: 25, 30 (숫자)\n' +
                                   '- 등급: A, B (영문)';
                    } else if (testCase.mode === 'ksc-mixed') {
                        modeInfo = 'KSC-5601 혼용 모드입니다.\n\n' +
                                   '※ 파싱 후 타입 컬럼의 드롭다운을 "KSC 혼용"으로 변경하면\n' +
                                   '   한글이 올바르게 표시됩니다.\n\n' +
                                   '테스트 데이터:\n' +
                                   '- 이름: 홍길동AB, 김영희CD (한글+영문 혼용)\n' +
                                   '- 코드: ABC123, XYZ789 (ASCII)\n' +
                                   '- 비고: OK테스트, 완료 OK (혼용)';
                    } else if (isLineByLineMode) {
                        modeInfo = '개행문자 인식이 활성화되었습니다.\n각 레코드 끝에 CRLF(2 bytes)가 있습니다.';
                    } else {
                        modeInfo = '개행문자 인식이 비활성화되었습니다.\n연속 데이터로 파싱됩니다.';
                    }
                    
                    alert('✓ 테스트 케이스 로드 완료\n\n' +
                          '테스트: ' + testCase.name + '\n' +
                          '설명: ' + (testCase.description || '') + '\n\n' +
                          modeInfo);
                });
            });

            // ESC 키로 테스트 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && testModal.classList.contains('show')) {
                    testModal.classList.remove('show');
                }
            });

            /**
             * 구조체 파싱 실행 함수 (재사용 가능)
             * 버튼 클릭 또는 인코딩 옵션 변경 시 호출
             */
            function executeStructParsing() {
                // 1. collectStructDefinitions() 호출
                const structDefs = collectStructDefinitions();
                
                // null이면 중단 (에러는 함수 내부에서 표시)
                if (structDefs === null) {
                    return null;
                }

                // 2. struct-data 값 가져오기, trim
                const data = document.getElementById('struct-data').value.trim();
                
                // 비어있으면 displayError("데이터를 입력하세요")
                if (data === '') {
                    displayError('데이터를 입력하세요', 'struct-result-container');
                    return null;
                }

                // 3. parseStructData(data, structDefs) 호출
                const result = parseStructData(data, structDefs);
                
                // structDefs를 result에 추가
                result.structDefs = structDefs;

                // 4. displayStructResults(result) 호출
                displayStructResults(result);

                // 5. 성공 시 콘솔에 로그
                const count = result.stats.recordCount;
                const percent = result.stats.totalBytes > 0 
                    ? ((result.stats.parsedBytes / result.stats.totalBytes) * 100).toFixed(1)
                    : 0;
                console.log('파싱 완료: 레코드 ' + count + '개, 성공률 ' + percent + '%');
                
                return result;
            }

            // 구조체 파싱 실행 버튼 클릭 이벤트
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                executeStructParsing();
            });

            // 입력창 변경 시 재생성된 바이트 데이터 무효화
            // 사용자가 직접 입력창을 수정하면 바이트 데이터와 불일치하므로 무효화
            document.getElementById('struct-data').addEventListener('input', function() {
                if (window.structAppliedFromRegenerate) {
                    // 입력창 값이 재생성 데이터와 다르면 무효화
                    if (this.value !== window.structRegeneratedDisplayText) {
                        window.structAppliedFromRegenerate = false;
                        window.structRegeneratedBytes = null;
                        window.structRegeneratedDisplayText = null;
                        console.log('📌 입력창 수정됨: 재생성 바이트 데이터 무효화');
                    }
                }
            });

            // 입력 인코딩 옵션 변경 시 재파싱
            document.getElementById('input-encoding').addEventListener('change', function() {
                const hasData = document.getElementById('struct-data').value.trim().length > 0;
                const hasResults = document.getElementById('struct-result-container').children.length > 0;
                
                // 데이터와 결과가 모두 있을 때만 재파싱
                if (hasData && hasResults) {
                    const selectedEncoding = this.value;
                    const encodingName = selectedEncoding === 'auto' ? '자동 감지' : 
                                        selectedEncoding === 'ksc5601' ? 'KSC-5601' : 'ASCII';
                    console.log(`🔄 인코딩 변경: ${encodingName} → 재파싱 실행`);
                    executeStructParsing();
                }
            });

            // 구조체 초기화 버튼 클릭 이벤트
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                // 확인 대화상자
                if (!confirm('모든 입력을 초기화하시겠습니까?')) {
                    return;
                }
                
                // 1. struct-definitions-container innerHTML = ''
                structContainer.innerHTML = '';
                
                // 2. struct-data value = ''
                document.getElementById('struct-data').value = '';
                
                // 3. struct-result-container innerHTML = ''
                document.getElementById('struct-result-container').innerHTML = '';
                
                // 4. structCardIndex = 0
                structCardIndex = 0;
                
                // 5. 첫 번째 빈 카드 자동 추가
                structContainer.appendChild(createStructCard(structCardIndex));
                structCardIndex++;
                
                // 6. 필드 타입 오버라이드 초기화
                window.structFieldTypeOverrides = null;
                window.structParsedDataCurrent = null;
                window.structParsedDataOriginal = null;
            });

            // 테스트 실행 버튼 클릭 이벤트 (버튼이 존재할 경우에만)
            const runTestsBtn = document.getElementById('run-tests-btn');
            if (runTestsBtn) {
                runTestsBtn.addEventListener('click', function() {
                    const testResult = runTests();
                    displayTestResults(testResult);
                });
            }

            // 디코딩 모드 드롭다운 변경 이벤트 (이벤트 위임 사용)
            document.getElementById('struct-result-container').addEventListener('change', function(e) {
                if (!e.target.classList.contains('decoding-mode-select')) {
                    return;
                }
                
                const select = e.target;
                const mode = select.value;
                const recordIndex = parseInt(select.getAttribute('data-record-index'));
                const fieldIndex = parseInt(select.getAttribute('data-field-index'));
                
                // 같은 행의 값 셀 찾기
                const tr = select.closest('tr');
                const valueSpan = tr.querySelector('.editable-value');
                
                if (!valueSpan) return;
                
                // 원본 바이트 가져오기
                const rawValue = valueSpan.getAttribute('data-raw-value');
                if (!rawValue) return;
                
                // 선택한 모드로 재디코딩
                const newValue = decodeByMode(rawValue, mode).trim();
                
                // 값 업데이트
                valueSpan.textContent = newValue;
                valueSpan.setAttribute('data-original-value', newValue);
                valueSpan.classList.remove('modified');
                
                // 드롭다운 스타일 업데이트
                if (mode === 'ascii') {
                    select.classList.remove('ksc-active');
                } else {
                    select.classList.add('ksc-active');
                }
                
                // 펄스 애니메이션
                select.classList.add('value-changed');
                setTimeout(function() {
                    select.classList.remove('value-changed');
                }, 500);
                
                // 전역 데이터 업데이트
                const newFieldType = mode === 'fullwidth' ? 'KSC-5601 (전각)' : 
                                     mode === 'mixed' ? 'KSC-5601 (혼용)' : 'ASCII';
                                     
                if (window.structParsedDataCurrent && 
                    window.structParsedDataCurrent[recordIndex] && 
                    window.structParsedDataCurrent[recordIndex].fields[fieldIndex]) {
                    window.structParsedDataCurrent[recordIndex].fields[fieldIndex].value = newValue;
                    window.structParsedDataCurrent[recordIndex].fields[fieldIndex].fieldType = newFieldType;
                }
                
                // 타입 변경에 따른 바이트 길이 재계산 및 표시
                const fieldSize = parseInt(valueSpan.getAttribute('data-field-size'));
                const byteLength = calculateByteLength(newValue, newFieldType);
                
                if (byteLength > fieldSize) {
                    valueSpan.classList.add('byte-overflow');
                    valueSpan.title = `바이트 초과: ${byteLength}/${fieldSize} bytes`;
                } else {
                    valueSpan.classList.remove('byte-overflow');
                    valueSpan.title = `${byteLength}/${fieldSize} bytes`;
                }
                
                // 바이트 뱃지 업데이트
                const badge = tr.querySelector('.byte-info-badge');
                if (badge) {
                    badge.textContent = `${byteLength}/${fieldSize}B`;
                    badge.classList.remove('byte-ok', 'byte-warning', 'byte-error');
                    if (byteLength > fieldSize) {
                        badge.classList.add('byte-error');
                    } else if (byteLength > fieldSize * 0.9) {
                        badge.classList.add('byte-warning');
                    } else {
                        badge.classList.add('byte-ok');
                    }
                }
                
                console.log(`필드 [${fieldIndex}] 디코딩 모드 변경: ${mode} → "${newValue}" (${byteLength}/${fieldSize} bytes)`);
                
                // 안내 메시지: 디코딩만 변경됨 (바이트 위치는 그대로)
                // 전체 재파싱이 필요하면 입력 인코딩 옵션을 변경하세요
            });
            
            /**
             * 전체 필드 인코딩 일괄 변경 함수
             * 모든 필드의 디코딩 모드를 변경하고 재디코딩
             * @param {string} mode - 'ascii', 'fullwidth', 'mixed'
             */
            window.changeAllFieldsEncoding = function(mode) {
                const selects = document.querySelectorAll('.decoding-mode-select');
                selects.forEach(select => {
                    select.value = mode;
                    select.dispatchEvent(new Event('change', { bubbles: true }));
                });
                console.log(`모든 필드 인코딩 변경: ${mode}`);
            };

            // 복사 버튼 및 원본 버튼 클릭 이벤트 (이벤트 위임 사용)
            document.getElementById('struct-result-container').addEventListener('click', function(e) {
                // 원본 보기 버튼 클릭 처리
                if (e.target.classList.contains('show-raw-btn')) {
                    const rawValue = e.target.getAttribute('data-raw');
                    if (rawValue) {
                        // 원본 바이트를 HEX로 변환하여 표시
                        const decoded = rawValue.replace(/&amp;/g, '&')
                                                .replace(/&lt;/g, '<')
                                                .replace(/&gt;/g, '>')
                                                .replace(/&quot;/g, '"');
                        const hexValue = Array.from(decoded).map(function(c) {
                            return c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                        }).join(' ');
                        
                        alert('원본 바이트:\n' + decoded + '\n\nHEX:\n' + hexValue);
                    }
                    return;
                }
                
                // 클릭된 요소가 복사 버튼인지 확인
                if (!e.target.classList.contains('copy-record-btn')) {
                    return;
                }

                const btn = e.target;

                // 1. data-record 속성에서 recordIndex 가져오기
                const recordIndex = btn.getAttribute('data-record');

                // 해당 레코드의 그룹 찾기
                const groupDiv = btn.closest('.struct-result-group');
                if (!groupDiv) {
                    return;
                }

                // 테이블의 tbody에서 모든 행 가져오기
                const tbody = groupDiv.querySelector('tbody');
                if (!tbody) {
                    return;
                }

                const rows = tbody.querySelectorAll('tr');
                
                // 2. TSV 형식으로 변환 (필드명\t타입\t크기\t값)
                const tsvLines = [];
                rows.forEach(function(row) {
                    const cells = row.querySelectorAll('td');
                    // 6개 컬럼: 필드명, 타입, 크기, 시작, 종료, 값
                    if (cells.length >= 6) {
                        const fieldName = cells[0].textContent;  // 필드명
                        const fieldType = cells[1].textContent;  // 타입
                        const size = cells[2].textContent;       // 크기
                        // 값 셀에서 editable-value span 또는 code 내용 추출
                        const valueCell = cells[5];
                        const editableSpan = valueCell.querySelector('.editable-value');
                        const codeEl = valueCell.querySelector('code');
                        const value = editableSpan ? editableSpan.textContent : (codeEl ? codeEl.textContent : valueCell.textContent);
                        tsvLines.push(fieldName + '\t' + fieldType + '\t' + size + '\t' + value);
                    }
                });

                const tsvText = tsvLines.join('\n');

                // 3. 클립보드에 복사
                navigator.clipboard.writeText(tsvText).then(function() {
                    // 4. 복사 성공 시:
                    // - 버튼 텍스트 → "✓ 복사됨"
                    const originalText = btn.textContent;
                    const originalBg = btn.style.backgroundColor;
                    
                    btn.textContent = '✓ 복사됨';
                    // - 배경색 임시 변경
                    btn.style.backgroundColor = '#17a2b8';
                    
                    // - 2초 후 원래대로
                    setTimeout(function() {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = originalBg;
                    }, 2000);
                }).catch(function(err) {
                    console.error('클립보드 복사 실패:', err);
                    alert('복사에 실패했습니다.');
                });
            });

            // =========================================
            // 구조체 카드 접기/펼치기 이벤트
            // - 헤더 클릭 시 본문 토글
            // - 아이콘 변경 (▼ ↔ ▶)
            // =========================================
            structContainer.addEventListener('click', function(e) {
                // 삭제 버튼이나 드래그 핸들 클릭 시 무시
                if (e.target.classList.contains('remove-struct-btn') || 
                    e.target.classList.contains('drag-handle')) {
                    return;
                }

                // 헤더 영역 클릭 확인
                const header = e.target.closest('.struct-card-header');
                if (!header) return;

                const card = header.closest('.struct-card');
                if (!card) return;

                // collapsed 클래스 토글
                card.classList.toggle('collapsed');

                // 접힌 상태에서 구조체명 미리보기 업데이트
                updateStructPreview(card);
            });

            /**
             * 구조체 미리보기 텍스트 업데이트
             * @param {HTMLElement} card - 구조체 카드 요소
             */
            function updateStructPreview(card) {
                const preview = card.querySelector('.struct-preview');
                const nameInput = card.querySelector('.struct-name');
                const kubunInput = card.querySelector('.struct-kubun');

                if (card.classList.contains('collapsed') && preview) {
                    const name = nameInput ? nameInput.value.trim() : '';
                    const kubun = kubunInput ? kubunInput.value.trim() : '';
                    
                    let previewText = '';
                    if (name) previewText += name;
                    if (kubun) previewText += (name ? ' ' : '') + '[' + kubun + ']';
                    
                    preview.textContent = previewText ? '- ' + previewText : '';
                } else if (preview) {
                    preview.textContent = '';
                }
            }

            // 입력값 변경 시 미리보기 업데이트
            structContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('struct-name') || 
                    e.target.classList.contains('struct-kubun')) {
                    const card = e.target.closest('.struct-card');
                    if (card) updateStructPreview(card);
                }
            });

            // =========================================
            // 드래그 앤 드롭 재정렬 기능
            // HTML5 Drag API 사용
            // =========================================
            let draggedCard = null;

            // 드래그 시작
            structContainer.addEventListener('dragstart', function(e) {
                const card = e.target.closest('.struct-card');
                if (!card) return;

                draggedCard = card;
                card.classList.add('dragging');

                // 드래그 이미지 설정 (선택사항)
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', card.getAttribute('data-index'));
            });

            // 드래그 종료
            structContainer.addEventListener('dragend', function(e) {
                const card = e.target.closest('.struct-card');
                if (card) {
                    card.classList.remove('dragging');
                }
                draggedCard = null;

                // 모든 drag-over 클래스 제거
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });

                // 카드 인덱스 재정렬
                renumberStructCards();
            });

            // 드래그 오버
            structContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                const card = e.target.closest('.struct-card');
                if (!card || card === draggedCard) return;

                // drag-over 클래스 추가
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });
                card.classList.add('drag-over');
            });

            // 드롭
            structContainer.addEventListener('drop', function(e) {
                e.preventDefault();

                const targetCard = e.target.closest('.struct-card');
                if (!targetCard || !draggedCard || targetCard === draggedCard) return;

                // 드래그한 카드를 타겟 위치로 이동
                const cards = Array.from(structContainer.querySelectorAll('.struct-card'));
                const draggedIndex = cards.indexOf(draggedCard);
                const targetIndex = cards.indexOf(targetCard);

                if (draggedIndex < targetIndex) {
                    // 아래로 이동
                    targetCard.parentNode.insertBefore(draggedCard, targetCard.nextSibling);
                } else {
                    // 위로 이동
                    targetCard.parentNode.insertBefore(draggedCard, targetCard);
                }

                targetCard.classList.remove('drag-over');
            });

            /**
             * 구조체 카드 번호 재정렬
             */
            function renumberStructCards() {
                const cards = structContainer.querySelectorAll('.struct-card');
                cards.forEach(function(card, index) {
                    const numberSpan = card.querySelector('.struct-number');
                    if (numberSpan) {
                        numberSpan.textContent = '구조체 #' + (index + 1);
                    }
                    card.setAttribute('data-index', index);
                });
            }

            // =========================================
            // 로컬 스토리지 저장/복원 기능
            // - 페이지 떠날 때 자동 저장
            // - 재방문 시 복원 제안
            // =========================================
            const STORAGE_KEY = 'structParserData';

            /**
             * 현재 구조체 정의들을 로컬 스토리지에 저장
             */
            function saveToLocalStorage() {
                const cards = structContainer.querySelectorAll('.struct-card');
                const data = [];

                cards.forEach(function(card) {
                    const name = card.querySelector('.struct-name').value;
                    const kubun = card.querySelector('.struct-kubun').value;
                    const definition = card.querySelector('.struct-definition').value;
                    const collapsed = card.classList.contains('collapsed');

                    // 하나라도 입력된 카드만 저장
                    if (name || kubun || definition) {
                        data.push({
                            name: name,
                            kubun: kubun,
                            definition: definition,
                            collapsed: collapsed
                        });
                    }
                });

                // 데이터가 있을 때만 저장
                if (data.length > 0) {
                    const saveData = {
                        structs: data,
                        structData: document.getElementById('struct-data').value,
                        savedAt: new Date().toISOString()
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
                    console.log('로컬 스토리지에 저장됨:', data.length + '개 구조체');
                }
            }

            /**
             * 로컬 스토리지에서 복원
             */
            function restoreFromLocalStorage() {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (!savedData) return;

                try {
                    const data = JSON.parse(savedData);
                    if (!data.structs || data.structs.length === 0) return;

                    // 저장 시간 표시
                    const savedAt = new Date(data.savedAt);
                    const timeStr = savedAt.toLocaleString('ko-KR');

                    // 복원 알림 표시
                    showRestoreNotification(data, timeStr);
                } catch (e) {
                    console.error('로컬 스토리지 데이터 파싱 실패:', e);
                }
            }

            /**
             * 복원 알림 UI 표시
             */
            function showRestoreNotification(data, timeStr) {
                // 기존 알림 제거
                const existingNotif = document.querySelector('.restore-notification');
                if (existingNotif) existingNotif.remove();

                const notification = document.createElement('div');
                notification.className = 'restore-notification';
                notification.innerHTML = `
                    <span class="restore-notification-text">
                        📁 이전 작업을 복원할 수 있습니다 (${timeStr}, ${data.structs.length}개 구조체)
                    </span>
                    <div class="restore-notification-actions">
                        <button class="restore-btn primary" id="restore-yes">복원</button>
                        <button class="restore-btn secondary" id="restore-no">무시</button>
                    </div>
                `;

                // DOM에 삽입할 위치 찾기
                let inserted = false;
                
                // 1순위: struct-definitions-area 앞에 삽입
                const inputSection = document.getElementById('struct-definitions-area');
                if (inputSection && inputSection.parentNode) {
                    inputSection.parentNode.insertBefore(notification, inputSection);
                    inserted = true;
                }
                
                // 2순위: struct-tab에 추가
                if (!inserted) {
                    const structTab = document.getElementById('struct-tab');
                    if (structTab) {
                        if (structTab.firstChild) {
                            structTab.insertBefore(notification, structTab.firstChild);
                        } else {
                            structTab.appendChild(notification);
                        }
                        inserted = true;
                    }
                }
                
                // 3순위: body에 추가 (최후의 fallback)
                if (!inserted) {
                    document.body.appendChild(notification);
                    inserted = true;
                }

                // 알림 내부의 버튼에 이벤트 연결 (notification 내부에서 찾기)
                const restoreYesBtn = notification.querySelector('#restore-yes');
                const restoreNoBtn = notification.querySelector('#restore-no');
                
                if (restoreYesBtn) {
                    restoreYesBtn.addEventListener('click', function() {
                        doRestore(data);
                        notification.remove();
                    });
                }

                if (restoreNoBtn) {
                    restoreNoBtn.addEventListener('click', function() {
                        notification.remove();
                        localStorage.removeItem(STORAGE_KEY); // 저장된 데이터 삭제
                    });
                }
            }

            /**
             * 실제 복원 수행
             */
            function doRestore(data) {
                // 기존 카드 삭제
                structContainer.innerHTML = '';
                structCardIndex = 0;

                // 저장된 구조체 복원
                data.structs.forEach(function(struct) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);

                    card.querySelector('.struct-name').value = struct.name || '';
                    card.querySelector('.struct-kubun').value = struct.kubun || '';
                    card.querySelector('.struct-definition').value = struct.definition || '';

                    if (struct.collapsed) {
                        card.classList.add('collapsed');
                        updateStructPreview(card);
                    }

                    structCardIndex++;
                });

                // 데이터 복원
                if (data.structData) {
                    document.getElementById('struct-data').value = data.structData;
                }

                console.log('로컬 스토리지에서 복원됨:', data.structs.length + '개 구조체');
            }

            // 페이지 떠날 때 자동 저장
            window.addEventListener('beforeunload', function() {
                saveToLocalStorage();
            });

            // 페이지 로드 시 복원 제안 표시
            // 구조체 탭이 활성화될 때까지 대기
            setTimeout(function() {
                restoreFromLocalStorage();
            }, 100);

            // =========================================
            // 다크모드 토글 기능
            // - localStorage에 테마 설정 저장
            // =========================================
            const THEME_KEY = 'structParserTheme';
            const themeToggle = document.getElementById('theme-toggle');

            /**
             * 테마 초기화
             */
            function initTheme() {
                const savedTheme = localStorage.getItem(THEME_KEY);
                if (savedTheme === 'dark') {
                    document.body.classList.add('dark-mode');
                    themeToggle.textContent = '☀️';
                } else {
                    themeToggle.textContent = '🌙';
                }
            }

            /**
             * 테마 토글
             */
            function toggleTheme() {
                const isDark = document.body.classList.toggle('dark-mode');
                localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
                themeToggle.textContent = isDark ? '☀️' : '🌙';
            }

            // 테마 초기화
            initTheme();

            // 테마 토글 버튼 클릭 이벤트
            themeToggle.addEventListener('click', toggleTheme);

            // =========================================
            // 개발 노트 토글 기능
            // =========================================
            const devnoteToggle = document.getElementById('devnote-toggle');
            const devnotePanel = document.getElementById('devnote-panel');
            
            if (devnoteToggle && devnotePanel) {
                devnoteToggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    devnotePanel.classList.toggle('open');
                    
                    if (devnotePanel.classList.contains('open')) {
                        devnotePanel.style.display = 'block';
                    } else {
                        // 애니메이션 후 숨기기
                        setTimeout(() => {
                            if (!devnotePanel.classList.contains('open')) {
                                devnotePanel.style.display = 'none';
                            }
                        }, 400);
                    }
                });
            }

            // =========================================
            // 키보드 단축키
            // - Ctrl+Enter: 파싱 실행
            // - Ctrl+N: 구조체 추가
            // =========================================
            document.addEventListener('keydown', function(e) {
                // Ctrl+Enter: 파싱 실행
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    
                    // 현재 활성화된 탭 확인
                    const xmlTabActive = document.getElementById('xml-tab').classList.contains('active');
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');

                    if (xmlTabActive) {
                        document.getElementById('parse-btn').click();
                    } else if (structTabActive) {
                        document.getElementById('struct-parse-btn').click();
                    }
                }

                // Ctrl+N: 구조체 추가 (struct 탭에서만)
                if (e.ctrlKey && e.key === 'n') {
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');
                    if (structTabActive) {
                        e.preventDefault();
                        document.getElementById('add-struct-btn').click();
                    }
                }
            });

            /**
             * =====================================================
             * 개행문자 인식 (CRLF) 체크박스 변경 이벤트
             * =====================================================
             * 
             * [옵션 전환 동작]
             * - 체크(ON): 라인 기반 파싱 모드
             *   → 각 줄을 독립 레코드로 처리
             *   → CRLF(2 bytes)가 레코드 끝에 자동 추가
             * 
             * - 해제(OFF): 연속 데이터 파싱 모드
             *   → 모든 줄바꿈 제거 후 연속 파싱
             *   → 구분값 기반 레코드 분리
             * 
             * [사용자 확인]
             * - 기존 데이터/결과가 있으면 재파싱 확인
             * - 취소 시 체크 상태 롤백
             */
            document.getElementById('recognize-crlf').addEventListener('change', function(e) {
                const isChecked = e.target.checked;
                const hasData = document.getElementById('struct-data').value.trim().length > 0;
                const hasResults = document.getElementById('struct-result-container').children.length > 0;

                if (hasData || hasResults) {
                    const confirmed = confirm(
                        '옵션을 변경하면 기존 파싱 결과가 영향을 받을 수 있습니다.\n' +
                        '다시 파싱하시겠습니까?'
                    );

                    if (confirmed) {
                        // 결과 초기화
                        document.getElementById('struct-result-container').innerHTML = '';

                        // 알림
                        const msg = isChecked
                            ? '개행문자 인식이 활성화되었습니다. 각 레코드 끝에 CRLF(2 bytes)가 추가됩니다.'
                            : '개행문자 인식이 비활성화되었습니다. 모든 줄바꿈이 제거됩니다.';

                        // 임시 메시지 표시
                        showTemporaryMessage(msg);
                    } else {
                        // 변경 취소
                        e.target.checked = !isChecked;
                    }
                }
            });

            /**
             * 임시 메시지 표시 함수
             * @param {string} message - 표시할 메시지
             */
            function showTemporaryMessage(message) {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'temporary-message';
                msgDiv.textContent = message;
                document.body.appendChild(msgDiv);

                setTimeout(function() {
                    msgDiv.classList.add('fade-out');
                    setTimeout(function() {
                        msgDiv.remove();
                    }, 300);
                }, 3000);
            }

            // =========================================
            // 도움말 모달 이벤트 핸들러
            // =========================================
            const crlfHelpBtn = document.getElementById('crlf-help');
            const crlfHelpModal = document.getElementById('crlf-help-modal');
            const closeHelpBtn = crlfHelpModal.querySelector('.close-help');

            // 도움말 아이콘 클릭 시 모달 표시
            crlfHelpBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                crlfHelpModal.classList.add('show');
            });

            // 닫기 버튼 클릭 시 모달 닫기
            closeHelpBtn.addEventListener('click', function() {
                crlfHelpModal.classList.remove('show');
            });

            // 모달 배경 클릭 시 닫기
            crlfHelpModal.addEventListener('click', function(e) {
                if (e.target === crlfHelpModal) {
                    crlfHelpModal.classList.remove('show');
                }
            });

            // =========================================
            // KSC-5601 도움말 모달 이벤트 핸들러
            // =========================================
            const kscHelpModal = document.getElementById('ksc-help-modal');
            const kscCloseBtn = kscHelpModal.querySelector('.close-help');

            // ESC 키로 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && crlfHelpModal.classList.contains('show')) {
                    crlfHelpModal.classList.remove('show');
                }
                if (e.key === 'Escape' && kscHelpModal.classList.contains('show')) {
                    kscHelpModal.classList.remove('show');
                }
            });

            // help-icon-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('help-icon-btn') || 
                    e.target.closest('.help-icon-btn')) {
                    const btn = e.target.classList.contains('help-icon-btn') 
                        ? e.target 
                        : e.target.closest('.help-icon-btn');
                    
                    if (btn.dataset.help === 'ksc5601') {
                        e.preventDefault();
                        e.stopPropagation();
                        kscHelpModal.classList.add('show');
                    }
                }
            });

            // =========================================
            // KSC-5601 입력기 모달 이벤트 핸들러
            // =========================================
            const kscInputModal = document.getElementById('ksc-input-modal');
            const kscInputCloseBtn = kscInputModal.querySelector('.close-help');
            const kscInputText = document.getElementById('ksc-input-text');
            const kscResultFullwidth = document.getElementById('ksc-result-fullwidth');
            const kscResultBytes = document.getElementById('ksc-result-bytes');
            const kscResultHex = document.getElementById('ksc-result-hex');
            let kscInputTargetField = null;  // 입력기 결과를 적용할 대상 필드

            // ESC 키로 입력기 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && kscInputModal.classList.contains('show')) {
                    kscInputModal.classList.remove('show');
                }
            });

            // 입력기 모달 배경 클릭 시 닫기
            kscInputModal.addEventListener('click', function(e) {
                if (e.target === kscInputModal) {
                    kscInputModal.classList.remove('show');
                }
            });

            // 입력기 닫기 버튼
            kscInputCloseBtn.addEventListener('click', function() {
                kscInputModal.classList.remove('show');
            });

            // 입력기 텍스트 변경 시 실시간 변환
            kscInputText.addEventListener('input', function() {
                updateKSCInputResult();
            });

            // 변환 모드 변경 시 재계산
            document.querySelectorAll('input[name="ksc-input-mode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    updateKSCInputResult();
                });
            });

            /**
             * KSC-5601 입력기 결과 업데이트
             */
            function updateKSCInputResult() {
                const text = kscInputText.value;
                const mode = document.querySelector('input[name="ksc-input-mode"]:checked').value;
                
                if (!text) {
                    kscResultFullwidth.textContent = '-';
                    kscResultBytes.textContent = '0 bytes';
                    kscResultHex.textContent = '-';
                    return;
                }

                try {
                    let encodedBytes;
                    let displayText;
                    
                    if (mode === 'fullwidth') {
                        // 전각 모드: 모든 문자를 2바이트로 변환
                        encodedBytes = KSC5601.encode(text);
                        // 전각 문자로 표시 (유니코드 전각 문자)
                        displayText = convertToFullwidthDisplay(text);
                    } else {
                        // 혼용 모드: 한글 2바이트, ASCII 1바이트
                        encodedBytes = encodeKSCMixedToBytes(text);
                        displayText = text;  // 혼용은 원본 그대로 표시
                    }
                    
                    // 결과 표시
                    kscResultFullwidth.textContent = displayText || text;
                    kscResultBytes.textContent = encodedBytes.length + ' bytes';
                    
                    // HEX 표시
                    const hexStr = Array.from(encodedBytes)
                        .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                        .join(' ');
                    kscResultHex.textContent = hexStr || '-';
                    
                    // 바이트 데이터 저장 (복사/적용용)
                    kscInputModal.encodedBytes = encodedBytes;
                } catch (e) {
                    console.error('KSC 변환 오류:', e);
                    kscResultFullwidth.textContent = '변환 오류';
                    kscResultBytes.textContent = '-';
                    kscResultHex.textContent = '-';
                }
            }

            /**
             * 텍스트를 유니코드 전각 문자로 변환 (표시용)
             */
            function convertToFullwidthDisplay(text) {
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    const code = text.charCodeAt(i);
                    
                    // 반각 공백 → 전각 공백
                    if (code === 0x20) {
                        result += '\u3000';
                    }
                    // 반각 숫자 (0-9) → 전각 숫자
                    else if (code >= 0x30 && code <= 0x39) {
                        result += String.fromCharCode(code - 0x30 + 0xFF10);
                    }
                    // 반각 대문자 (A-Z) → 전각 대문자
                    else if (code >= 0x41 && code <= 0x5A) {
                        result += String.fromCharCode(code - 0x41 + 0xFF21);
                    }
                    // 반각 소문자 (a-z) → 전각 소문자
                    else if (code >= 0x61 && code <= 0x7A) {
                        result += String.fromCharCode(code - 0x61 + 0xFF41);
                    }
                    // 한글 및 기타는 그대로
                    else {
                        result += text[i];
                    }
                }
                return result;
            }

            /**
             * 혼용 모드 인코딩 (바이트 배열 반환)
             */
            function encodeKSCMixedToBytes(text) {
                const result = [];
                for (let i = 0; i < text.length; i++) {
                    const code = text.charCodeAt(i);
                    
                    // ASCII (0x00-0x7F)
                    if (code < 0x80) {
                        result.push(code);
                    }
                    // 한글 완성형 (가-힣)
                    else if (code >= 0xAC00 && code <= 0xD7A3) {
                        const kscCode = KSC5601.unicodeToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            // 변환 실패 시 '?' 2바이트
                            result.push(0xA3, 0xBF);
                        }
                    }
                    // 기타 멀티바이트
                    else {
                        // 2바이트로 처리 시도
                        const bytes = KSC5601.encode(text[i]);
                        for (let j = 0; j < bytes.length; j++) {
                            result.push(bytes[j]);
                        }
                    }
                }
                return new Uint8Array(result);
            }

            // 바이트 복사 버튼
            document.getElementById('ksc-input-copy').addEventListener('click', function() {
                const encodedBytes = kscInputModal.encodedBytes;
                if (!encodedBytes || encodedBytes.length === 0) {
                    alert('변환된 데이터가 없습니다.');
                    return;
                }
                
                // Latin1 문자열로 변환하여 복사 (바이트 보존)
                let latin1Str = '';
                for (let i = 0; i < encodedBytes.length; i++) {
                    latin1Str += String.fromCharCode(encodedBytes[i]);
                }
                
                navigator.clipboard.writeText(latin1Str).then(function() {
                    alert('✓ 바이트 데이터가 클립보드에 복사되었습니다.\n(' + encodedBytes.length + ' bytes)');
                }).catch(function(err) {
                    console.error('복사 실패:', err);
                    alert('복사에 실패했습니다.');
                });
            });

            // 필드에 적용 버튼
            document.getElementById('ksc-input-apply').addEventListener('click', function() {
                const encodedBytes = kscInputModal.encodedBytes;
                if (!encodedBytes || encodedBytes.length === 0) {
                    alert('변환된 데이터가 없습니다.');
                    return;
                }
                
                if (!kscInputTargetField) {
                    alert('적용할 필드가 선택되지 않았습니다.\n결과 테이블의 🔤 버튼을 클릭하여 입력기를 열어주세요.');
                    return;
                }
                
                // 원본 유니코드 텍스트 (표시용)
                const originalText = kscInputText.value;
                
                // Latin1 문자열로 변환 (바이트 데이터용)
                let latin1Str = '';
                for (let i = 0; i < encodedBytes.length; i++) {
                    latin1Str += String.fromCharCode(encodedBytes[i]);
                }
                
                // 대상 필드에 적용
                // textContent에는 디코딩된 텍스트를 표시 (KSC5601.decode 사용)
                const decodedText = KSC5601.decode(encodedBytes);
                kscInputTargetField.textContent = decodedText;
                // data-raw-value에는 바이트 데이터 저장 (재생성 시 사용)
                kscInputTargetField.setAttribute('data-raw-value', latin1Str);
                // data-original-value도 디코딩된 텍스트로 설정
                kscInputTargetField.setAttribute('data-original-value', decodedText);
                kscInputTargetField.classList.add('modified');
                
                // 전역 데이터 업데이트
                const recIdx = parseInt(kscInputTargetField.getAttribute('data-record-index'));
                const fldIdx = parseInt(kscInputTargetField.getAttribute('data-field-index'));
                if (window.structParsedDataCurrent && 
                    window.structParsedDataCurrent[recIdx] && 
                    window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                    // value는 디코딩된 텍스트 (표시 및 비교용)
                    window.structParsedDataCurrent[recIdx].fields[fldIdx].value = decodedText;
                    // rawValue는 바이트 데이터 (재생성 시 사용)
                    window.structParsedDataCurrent[recIdx].fields[fldIdx].rawValue = latin1Str;
                }
                
                // 바이트 뱃지 업데이트
                const fieldSize = parseInt(kscInputTargetField.getAttribute('data-field-size'));
                const badge = kscInputTargetField.closest('td').querySelector('.byte-info-badge');
                if (badge) {
                    const byteLen = encodedBytes.length;
                    badge.textContent = `${byteLen}/${fieldSize}B`;
                    badge.classList.remove('byte-ok', 'byte-warning', 'byte-error');
                    if (byteLen > fieldSize) {
                        badge.classList.add('byte-error');
                    } else if (byteLen > fieldSize * 0.9) {
                        badge.classList.add('byte-warning');
                    } else {
                        badge.classList.add('byte-ok');
                    }
                }
                
                // 수정 카운터 업데이트
                updateStructModifiedCount();
                
                // 모달 닫기
                kscInputModal.classList.remove('show');
                
                alert('✓ 필드에 적용되었습니다.\n(' + encodedBytes.length + ' bytes)');
            });

            /**
             * KSC-5601 입력기 열기 (외부에서 호출용)
             * @param {HTMLElement} targetField - 적용할 대상 필드 요소
             */
            window.openKSCInputModal = function(targetField) {
                kscInputTargetField = targetField || null;
                kscInputText.value = '';
                updateKSCInputResult();
                kscInputModal.classList.add('show');
                kscInputText.focus();
            };

            // KSC 모달 닫기 버튼
            kscCloseBtn.addEventListener('click', function() {
                kscHelpModal.classList.remove('show');
            });

            // KSC 모달 배경 클릭 시 닫기
            kscHelpModal.addEventListener('click', function(e) {
                if (e.target === kscHelpModal) {
                    kscHelpModal.classList.remove('show');
                }
            });

            // =========================================
            // 전문 생성 폼 이벤트 핸들러
            // =========================================
            
            /**
             * 숫자 필드 여부 확인 헬퍼 함수
             * - cd, code는 자동 판단에서 제외 (사용자 선택에 맡김)
             * @param {string} fieldName - 필드명
             * @returns {boolean} 숫자 필드 여부
             */
            function isNumericField(fieldName) {
                // cd, code는 사용자 판단에 맡기므로 제외
                const numericPatterns = /amt|amount|cnt|count|num|number|price|qty|quantity|seq|no/i;
                return numericPatterns.test(fieldName);
            }
            
            /**
             * cd/code 포함 필드 여부 확인 (사용자 선택 필요 필드)
             * @param {string} fieldName - 필드명
             * @returns {boolean} cd/code 포함 여부
             */
            function isUserChoiceField(fieldName) {
                return /cd|code/i.test(fieldName);
            }
            
            /**
             * 필드 입력 행 생성 함수
             * @param {Object} field - 필드 정의 객체
             * @param {number} index - 필드 인덱스
             * @param {boolean} recognizeCRLF - CRLF 인식 여부
             * @param {string} encodingMode - 인코딩 모드 ('fullwidth' 또는 'mixed')
             * @returns {HTMLTableRowElement} 테이블 행 요소
             */
            function createFieldRow(field, index, recognizeCRLF, encodingMode) {
                const tr = document.createElement('tr');
                
                // CRLF 필드 특수 처리
                const isCRLFField = field.name.toLowerCase().match(/crlf|cr_lf|newline|eol/);
                
                if (isCRLFField && recognizeCRLF) {
                    // 자동 설정 필드
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            <span class="field-tag auto-tag">자동</span>
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text" 
                                   class="field-input auto-field generate-field-input"
                                   value="\\r\\n"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   id="gen-field-${index}"
                                   disabled
                                   readonly />
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}">\\r\\n</code>
                        </td>
                    `;
                    return tr;
                }
                
                // KSC-5601 필드 처리
                if (field.isKSC) {
                    const maxChars = encodingMode === 'fullwidth' 
                        ? Math.floor(field.size / 2)
                        : '가변';
                    
                    const placeholderText = encodingMode === 'fullwidth' 
                        ? '최대 ' + maxChars + '자'
                        : '최대 ' + field.size + ' bytes';
                    
                    const charCounterHtml = encodingMode === 'fullwidth'
                        ? '<span class="current-chars">0</span>/' + maxChars + '자 (<span class="current-bytes">0</span>/' + field.size + 'B)'
                        : '<span class="current-bytes">0</span>/' + field.size + 'B (<span class="current-chars">0</span>자)';
                    
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            <span class="field-tag ksc-tag">KSC-5601</span>
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text"
                                   class="field-input generate-field-input ksc-field-input"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   data-ksc="true"
                                   data-encoding-mode="${encodingMode}"
                                   id="gen-field-${index}"
                                   placeholder="${placeholderText}" />
                            <div class="input-meta">
                                <span class="char-counter" id="char-counter-${index}">
                                    ${charCounterHtml}
                                </span>
                            </div>
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}"></code>
                        </td>
                    `;
                    
                    // KSC 필드 입력 이벤트 바인딩
                    setTimeout(function() {
                        const input = document.getElementById('gen-field-' + index);
                        const counterEl = document.getElementById('char-counter-' + index);
                        const previewEl = document.getElementById('preview-field-' + index);
                        
                        if (input) {
                            input.addEventListener('input', function() {
                                const value = this.value;
                                const size = parseInt(this.dataset.fieldSize);
                                const mode = this.dataset.encodingMode;
                                
                                // 바이트 수 계산
                                let byteCount = 0;
                                if (mode === 'fullwidth') {
                                    byteCount = value.length * 2;
                                } else {
                                    // 혼용 모드: 한글 2바이트, ASCII 1바이트
                                    for (let i = 0; i < value.length; i++) {
                                        byteCount += value.charCodeAt(i) > 127 ? 2 : 1;
                                    }
                                }
                                
                                // 카운터 업데이트
                                const charsSpan = counterEl.querySelector('.current-chars');
                                const bytesSpan = counterEl.querySelector('.current-bytes');
                                if (charsSpan) charsSpan.textContent = value.length;
                                if (bytesSpan) bytesSpan.textContent = byteCount;
                                
                                // 바이트 초과 시 경고
                                if (byteCount > size) {
                                    counterEl.classList.add('over-limit');
                                    input.classList.add('over-limit');
                                } else {
                                    counterEl.classList.remove('over-limit');
                                    input.classList.remove('over-limit');
                                }
                                
                                // 미리보기 업데이트
                                if (previewEl) {
                                    previewEl.textContent = value || '';
                                }
                            });
                        }
                    }, 0);
                    
                    return tr;
                }
                
                // 일반 입력 필드
                    const isNumeric = isNumericField(field.name);
                    const isUserChoice = isUserChoiceField(field.name);
                    
                    // 숫자 태그 HTML 생성 (cd/code 필드는 토글 가능)
                    let numericTagHtml = '';
                    if (isNumeric) {
                        numericTagHtml = '<span class="field-tag numeric-tag">숫자</span>';
                    } else if (isUserChoice) {
                        // cd/code 필드: 사용자 선택 토글 추가
                        numericTagHtml = `
                            <label class="type-toggle-label" title="체크하면 숫자 필드로 처리 (좌측 0 패딩)">
                                <input type="checkbox" 
                                       class="type-toggle-checkbox" 
                                       id="type-toggle-${index}"
                                       data-field-index="${index}" />
                                <span class="type-toggle-text">숫자</span>
                            </label>
                        `;
                    }
                    
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            ${numericTagHtml}
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text"
                                   class="field-input generate-field-input"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   data-is-numeric="${isNumeric}"
                                   data-is-user-choice="${isUserChoice}"
                                   id="gen-field-${index}"
                                   maxlength="${field.size}"
                                   placeholder="최대 ${field.size}자"
                                   ${isNumeric ? 'inputmode="numeric"' : ''} />
                            <div class="input-meta">
                                <span class="char-counter">
                                    <span class="current-length" id="char-count-${index}">0</span>/${field.size}
                                </span>
                            </div>
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}"></code>
                        </td>
                    `;
                    
                    // 입력 이벤트 바인딩을 위해 setTimeout 사용 (DOM에 추가된 후 실행)
                    setTimeout(function() {
                        const input = document.getElementById('gen-field-' + index);
                        const charCountEl = document.getElementById('char-count-' + index);
                        const previewEl = document.getElementById('preview-field-' + index);
                        const typeToggle = document.getElementById('type-toggle-' + index);
                        
                        if (input) {
                            input.addEventListener('input', function() {
                                const value = this.value;
                                const size = parseInt(this.dataset.fieldSize);
                                
                                // 글자 수 카운터 업데이트
                                if (charCountEl) {
                                    charCountEl.textContent = value.length;
                                }
                                
                                // 미리보기 업데이트
                                if (previewEl) {
                                    previewEl.classList.remove('filled', 'padded', 'over');
                                    
                                    if (value.length === 0) {
                                        previewEl.textContent = '';
                                    } else if (value.length < size) {
                                        // 패딩 표시 - 숫자 필드는 0, 문자 필드는 공백
                                        const isNumericNow = input.dataset.isNumeric === 'true' || 
                                                           (typeToggle && typeToggle.checked);
                                        const padChar = isNumericNow ? '0' : '░';
                                        const padded = isNumericNow ? 
                                                      padChar.repeat(size - value.length) + value :
                                                      value + padChar.repeat(size - value.length);
                                        previewEl.textContent = padded;
                                        previewEl.classList.add('padded');
                                    } else if (value.length === size) {
                                        previewEl.textContent = value;
                                        previewEl.classList.add('filled');
                                    } else {
                                        // 초과
                                        previewEl.textContent = value + ' (초과!)';
                                        previewEl.classList.add('over');
                                    }
                                }
                            });
                        }
                        
                        // 타입 토글 체크박스 이벤트 (cd/code 필드용)
                        if (typeToggle && input) {
                            typeToggle.addEventListener('change', function() {
                                // inputmode 변경
                                if (this.checked) {
                                    input.setAttribute('inputmode', 'numeric');
                                } else {
                                    input.removeAttribute('inputmode');
                                }
                                // 미리보기 즉시 업데이트
                                input.dispatchEvent(new Event('input'));
                            });
                        }
                    }, 0);
                
                return tr;
            }
            
            /**
             * 폼 이벤트 리스너 연결 함수
             * 현재 선택된 구조체 정보를 클로저로 캡처합니다.
             * @param {Object} structDef - 구조체 정의 객체
             */
            function attachFormEvents(structDef) {
                // 미리보기 버튼
                const previewBtn = document.getElementById('preview-telegram-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', function() {
                        const inputs = document.querySelectorAll('.field-input');
                        let telegram = '';
                        const errors = [];
                        
                        // 각 필드 값 수집 및 패딩
                        inputs.forEach(function(input, index) {
                            const fieldName = input.dataset.field;
                            const fieldSize = parseInt(input.dataset.size);
                            let value = input.value;
                            
                            // CRLF 필드 처리
                            if (input.disabled) {
                                value = '\r\n';
                            }
                            
                            // 필수 필드 검증 (구분값)
                            if (fieldName && fieldName.toLowerCase().match(/kubun|type|구분/) && !value && !input.disabled) {
                                errors.push('"' + fieldName + '" 필드는 필수입니다');
                            }
                            
                            // 패딩 적용
                            const paddedValue = padValue(value, fieldSize, fieldName);
                            telegram += paddedValue;
                        });
                        
                        // 미리보기 박스 표시
                        const previewBox = document.getElementById('telegram-preview-box');
                        
                        if (errors.length > 0) {
                            previewBox.innerHTML = 
                                '<div class="preview-error">' +
                                '  <h5>⚠️ 입력 오류</h5>' +
                                '  <ul>' +
                                errors.map(function(err) { return '<li>' + err + '</li>'; }).join('') +
                                '  </ul>' +
                                '</div>';
                        } else {
                            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                            const escapedTelegram = escapeHtml(telegram);
                            
                            previewBox.innerHTML = 
                                '<div class="preview-success">' +
                                '  <div class="preview-header">' +
                                '    <h5>👁️ 생성된 전문 미리보기</h5>' +
                                '    <button class="copy-preview-btn" data-telegram="' + escapedTelegram + '">' +
                                '      📋 복사' +
                                '    </button>' +
                                '  </div>' +
                                '  <div class="preview-content">' +
                                '    <pre class="telegram-display">' + escapeForDisplay(telegram) + '</pre>' +
                                '  </div>' +
                                '  <div class="preview-info">' +
                                '    <div class="info-item">' +
                                '      <span class="info-label">길이:</span>' +
                                '      <span class="info-value">' + telegram.length + ' bytes</span>' +
                                '    </div>' +
                                '    <div class="info-item">' +
                                '      <span class="info-label">HEX:</span>' +
                                '      <span class="info-value hex-value">' + toHexPreview(telegram) + '</span>' +
                                '    </div>' +
                                (recognizeCRLF ? 
                                '    <div class="info-item">' +
                                '      <span class="info-label">CRLF:</span>' +
                                '      <span class="info-value">포함 (2 bytes)</span>' +
                                '    </div>' : '') +
                                '  </div>' +
                                '</div>';
                        }
                        
                        previewBox.style.display = 'block';
                    });
                }
                
                // 레코드 추가 버튼 - 이제 이벤트 위임 방식으로 document에서 처리
                // (아래 document.addEventListener 참조)
                
                // 초기화 버튼 - 이제 이벤트 위임 방식으로 document에서 처리
                // (아래 document.addEventListener 참조)
                
                // 실시간 입력 처리 (이벤트 위임)
                const formContainer = document.getElementById('generate-form-container');
                if (formContainer) {
                    formContainer.addEventListener('input', function(e) {
                        if (e.target.classList.contains('field-input') && !e.target.disabled) {
                            const input = e.target;
                            const fieldName = input.dataset.field;
                            const fieldSize = parseInt(input.dataset.size);
                            const value = input.value;
                            const isKSC = input.dataset.ksc === 'true';
                            
                            // KSC-5601 필드 처리
                            if (isKSC) {
                                const encodingMode = input.dataset.encodingMode;
                                const row = input.closest('tr');
                                const currentCharsSpan = row.querySelector('.current-chars');
                                const currentBytesSpan = row.querySelector('.current-bytes');
                                const previewCell = row.querySelector('.preview-text');
                                
                                if (encodingMode === 'fullwidth') {
                                    // 전각 전용: 글자수 × 2 = 바이트
                                    const charCount = value.length;
                                    const byteCount = charCount * 2;
                                    const maxChars = Math.floor(fieldSize / 2);
                                    
                                    if (currentCharsSpan) currentCharsSpan.textContent = charCount;
                                    if (currentBytesSpan) currentBytesSpan.textContent = byteCount;
                                    
                                    if (charCount > maxChars) {
                                        input.style.borderColor = '#dc3545';
                                        input.style.backgroundColor = '#fff5f5';
                                        if (currentCharsSpan) currentCharsSpan.style.color = '#dc3545';
                                    } else if (charCount === maxChars) {
                                        input.style.borderColor = '#28a745';
                                        input.style.backgroundColor = '#f0fff4';
                                        if (currentCharsSpan) currentCharsSpan.style.color = '#28a745';
                                    } else {
                                        input.style.borderColor = '#ced4da';
                                        input.style.backgroundColor = '#fff';
                                        if (currentCharsSpan) currentCharsSpan.style.color = '#6c757d';
                                    }
                                    
                                    // 미리보기
                                    if (previewCell) {
                                        const paddedValue = padKSC5601Fullwidth(value, fieldSize);
                                        previewCell.textContent = paddedValue;
                                    }
                                    
                                } else {
                                    // 혼용 모드
                                    const charCount = value.length;
                                    const byteCount = calculateKSCMixedBytes(value);
                                    
                                    if (currentCharsSpan) currentCharsSpan.textContent = charCount;
                                    if (currentBytesSpan) currentBytesSpan.textContent = byteCount;
                                    
                                    if (byteCount > fieldSize) {
                                        input.style.borderColor = '#dc3545';
                                        input.style.backgroundColor = '#fff5f5';
                                        if (currentBytesSpan) currentBytesSpan.style.color = '#dc3545';
                                    } else if (byteCount === fieldSize) {
                                        input.style.borderColor = '#28a745';
                                        input.style.backgroundColor = '#f0fff4';
                                        if (currentBytesSpan) currentBytesSpan.style.color = '#28a745';
                                    } else {
                                        input.style.borderColor = '#ced4da';
                                        input.style.backgroundColor = '#fff';
                                        if (currentBytesSpan) currentBytesSpan.style.color = '#6c757d';
                                    }
                                    
                                    // 미리보기
                                    if (previewCell) {
                                        const paddedValue = padKSC5601Mixed(value, fieldSize);
                                        previewCell.textContent = paddedValue;
                                    }
                                }
                                
                                return; // KSC 필드는 여기서 처리 완료
                            }
                            
                            // 1. 글자 수 카운터 업데이트 (일반 필드)
                            const row = input.closest('tr');
                            const currentLength = row.querySelector('.current-length');
                            
                            if (currentLength) {
                                currentLength.textContent = value.length;
                                
                                // 색상 변경
                                if (value.length > fieldSize) {
                                    currentLength.style.color = '#dc3545';
                                    input.style.borderColor = '#dc3545';
                                    input.style.backgroundColor = '#fff5f5';
                                } else if (value.length === fieldSize) {
                                    currentLength.style.color = '#28a745';
                                    input.style.borderColor = '#28a745';
                                    input.style.backgroundColor = '#f0fff4';
                                } else {
                                    currentLength.style.color = '#6c757d';
                                    input.style.borderColor = '#ced4da';
                                    input.style.backgroundColor = '#fff';
                                }
                            }
                            
                            // 2. 숫자 필드 검증 (자동 판단 + 사용자 선택 토글 확인)
                            const fieldIndex = input.dataset.index;
                            const typeToggle = document.getElementById('type-toggle-' + fieldIndex);
                            const isAutoNumeric = isNumericField(fieldName);
                            const isUserChoiceNumeric = typeToggle && typeToggle.checked;
                            const shouldValidateNumeric = isAutoNumeric || isUserChoiceNumeric;
                            
                            if (shouldValidateNumeric) {
                                if (value && !/^[0-9]*$/.test(value)) {
                                    input.setCustomValidity('숫자만 입력 가능합니다');
                                    input.style.borderColor = '#ffc107';
                                } else {
                                    input.setCustomValidity('');
                                }
                            } else {
                                input.setCustomValidity('');
                            }
                            
                            // 3. 패딩 미리보기 (숫자: 좌측 0 패딩, 문자: 우측 공백 패딩)
                            let paddedValue;
                            if (value.length >= fieldSize) {
                                paddedValue = value.substring(0, fieldSize);
                            } else if (shouldValidateNumeric) {
                                paddedValue = '0'.repeat(fieldSize - value.length) + value;
                            } else {
                                paddedValue = value + ' '.repeat(fieldSize - value.length);
                            }
                            const previewCell = row.querySelector('.preview-text');
                            if (previewCell) {
                                previewCell.textContent = paddedValue;
                            }
                            
                            // 4. 길이 초과 시 경고 표시 (자동 자르기 대신)
                            // if (value.length > fieldSize) {
                            //     input.value = value.substring(0, fieldSize);
                            // }
                        }
                    });
                }
            }
            
            /**
             * 폼에서 전문 문자열 생성
             * @param {Object} structDef - 구조체 정의 객체
             * @returns {Object} { raw: 실제 전문, display: 표시용 전문 }
             */
            function buildTelegramFromForm(structDef) {
                const inputs = document.querySelectorAll('#form-fields-body .generate-field-input');
                let raw = '';
                let display = '';
                
                inputs.forEach(function(input, idx) {
                    const field = structDef.fields[idx];
                    let value = input.value;
                    
                    // CRLF 필드 처리
                    if (field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                        raw += '\r\n';
                        display += '\\r\\n';
                        return;
                    }
                    
                    // 숫자 필드 여부 판단 (자동 판단 + 사용자 선택 토글)
                    const isNumeric = input.dataset.isNumeric === 'true';
                    const isUserChoice = input.dataset.isUserChoice === 'true';
                    const typeToggle = document.getElementById('type-toggle-' + idx);
                    const useNumericPad = isNumeric || (isUserChoice && typeToggle && typeToggle.checked);
                    
                    // 값 패딩 (숫자: 좌측 0 패딩, 문자: 우측 공백 패딩)
                    if (value.length < field.size) {
                        if (useNumericPad) {
                            value = '0'.repeat(field.size - value.length) + value;
                        } else {
                            value = value + ' '.repeat(field.size - value.length);
                        }
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                    }
                    
                    raw += value;
                    display += value.replace(/ /g, '·');  // 공백을 점으로 표시
                });
                
                return { raw: raw, display: display };
            }
            
            /**
             * 전문 생성 폼 표시 함수
             * @param {Object} structDef - 구조체 정의 객체
             */
            function displayGenerateForm(structDef) {
                // 1. generate-form-container 초기화
                const container = document.getElementById('generate-form-container');
                
                // 2. recognizeCRLF 옵션 확인
                const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                
                // 3. 폼 HTML 생성
                const formHTML = 
                    '<div class="generate-form">' +
                    
                    '  <div class="form-header">' +
                    '    <div class="form-title">' +
                    '      <h4>📝 ' + (structDef.name || '구조체') + ' 입력 폼</h4>' +
                    '      <span class="form-badge">총 ' + structDef.totalSize + ' bytes</span>' +
                    '    </div>' +
                    '    <div class="form-info">' +
                    '      <small>' + structDef.fields.length + '개 필드</small>' +
                    '    </div>' +
                    '  </div>' +
                    
                    '  <table class="input-form-table">' +
                    '    <thead>' +
                    '      <tr>' +
                    '        <th style="width: 25%">필드명</th>' +
                    '        <th style="width: 8%">크기</th>' +
                    '        <th style="width: 42%">입력값</th>' +
                    '        <th style="width: 25%">미리보기</th>' +
                    '      </tr>' +
                    '    </thead>' +
                    '    <tbody id="form-fields-body">' +
                    '    </tbody>' +
                    '  </table>' +
                    
                    '  <div class="form-actions">' +
                    '    <button id="preview-telegram-btn" class="btn-info">' +
                    '      👁️ 미리보기' +
                    '    </button>' +
                    '    <button id="add-to-list-btn" class="btn-success">' +
                    '      ✓ 레코드 추가' +
                    '    </button>' +
                    '    <button id="reset-form-btn" class="btn-secondary">' +
                    '      🔄 초기화' +
                    '    </button>' +
                    '  </div>' +
                    
                    '  <div id="telegram-preview-box" class="preview-box" style="display: none;">' +
                    '  </div>' +
                    
                    '</div>';
                
                // 4. DOM에 추가
                container.innerHTML = formHTML;
                container.style.display = 'block';
                
                // 5. 필드 행 생성
                const tbody = document.getElementById('form-fields-body');
                
                structDef.fields.forEach(function(field, index) {
                    const row = createFieldRow(field, index, recognizeCRLF, structDef.encodingMode);
                    tbody.appendChild(row);
                });
                
                // 6. 이벤트 리스너 연결
                attachFormEvents(structDef);
            }
            
            /**
             * XML 규격 기반 전문 생성 폼 표시 함수
             * @param {Array} xmlSpec - parseXMLSpec의 결과 배열 [{id, type, size}, ...]
             */
            function displayXMLGenerateForm(xmlSpec) {
                // 폼 HTML 생성
                const formHTML = 
                    '<div class="generate-form">' +
                    
                    '  <div class="form-header">' +
                    '    <div class="form-title">' +
                    '      <h4>📝 필드 입력 폼</h4>' +
                    '      <span class="form-badge">' + xmlSpec.length + '개 필드</span>' +
                    '    </div>' +
                    '  </div>' +
                    
                    '  <table class="input-form-table">' +
                    '    <thead>' +
                    '      <tr>' +
                    '        <th style="width: 30%">필드명 (ID)</th>' +
                    '        <th style="width: 10%">타입</th>' +
                    '        <th style="width: 8%">크기</th>' +
                    '        <th style="width: 37%">입력값</th>' +
                    '        <th style="width: 15%">미리보기</th>' +
                    '      </tr>' +
                    '    </thead>' +
                    '    <tbody id="xml-form-fields-body">' +
                    '      <!-- 필드 행 -->' +
                    '    </tbody>' +
                    '  </table>' +
                    
                    '  <div class="form-actions">' +
                    '    <button id="xml-preview-telegram-btn" class="btn-info">' +
                    '      👁️ 미리보기' +
                    '    </button>' +
                    '    <button id="xml-add-to-list-btn" class="btn-success">' +
                    '      ✓ 레코드 추가' +
                    '    </button>' +
                    '    <button id="xml-reset-form-btn" class="btn-secondary">' +
                    '      🔄 초기화' +
                    '    </button>' +
                    '  </div>' +
                    
                    '  <div id="xml-telegram-preview-box" class="preview-box" style="display: none;">' +
                    '    <!-- 미리보기 -->' +
                    '  </div>' +
                    
                    '</div>';
                
                // DOM에 추가
                document.getElementById('xml-generate-form-container').innerHTML = formHTML;
                document.getElementById('xml-generate-form-container').style.display = 'block';
                
                // 필드 행 생성
                const tbody = document.getElementById('xml-form-fields-body');
                
                xmlSpec.forEach(function(field, index) {
                    const tr = document.createElement('tr');
                    const isNumeric = field.type === 'N';
                    const isFull = field.type === 'FULL';
                    
                    // FULL 타입은 바이트 기준이므로 maxlength를 넉넉하게 설정
                    // (한글 1자 = 2바이트이므로 size/2 + 여유분)
                    const maxLength = isFull ? Math.ceil(field.size) : field.size;
                    
                    // placeholder 설정
                    let placeholder = '텍스트 입력';
                    if (isNumeric) {
                        placeholder = '숫자 입력';
                    } else if (isFull) {
                        placeholder = '한글/영문 입력 (KSC-5601 ' + field.size + 'bytes)';
                    }
                    
                    // 단위 표시 (FULL: bytes, 기타: chars)
                    const sizeUnit = isFull ? ' bytes' : '';
                    
                    tr.innerHTML = 
                        '<td>' +
                        '  <span class="field-name">' + field.id + '</span>' +
                        '</td>' +
                        '<td class="field-type-cell">' +
                        '  <span class="type-badge type-' + field.type + '">' + field.type + '</span>' +
                        '</td>' +
                        '<td class="field-size">' + field.size + sizeUnit + '</td>' +
                        '<td>' +
                        '  <input type="text"' +
                        '         class="field-input xml-field-input"' +
                        '         data-field="' + field.id + '"' +
                        '         data-type="' + field.type + '"' +
                        '         data-size="' + field.size + '"' +
                        '         data-index="' + index + '"' +
                        (isFull ? '' : '         maxlength="' + maxLength + '"') +
                        '         placeholder="' + placeholder + '"' +
                        (isNumeric ? '         inputmode="numeric"' : '') +
                        '  />' +
                        '  <div class="input-meta">' +
                        '    <span class="char-counter">' +
                        '      <span class="current-length">0</span>/' + field.size + (isFull ? 'B' : '') +
                        '    </span>' +
                        '  </div>' +
                        '</td>' +
                        '<td class="preview-cell">' +
                        '  <code class="preview-text"></code>' +
                        '</td>';
                    
                    tbody.appendChild(tr);
                });
                
                // 이벤트 리스너 연결
                attachXMLFormEvents(xmlSpec);
            }
            
            /**
             * XML 폼 이벤트 연결 함수
             * @param {Array} xmlSpec - XML 규격 배열
             */
            function attachXMLFormEvents(xmlSpec) {
                // 실시간 입력 처리 (이벤트 위임)
                document.getElementById('xml-generate-form-container').addEventListener('input', function(e) {
                    if (e.target.classList.contains('xml-field-input')) {
                        const input = e.target;
                        const fieldType = input.dataset.type;
                        const fieldSize = parseInt(input.dataset.size);
                        const value = input.value;
                        
                        // 글자 수/바이트 수 카운터
                        const row = input.closest('tr');
                        const currentLength = row.querySelector('.current-length');
                        
                        // FULL 타입은 바이트 수, 그 외는 글자 수
                        const displayLength = fieldType === 'FULL' 
                            ? KSC5601.getByteLength(value) 
                            : value.length;
                        
                        currentLength.textContent = displayLength;
                        
                        if (displayLength > fieldSize) {
                            currentLength.style.color = '#dc3545';
                            input.style.borderColor = '#dc3545';
                        } else if (displayLength === fieldSize) {
                            currentLength.style.color = '#28a745';
                            input.style.borderColor = '#28a745';
                        } else {
                            currentLength.style.color = '#6c757d';
                            input.style.borderColor = '#ced4da';
                        }
                        
                        // 타입 검증
                        if (fieldType === 'N' && value && !/^[0-9]*$/.test(value)) {
                            input.style.borderColor = '#ffc107';
                            input.setCustomValidity('숫자만 입력 가능합니다');
                        } else {
                            input.setCustomValidity('');
                        }
                        
                        // 패딩 미리보기
                        const paddedValue = padValueByType(value, fieldSize, fieldType);
                        const previewCell = row.querySelector('.preview-text');
                        
                        // FULL 타입은 HEX로도 표시
                        if (fieldType === 'FULL') {
                            const hexPreview = Array.from(paddedValue.substring(0, 20))
                                .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                                .join(' ');
                            previewCell.textContent = paddedValue.length > 20 
                                ? hexPreview + '...' 
                                : hexPreview;
                            previewCell.title = '원본: ' + value + '\nKSC-5601 인코딩됨 (' + paddedValue.length + 'bytes)';
                        } else {
                            previewCell.textContent = paddedValue;
                            previewCell.title = '';
                        }
                    }
                });
                
                // 미리보기 버튼
                document.getElementById('xml-preview-telegram-btn').addEventListener('click', function() {
                    const inputs = document.querySelectorAll('.xml-field-input');
                    let telegram = '';
                    let hasFull = false;
                    const fieldPreviews = [];
                    
                    inputs.forEach(function(input) {
                        const fieldId = input.dataset.field;
                        const fieldType = input.dataset.type;
                        const fieldSize = parseInt(input.dataset.size);
                        const value = input.value;
                        
                        const paddedValue = padValueByType(value, fieldSize, fieldType);
                        telegram += paddedValue;
                        
                        if (fieldType === 'FULL') {
                            hasFull = true;
                            // FULL 타입: HEX와 원본 텍스트 저장
                            const hexStr = Array.from(paddedValue)
                                .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                                .join(' ');
                            // KSC-5601 디코딩 시도
                            let decoded = '';
                            try {
                                decoded = KSC5601.decode(paddedValue);
                            } catch(e) {
                                decoded = value;
                            }
                            fieldPreviews.push({
                                id: fieldId,
                                type: 'FULL',
                                original: value,
                                decoded: decoded,
                                hex: hexStr,
                                bytes: paddedValue.length
                            });
                        }
                    });
                    
                    const previewBox = document.getElementById('xml-telegram-preview-box');
                    
                    // 전체 HEX 생성 (한 줄에 16바이트씩)
                    const hexBytes = Array.from(telegram)
                        .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase());
                    let fullHex = '';
                    for (let i = 0; i < hexBytes.length; i += 16) {
                        fullHex += hexBytes.slice(i, i + 16).join(' ') + '\n';
                    }
                    fullHex = fullHex.trim();
                    
                    // FULL 타입 필드 상세 정보 HTML
                    let fullFieldsHtml = '';
                    if (hasFull && fieldPreviews.length > 0) {
                        fullFieldsHtml = 
                            '<div class="full-fields-detail" style="margin-top: 15px; padding: 10px; background: #f0e6ff; border-radius: 6px; border: 1px solid #d4b8ff;">' +
                            '  <h6 style="margin: 0 0 10px 0; color: #6f42c1;">📦 FULL 타입 필드 (KSC-5601 2바이트 완성형)</h6>';
                        
                        fieldPreviews.forEach(function(fp) {
                            fullFieldsHtml += 
                                '<div style="margin-bottom: 8px; font-size: 13px; padding: 8px; background: white; border-radius: 4px;">' +
                                '  <strong style="color: #6f42c1;">' + fp.id + '</strong> (' + fp.bytes + ' bytes)<br>' +
                                '  <span style="color: #666;">입력값:</span> ' + escapeHtml(fp.original || '(비어있음)') + '<br>' +
                                '  <span style="color: #666;">디코딩:</span> <span style="color: #28a745;">' + escapeHtml(fp.decoded) + '</span><br>' +
                                '  <span style="color: #666;">HEX:</span> <code style="font-size: 11px; background: #e9ecef; padding: 2px 4px; word-break: break-all;">' + fp.hex + '</code>' +
                                '</div>';
                        });
                        
                        fullFieldsHtml += '</div>';
                    }
                    
                    // 통데이터 표시 (FULL 타입은 디코딩된 텍스트로 치환)
                    let displayTelegram = telegram;
                    if (hasFull) {
                        // FULL 타입 바이트를 디코딩된 텍스트로 치환하여 표시
                        try {
                            displayTelegram = KSC5601.decode(telegram);
                        } catch(e) {
                            displayTelegram = escapeForDisplay(telegram);
                        }
                    }
                    
                    previewBox.innerHTML = 
                        '<div class="preview-success">' +
                        '  <div class="preview-header">' +
                        '    <h5>👁️ 생성된 전문 미리보기</h5>' +
                        '    <button class="copy-preview-btn" data-telegram="' + escapeHtml(telegram) + '">' +
                        '      📋 복사 (바이너리)' +
                        '    </button>' +
                        '  </div>' +
                        '  <div class="preview-content">' +
                        '    <div style="margin-bottom: 5px;"><strong>📄 통데이터 (디코딩):</strong></div>' +
                        '    <pre class="telegram-display" style="margin-bottom: 15px;">' + escapeHtml(displayTelegram) + '</pre>' +
                        '    <div style="margin-bottom: 5px;"><strong>🔢 HEX 표현:</strong></div>' +
                        '    <pre class="telegram-display" style="word-break: break-all; white-space: pre-wrap; font-size: 11px; background: #f8f9fa; color: #495057;">' + fullHex + '</pre>' +
                        fullFieldsHtml +
                        '  </div>' +
                        '  <div class="preview-info">' +
                        '    <div class="info-item">' +
                        '      <span class="info-label">총 길이:</span>' +
                        '      <span class="info-value">' + telegram.length + ' bytes</span>' +
                        '    </div>' +
                        '  </div>' +
                        '</div>';
                    
                    previewBox.style.display = 'block';
                });
                
                // 레코드 추가 버튼
                document.getElementById('xml-add-to-list-btn').addEventListener('click', function() {
                    const inputs = document.querySelectorAll('.xml-field-input');
                    let telegram = '';
                    const fieldData = [];
                    
                    inputs.forEach(function(input) {
                        const fieldId = input.dataset.field;
                        const fieldType = input.dataset.type;
                        const fieldSize = parseInt(input.dataset.size);
                        const value = input.value;
                        const paddedValue = padValueByType(value, fieldSize, fieldType);
                        
                        telegram += paddedValue;
                        
                        fieldData.push({
                            name: fieldId,
                            type: fieldType,
                            size: fieldSize,
                            value: value,
                            padded: paddedValue
                        });
                    });
                    
                    const record = {
                        id: Date.now(),
                        structName: 'XML 전문',
                        telegram: telegram,
                        fieldData: fieldData,
                        timestamp: new Date().toLocaleString('ko-KR'),
                        length: telegram.length
                    };
                    
                    addXMLRecordToList(record);
                    
                    const shouldReset = confirm('레코드가 추가되었습니다.\n입력 폼을 초기화하시겠습니까?');
                    if (shouldReset) {
                        resetXMLForm();
                    }
                });
                
                // 초기화 버튼
                document.getElementById('xml-reset-form-btn').addEventListener('click', function() {
                    if (confirm('입력한 내용을 모두 초기화하시겠습니까?')) {
                        resetXMLForm();
                    }
                });
            }
            
            /**
             * 타입에 따른 패딩 처리 함수
             * @param {string} value - 입력값
             * @param {number} size - 필드 크기
             * @param {string} type - 필드 타입 (N: 숫자, X: 문자)
             * @returns {string} 패딩된 값
             */
            function padValueByType(value, size, type) {
                // FULL 타입: KSC-5601 2바이트 완성형 코드로 변환 후 패딩
                if (type === 'FULL') {
                    return KSC5601.padToByteSize(value, size);
                }
                
                if (value.length > size) {
                    return value.substring(0, size);
                }
                if (value.length < size) {
                    // N 타입: 좌측 0 패딩
                    if (type === 'N') {
                        return value.padStart(size, '0');
                    }
                    // X 타입: 우측 공백 패딩
                    return value.padEnd(size, ' ');
                }
                return value;
            }
            
            /**
             * XML 폼 초기화 함수
             */
            function resetXMLForm() {
                document.querySelectorAll('.xml-field-input').forEach(function(input) {
                    input.value = '';
                    input.style.borderColor = '#ced4da';
                });
                document.querySelectorAll('.current-length').forEach(function(span) {
                    span.textContent = '0';
                    span.style.color = '#6c757d';
                });
                document.querySelectorAll('.preview-text').forEach(function(code) {
                    code.textContent = '';
                });
                document.getElementById('xml-telegram-preview-box').style.display = 'none';
            }
            
            /**
             * XML 레코드를 목록에 추가 (C 구조체 addRecordToList와 동일한 구조)
             * @param {Object} record - 레코드 객체 (id, structName, telegram, fieldData, timestamp, length)
             */
            function addXMLRecordToList(record) {
                const container = document.getElementById('xml-generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (container.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'records-header';
                    header.innerHTML = `
                        <div class="header-left">
                            <h4>📦 생성된 XML 레코드 목록</h4>
                            <span class="xml-record-count-badge">0개</span>
                        </div>
                        <div class="header-right">
                            <button id="export-xml-records-btn" class="export-btn">
                                💾 전체 내보내기
                            </button>
                            <button id="clear-xml-records-btn" class="clear-btn">
                                🗑️ 전체 삭제
                            </button>
                        </div>
                    `;
                    container.appendChild(header);
                    
                    // 목록 컨테이너 추가
                    const listContainer = document.createElement('div');
                    listContainer.id = 'xml-records-list';
                    listContainer.className = 'records-list';
                    container.appendChild(listContainer);
                    
                    // 전체 내보내기 버튼 이벤트
                    document.getElementById('export-xml-records-btn').addEventListener('click', function() {
                        if (!window.xmlGeneratedRecords || window.xmlGeneratedRecords.length === 0) {
                            showTemporaryMessage('내보낼 레코드가 없습니다.');
                            return;
                        }
                        showXMLExportModal();
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-xml-records-btn').addEventListener('click', function() {
                        const count = window.xmlGeneratedRecords?.length || 0;
                        
                        if (count === 0) {
                            alert('삭제할 레코드가 없습니다');
                            return;
                        }
                        
                        if (confirm(`${count}개의 레코드를 모두 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
                            // 애니메이션과 함께 삭제
                            const recordItems = container.querySelectorAll('.xml-record-item');
                            
                            recordItems.forEach((item, index) => {
                                setTimeout(() => {
                                    item.style.opacity = '0';
                                    item.style.transform = 'translateX(-100%)';
                                }, index * 50);
                            });
                            
                            setTimeout(() => {
                                document.getElementById('xml-generated-records-area').innerHTML = '';
                                window.xmlGeneratedRecords = [];
                                showTemporaryMessage('✓ 모든 레코드가 삭제되었습니다');
                            }, recordItems.length * 50 + 300);
                        }
                    });
                }
                
                // 레코드 카드 생성
                const recordCard = document.createElement('div');
                recordCard.className = 'record-item xml-record-item';
                recordCard.dataset.id = record.id;
                
                const recordIndex = container.querySelectorAll('.xml-record-item').length;
                
                recordCard.innerHTML = `
                    <div class="record-item-header">
                        <div class="record-meta">
                            <span class="xml-record-number">#${recordIndex + 1}</span>
                            <span class="record-struct-name">${record.structName || 'XML 레코드'}</span>
                            <span class="record-timestamp">${record.timestamp}</span>
                        </div>
                        <div class="record-actions">
                            <button class="btn-icon xml-copy-record-btn" 
                                    data-id="${record.id}" 
                                    title="복사">
                                📋
                            </button>
                            <button class="btn-icon xml-view-detail-btn" 
                                    data-id="${record.id}"
                                    title="상세보기">
                                👁️
                            </button>
                            <button class="btn-icon xml-delete-record-btn" 
                                    data-id="${record.id}"
                                    title="삭제">
                                🗑️
                            </button>
                        </div>
                    </div>
                    
                    <div class="record-item-body">
                        <div class="telegram-box">
                            <pre class="telegram-text">${escapeForDisplay(record.telegram)}</pre>
                        </div>
                        <div class="record-stats">
                            <span class="stat-item">
                                <span class="stat-label">길이:</span>
                                <span class="stat-value">${record.length} bytes</span>
                            </span>
                        </div>
                    </div>
                    
                    <div class="xml-record-detail" style="display: none;">
                        <table class="detail-table">
                            <thead>
                                <tr>
                                    <th>필드명</th>
                                    <th>크기</th>
                                    <th>입력값</th>
                                    <th>패딩후</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${record.fieldData ? record.fieldData.map(field => `
                                    <tr>
                                        <td>${field.name}</td>
                                        <td>${field.size}</td>
                                        <td>${field.value || '<비어있음>'}</td>
                                        <td><code>${escapeForDisplay(field.padded)}</code></td>
                                    </tr>
                                `).join('') : ''}
                            </tbody>
                        </table>
                    </div>
                `;
                
                // 목록에 추가 (최신이 위로)
                const listContainer = container.querySelector('#xml-records-list');
                if (listContainer) {
                    if (listContainer.firstChild) {
                        listContainer.insertBefore(recordCard, listContainer.firstChild);
                    } else {
                        listContainer.appendChild(recordCard);
                    }
                }
                
                // 카운트 업데이트
                updateXMLRecordCount();
                
                // 전역 저장소에 추가
                if (!window.xmlGeneratedRecords) {
                    window.xmlGeneratedRecords = [];
                }
                window.xmlGeneratedRecords.unshift(record);
            }
            
            /**
             * XML 기반 전문 생성 함수
             * @param {Array} xmlSpec - XML 규격 배열
             * @returns {Object} {raw: 원본 문자열, display: 표시용 문자열}
             */
            function generateXMLTelegram(xmlSpec) {
                const inputs = document.querySelectorAll('#xml-form-fields-body .xml-field-input');
                let raw = '';
                let display = '';
                
                inputs.forEach(function(input, idx) {
                    const field = xmlSpec[idx];
                    let value = input.value;
                    
                    // 타입에 따른 패딩 처리
                    if (field.type === 'FULL') {
                        // FULL 타입: KSC-5601 인코딩 후 바이트 단위 패딩
                        value = KSC5601.padToByteSize(value, field.size);
                        raw += value;
                        // display용: HEX 표현으로 변환
                        display += '[KSC:' + value.length + 'B]';
                    } else if (value.length < field.size) {
                        if (field.type === 'N') {
                            // 숫자 타입: 왼쪽 0 패딩
                            value = '0'.repeat(field.size - value.length) + value;
                        } else {
                            // 문자 타입: 오른쪽 공백 패딩
                            value = value + ' '.repeat(field.size - value.length);
                        }
                        raw += value;
                        display += value.replace(/ /g, '·');  // 공백을 점으로 표시
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                        raw += value;
                        display += value.replace(/ /g, '·');
                    } else {
                        raw += value;
                        display += value.replace(/ /g, '·');
                    }
                });
                
                return { raw: raw, display: display };
            }
            
            /**
             * XML 생성 폼 초기화 함수
             */
            function resetXMLGenerateForm() {
                const inputs = document.querySelectorAll('#xml-form-fields-body .xml-field-input');
                inputs.forEach(function(input) {
                    input.value = '';
                    
                    const row = input.closest('tr');
                    
                    // 카운터 초기화
                    const charCountEl = row.querySelector('.current-length');
                    if (charCountEl) {
                        charCountEl.textContent = '0';
                    }
                    
                    // 미리보기 초기화
                    const previewEl = row.querySelector('.preview-text');
                    if (previewEl) {
                        previewEl.textContent = '';
                        previewEl.classList.remove('filled', 'padded', 'over');
                    }
                });
                
                // 미리보기 박스 숨기기
                document.getElementById('xml-telegram-preview-box').style.display = 'none';
            }
            
            /**
             * XML 생성된 레코드를 목록에 추가
             * @param {string} record - 생성된 레코드
             */
            function addXMLGeneratedRecord(record) {
                const area = document.getElementById('xml-generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (area.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'generated-records-header';
                    header.innerHTML = 
                        '<h5>📦 생성된 레코드</h5>' +
                        '<div class="header-actions">' +
                        '  <button id="xml-copy-all-records" class="btn-secondary btn-sm">전체 복사</button>' +
                        '  <button id="xml-clear-all-records" class="btn-danger btn-sm">전체 삭제</button>' +
                        '</div>';
                    area.appendChild(header);
                    
                    // 전체 복사 이벤트
                    document.getElementById('xml-copy-all-records').addEventListener('click', function() {
                        const records = area.querySelectorAll('.record-text');
                        let allRecords = '';
                        records.forEach(function(r) {
                            allRecords += r.textContent + '\n';
                        });
                        navigator.clipboard.writeText(allRecords.trim()).then(function() {
                            showTemporaryMessage('전체 레코드가 복사되었습니다.');
                        });
                    });
                    
                    // 전체 삭제 이벤트
                    document.getElementById('xml-clear-all-records').addEventListener('click', function() {
                        if (confirm('모든 생성된 레코드를 삭제하시겠습니까?')) {
                            area.innerHTML = '';
                            showTemporaryMessage('모든 레코드가 삭제되었습니다.');
                        }
                    });
                }
                
                // 레코드 아이템 생성
                const recordItem = document.createElement('div');
                recordItem.className = 'record-item';
                
                const recordIndex = area.querySelectorAll('.record-item').length + 1;
                
                recordItem.innerHTML = 
                    '<div class="record-header">' +
                    '  <span class="record-number">#' + recordIndex + '</span>' +
                    '  <span class="record-size">' + record.length + ' bytes</span>' +
                    '</div>' +
                    '<code class="record-text">' + escapeHtml(record) + '</code>' +
                    '<div class="record-actions">' +
                    '  <button class="xml-copy-record-btn btn-secondary btn-xs">복사</button>' +
                    '  <button class="xml-delete-record-btn btn-danger btn-xs">삭제</button>' +
                    '</div>';
                
                area.appendChild(recordItem);
                
                // 복사 버튼 이벤트
                recordItem.querySelector('.xml-copy-record-btn').addEventListener('click', function() {
                    navigator.clipboard.writeText(record).then(function() {
                        showTemporaryMessage('레코드가 복사되었습니다.');
                    });
                });
                
                // 삭제 버튼 이벤트
                recordItem.querySelector('.xml-delete-record-btn').addEventListener('click', function() {
                    recordItem.remove();
                    showTemporaryMessage('레코드가 삭제되었습니다.');
                    
                    // 모든 레코드가 삭제되면 헤더도 삭제
                    if (area.querySelectorAll('.record-item').length === 0) {
                        area.innerHTML = '';
                    }
                });
            }
            
            /**
             * 레코드 생성 함수
             * @param {Object} struct - 구조체 정의
             */
            function generateRecord(struct) {
                const inputs = document.querySelectorAll('#form-fields-body .generate-field-input');
                let record = '';
                let hasError = false;
                
                inputs.forEach(function(input, idx) {
                    const field = struct.fields[idx];
                    let value = input.value;
                    
                    // CRLF 필드 처리
                    if (field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                        record += '\r\n';
                        return;
                    }
                    
                    // 값 패딩 (오른쪽 공백 채우기)
                    if (value.length < field.size) {
                        value = value + ' '.repeat(field.size - value.length);
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                    }
                    
                    record += value;
                });
                
                if (!hasError) {
                    // 생성된 레코드 표시
                    addGeneratedRecord(record, struct.name);
                    showTemporaryMessage('레코드가 생성되었습니다. (' + record.length + ' bytes)');
                }
            }
            
            /**
             * 생성된 레코드를 목록에 추가
             * @param {string} record - 생성된 레코드
             * @param {string} structName - 구조체 이름
             */
            function addGeneratedRecord(record, structName) {
                const area = document.getElementById('generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (area.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'generated-records-header';
                    header.innerHTML = '<h5>📋 생성된 레코드 목록</h5>' +
                        '<button id="copy-all-records" class="secondary-btn">전체 복사</button>' +
                        '<button id="clear-all-records" class="danger-btn">전체 삭제</button>';
                    area.appendChild(header);
                    
                    // 전체 복사 버튼 이벤트
                    document.getElementById('copy-all-records').addEventListener('click', function() {
                        const records = area.querySelectorAll('.generated-record-content');
                        let allRecords = '';
                        records.forEach(function(r) {
                            allRecords += r.textContent + '\n';
                        });
                        navigator.clipboard.writeText(allRecords.trim()).then(function() {
                            showTemporaryMessage('전체 레코드가 복사되었습니다.');
                        });
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-all-records').addEventListener('click', function() {
                        if (confirm('모든 생성된 레코드를 삭제하시겠습니까?')) {
                            area.innerHTML = '';
                            showTemporaryMessage('모든 레코드가 삭제되었습니다.');
                        }
                    });
                }
                
                // 레코드 아이템 생성
                const item = document.createElement('div');
                item.className = 'generated-record-item';
                
                const info = document.createElement('span');
                info.className = 'record-info';
                info.textContent = structName + ' (' + record.length + ' bytes)';
                
                const content = document.createElement('code');
                content.className = 'generated-record-content';
                content.textContent = record.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.textContent = '복사';
                copyBtn.addEventListener('click', function() {
                    navigator.clipboard.writeText(record).then(function() {
                        showTemporaryMessage('레코드가 복사되었습니다.');
                    });
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-record-btn';
                deleteBtn.textContent = '삭제';
                deleteBtn.addEventListener('click', function() {
                    item.remove();
                    // 레코드가 모두 삭제되면 헤더도 삭제
                    if (area.querySelectorAll('.generated-record-item').length === 0) {
                        area.innerHTML = '';
                    }
                });
                
                item.appendChild(info);
                item.appendChild(content);
                item.appendChild(copyBtn);
                item.appendChild(deleteBtn);
                area.appendChild(item);
            }
            
            /**
             * 레코드를 목록에 추가
             * @param {Object} record - 레코드 객체 (id, structName, telegram, fieldData, timestamp, length)
             */
            function addRecordToList(record) {
                const container = document.getElementById('generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (container.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'records-header';
                    header.innerHTML = `
                        <div class="header-left">
                            <h4>📦 생성된 레코드 목록</h4>
                            <span class="record-count-badge">0개</span>
                        </div>
                        <div class="header-right">
                            <button id="export-all-records-btn" class="export-btn">
                                💾 전체 내보내기
                            </button>
                            <button id="clear-all-records-btn" class="clear-btn">
                                🗑️ 전체 삭제
                            </button>
                        </div>
                    `;
                    container.appendChild(header);
                    
                    // 목록 컨테이너 추가
                    const listContainer = document.createElement('div');
                    listContainer.id = 'records-list';
                    listContainer.className = 'records-list';
                    container.appendChild(listContainer);
                    
                    // 전체 내보내기 버튼 이벤트
                    document.getElementById('export-all-records-btn').addEventListener('click', function() {
                        if (!window.generatedRecords || window.generatedRecords.length === 0) {
                            showTemporaryMessage('내보낼 레코드가 없습니다.');
                            return;
                        }
                        showExportModal();
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-all-records-btn').addEventListener('click', function() {
                        const count = window.generatedRecords?.length || 0;
                        
                        if (count === 0) {
                            alert('삭제할 레코드가 없습니다');
                            return;
                        }
                        
                        if (confirm(`${count}개의 레코드를 모두 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
                            // 애니메이션과 함께 삭제
                            const recordItems = document.querySelectorAll('.record-item');
                            
                            recordItems.forEach((item, index) => {
                                setTimeout(() => {
                                    item.style.opacity = '0';
                                    item.style.transform = 'translateX(-100%)';
                                }, index * 50);
                            });
                            
                            setTimeout(() => {
                                document.getElementById('generated-records-area').innerHTML = '';
                                window.generatedRecords = [];
                                showTemporaryMessage('✓ 모든 레코드가 삭제되었습니다');
                            }, recordItems.length * 50 + 300);
                        }
                    });
                }
                
                // 레코드 카드 생성
                const recordCard = document.createElement('div');
                recordCard.className = 'record-item';
                recordCard.dataset.id = record.id;
                
                const recordIndex = container.querySelectorAll('.record-item').length;
                
                recordCard.innerHTML = `
                    <div class="record-item-header">
                        <div class="record-meta">
                            <span class="record-number">#${recordIndex + 1}</span>
                            <span class="record-struct-name">${record.structName}</span>
                            <span class="record-timestamp">${record.timestamp}</span>
                        </div>
                        <div class="record-actions">
                            <button class="btn-icon copy-record-btn" 
                                    data-id="${record.id}" 
                                    title="복사">
                                📋
                            </button>
                            <button class="btn-icon view-detail-btn" 
                                    data-id="${record.id}"
                                    title="상세보기">
                                👁️
                            </button>
                            <button class="btn-icon delete-record-btn" 
                                    data-id="${record.id}"
                                    title="삭제">
                                🗑️
                            </button>
                        </div>
                    </div>
                    
                    <div class="record-item-body">
                        <div class="telegram-box">
                            <pre class="telegram-text">${escapeForDisplay(record.telegram)}</pre>
                        </div>
                        <div class="record-stats">
                            <span class="stat-item">
                                <span class="stat-label">길이:</span>
                                <span class="stat-value">${record.length} bytes</span>
                            </span>
                        </div>
                    </div>
                    
                    <div class="record-detail" style="display: none;">
                        <table class="detail-table">
                            <thead>
                                <tr>
                                    <th>필드명</th>
                                    <th>크기</th>
                                    <th>입력값</th>
                                    <th>패딩후</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${record.fieldData.map(field => `
                                    <tr>
                                        <td>${field.name}</td>
                                        <td>${field.size}</td>
                                        <td>${field.value || '<비어있음>'}</td>
                                        <td><code>${escapeForDisplay(field.padded)}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                
                // 목록에 추가 (최신이 위로)
                const listContainer = container.querySelector('#records-list');
                if (listContainer) {
                    if (listContainer.firstChild) {
                        listContainer.insertBefore(recordCard, listContainer.firstChild);
                    } else {
                        listContainer.appendChild(recordCard);
                    }
                }
                
                // 카운트 업데이트
                updateRecordCount();
                
                // 전역 저장소에 추가
                if (!window.generatedRecords) {
                    window.generatedRecords = [];
                }
                window.generatedRecords.unshift(record);
            }
            
            // =========================================
            // 레코드 카드 이벤트 (이벤트 위임)
            // =========================================
            document.addEventListener('click', function(e) {
              
              // 복사 버튼
              if (e.target.classList.contains('copy-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                const record = window.generatedRecords.find(r => r.id === recordId)
                
                if (record) {
                  navigator.clipboard.writeText(record.telegram).then(() => {
                    const originalText = e.target.textContent
                    e.target.textContent = '✓'
                    e.target.style.backgroundColor = 'rgba(40,167,69,0.3)'
                    
                    setTimeout(() => {
                      e.target.textContent = originalText
                      e.target.style.backgroundColor = ''
                    }, 2000)
                  }).catch(err => {
                    alert('복사 실패: ' + err.message)
                  })
                }
              }
              
              // 상세보기 토글
              if (e.target.classList.contains('view-detail-btn')) {
                const recordId = e.target.dataset.id
                const recordCard = document.querySelector(`.record-item[data-id="${recordId}"]`)
                const detailDiv = recordCard.querySelector('.record-detail')
                
                if (detailDiv.style.display === 'none') {
                  detailDiv.style.display = 'block'
                  e.target.textContent = '🔼'
                  e.target.title = '상세닫기'
                } else {
                  detailDiv.style.display = 'none'
                  e.target.textContent = '👁️'
                  e.target.title = '상세보기'
                }
              }
              
              // 삭제 버튼
              if (e.target.classList.contains('delete-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                
                if (confirm('이 레코드를 삭제하시겠습니까?')) {
                  // DOM에서 제거
                  const recordCard = document.querySelector(`.record-item[data-id="${recordId}"]`)
                  recordCard.style.opacity = '0'
                  recordCard.style.transform = 'translateX(-100%)'
                  
                  setTimeout(() => {
                    recordCard.remove()
                    
                    // 배열에서 제거
                    const index = window.generatedRecords.findIndex(r => r.id === recordId)
                    if (index > -1) {
                      window.generatedRecords.splice(index, 1)
                    }
                    
                    // 카운트 업데이트
                    updateRecordCount()
                    
                    // 번호 재정렬
                    reindexRecords()
                    
                    // 목록이 비었으면 헤더도 제거
                    if (window.generatedRecords.length === 0) {
                      document.getElementById('generated-records-area').innerHTML = ''
                    }
                  }, 300)
                }
              }
              
              // =========================================
              // XML 레코드 카드 이벤트 (이벤트 위임)
              // =========================================
              
              // XML 복사 버튼
              if (e.target.classList.contains('xml-copy-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                const record = window.xmlGeneratedRecords?.find(r => r.id === recordId)
                
                if (record) {
                  navigator.clipboard.writeText(record.telegram).then(() => {
                    const originalText = e.target.textContent
                    e.target.textContent = '✓'
                    e.target.style.backgroundColor = 'rgba(40,167,69,0.3)'
                    
                    setTimeout(() => {
                      e.target.textContent = originalText
                      e.target.style.backgroundColor = ''
                    }, 2000)
                  }).catch(err => {
                    alert('복사 실패: ' + err.message)
                  })
                }
              }
              
              // XML 상세보기 토글
              if (e.target.classList.contains('xml-view-detail-btn')) {
                const recordId = e.target.dataset.id
                const recordCard = document.querySelector(`.xml-record-item[data-id="${recordId}"]`)
                const detailDiv = recordCard.querySelector('.xml-record-detail')
                
                if (detailDiv.style.display === 'none') {
                  detailDiv.style.display = 'block'
                  e.target.textContent = '🔼'
                  e.target.title = '상세닫기'
                } else {
                  detailDiv.style.display = 'none'
                  e.target.textContent = '👁️'
                  e.target.title = '상세보기'
                }
              }
              
              // XML 삭제 버튼
              if (e.target.classList.contains('xml-delete-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                
                if (confirm('이 레코드를 삭제하시겠습니까?')) {
                  // DOM에서 제거
                  const recordCard = document.querySelector(`.xml-record-item[data-id="${recordId}"]`)
                  recordCard.style.opacity = '0'
                  recordCard.style.transform = 'translateX(-100%)'
                  
                  setTimeout(() => {
                    recordCard.remove()
                    
                    // 배열에서 제거
                    const index = window.xmlGeneratedRecords?.findIndex(r => r.id === recordId)
                    if (index > -1) {
                      window.xmlGeneratedRecords.splice(index, 1)
                    }
                    
                    // 카운트 업데이트
                    updateXMLRecordCount()
                    
                    // 번호 재정렬
                    reindexXMLRecords()
                    
                    // 목록이 비었으면 헤더도 제거
                    if (!window.xmlGeneratedRecords || window.xmlGeneratedRecords.length === 0) {
                      document.getElementById('xml-generated-records-area').innerHTML = ''
                    }
                  }, 300)
                }
              }
            })
            
            function updateRecordCount() {
              const badge = document.querySelector('.record-count-badge')
              if (badge) {
                const count = document.querySelectorAll('.record-item').length
                badge.textContent = `${count}개`
              }
            }

            function reindexRecords() {
              document.querySelectorAll('.record-item').forEach((card, index) => {
                const numberSpan = card.querySelector('.record-number')
                numberSpan.textContent = `#${index + 1}`
              })
            }
            
            // =========================================
            // XML 레코드 목록 관련 함수들
            // =========================================
            
            /**
             * XML 레코드 카운트 업데이트
             */
            function updateXMLRecordCount() {
              const badge = document.querySelector('.xml-record-count-badge')
              if (badge) {
                const count = document.querySelectorAll('.xml-record-item').length
                badge.textContent = `${count}개`
              }
            }
            
            /**
             * XML 레코드 번호 재정렬
             */
            function reindexXMLRecords() {
              document.querySelectorAll('.xml-record-item').forEach((card, index) => {
                const numberSpan = card.querySelector('.xml-record-number')
                if (numberSpan) {
                  numberSpan.textContent = `#${index + 1}`
                }
              })
            }
            
            // =========================================
            // 전체 내보내기 모달 관련 함수들
            // =========================================
            
            /**
             * 전체 내보내기 모달 표시
             */
            function showExportModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-container">
                        <div class="modal-header">
                            <h3>💾 전체 내보내기</h3>
                            <button class="modal-close-btn">✕</button>
                        </div>
                        
                        <div class="modal-body">
                            <p class="modal-description">
                                총 <strong>${window.generatedRecords.length}개</strong>의 레코드를 내보냅니다
                            </p>
                            
                            <div class="export-format-select">
                                <label>내보내기 형식</label>
                                <div class="format-options">
                                    <label class="format-option selected">
                                        <input type="radio" name="export-format" value="continuous" checked>
                                        <span class="option-text">
                                            <strong>연속 데이터</strong>
                                            <small>모든 레코드를 줄바꿈 없이 연결</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="export-format" value="lines">
                                        <span class="option-text">
                                            <strong>줄바꿈 구분</strong>
                                            <small>각 레코드를 줄바꿈으로 구분</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="export-format" value="hex">
                                        <span class="option-text">
                                            <strong>HEX 형식</strong>
                                            <small>16진수로 변환하여 표시</small>
                                        </span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="export-preview">
                                <label>미리보기</label>
                                <textarea id="export-preview-area" readonly rows="12"></textarea>
                                <div class="preview-stats">
                                    <span id="export-total-bytes">0 bytes</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-footer">
                            <button id="download-export-btn" class="btn-primary">
                                ⬇️ 파일 다운로드
                            </button>
                            <button id="copy-export-btn" class="btn-secondary">
                                📋 클립보드 복사
                            </button>
                            <button class="modal-close-btn btn-cancel">
                                취소
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 포맷 옵션 선택 스타일 처리
                modal.querySelectorAll('.format-option').forEach(option => {
                    option.addEventListener('click', function() {
                        modal.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        this.querySelector('input[type="radio"]').checked = true;
                        updateExportPreview();
                    });
                });
                
                // 포맷 변경 시 미리보기 업데이트
                modal.querySelectorAll('input[name="export-format"]').forEach(radio => {
                    radio.addEventListener('change', updateExportPreview);
                });
                
                // 초기 미리보기
                updateExportPreview();
                
                // 닫기 버튼들
                modal.querySelectorAll('.modal-close-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.remove();
                    });
                });
                
                // 오버레이 클릭으로 닫기
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // 다운로드
                modal.querySelector('#download-export-btn').addEventListener('click', () => {
                    const format = modal.querySelector('input[name="export-format"]:checked').value;
                    const data = generateExportData(format);
                    const filename = `telegrams_${new Date().getTime()}.txt`;
                    downloadFile(data, filename);
                });
                
                // 복사
                modal.querySelector('#copy-export-btn').addEventListener('click', () => {
                    const textarea = modal.querySelector('#export-preview-area');
                    textarea.select();
                    document.execCommand('copy');
                    
                    const btn = modal.querySelector('#copy-export-btn');
                    const originalText = btn.textContent;
                    btn.textContent = '✓ 복사됨';
                    btn.style.backgroundColor = '#1e7e34';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                });
            }
            
            /**
             * 내보내기 미리보기 업데이트
             */
            function updateExportPreview() {
                const format = document.querySelector('input[name="export-format"]:checked').value;
                const data = generateExportData(format);
                
                document.getElementById('export-preview-area').value = data;
                document.getElementById('export-total-bytes').textContent = `${data.length} bytes`;
            }
            
            /**
             * 내보내기 데이터 생성
             */
            function generateExportData(format) {
                const records = window.generatedRecords.slice().reverse(); // 원래 순서로
                const telegrams = records.map(r => r.telegram);
                
                switch(format) {
                    case 'continuous':
                        return telegrams.join('');
                        
                    case 'lines':
                        return telegrams.join('\n');
                        
                    case 'hex':
                        return telegrams.map((t, i) => {
                            const hex = toHexString(t);
                            return `레코드 #${i+1}:\n${hex}`;
                        }).join('\n\n');
                        
                    default:
                        return telegrams.join('');
                }
            }
            
            /**
             * 문자열을 HEX 문자열로 변환
             */
            function toHexString(str) {
                return Array.from(str)
                    .map((c, i) => {
                        const hex = c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                        return (i > 0 && i % 16 === 0) ? '\n' + hex : hex;
                    })
                    .join(' ');
            }
            
            /**
             * 파일 다운로드
             */
            function downloadFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // =========================================
            // XML 전체 내보내기 모달 관련 함수들
            // =========================================
            
            /**
             * XML 전체 내보내기 모달 표시
             */
            function showXMLExportModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-container">
                        <div class="modal-header">
                            <h3>💾 XML 레코드 전체 내보내기</h3>
                            <button class="modal-close-btn">✕</button>
                        </div>
                        
                        <div class="modal-body">
                            <p class="modal-description">
                                총 <strong>${window.xmlGeneratedRecords.length}개</strong>의 XML 레코드를 내보냅니다
                            </p>
                            
                            <div class="export-format-select">
                                <label>내보내기 형식</label>
                                <div class="format-options">
                                    <label class="format-option selected">
                                        <input type="radio" name="xml-export-format" value="continuous" checked>
                                        <span class="option-text">
                                            <strong>연속 데이터</strong>
                                            <small>모든 레코드를 줄바꿈 없이 연결</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="xml-export-format" value="lines">
                                        <span class="option-text">
                                            <strong>줄바꿈 구분</strong>
                                            <small>각 레코드를 줄바꿈으로 구분</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="xml-export-format" value="hex">
                                        <span class="option-text">
                                            <strong>HEX 형식</strong>
                                            <small>16진수로 변환하여 표시</small>
                                        </span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="export-preview">
                                <label>미리보기</label>
                                <textarea id="xml-export-preview-area" readonly rows="12"></textarea>
                                <div class="preview-stats">
                                    <span id="xml-export-total-bytes">0 bytes</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-footer">
                            <button id="xml-download-export-btn" class="btn-primary">
                                ⬇️ 파일 다운로드
                            </button>
                            <button id="xml-copy-export-btn" class="btn-secondary">
                                📋 클립보드 복사
                            </button>
                            <button class="modal-close-btn btn-cancel">
                                취소
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 포맷 옵션 선택 스타일 처리
                modal.querySelectorAll('.format-option').forEach(option => {
                    option.addEventListener('click', function() {
                        modal.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        this.querySelector('input[type="radio"]').checked = true;
                        updateXMLExportPreview();
                    });
                });
                
                // 포맷 변경 시 미리보기 업데이트
                modal.querySelectorAll('input[name="xml-export-format"]').forEach(radio => {
                    radio.addEventListener('change', updateXMLExportPreview);
                });
                
                // 초기 미리보기
                updateXMLExportPreview();
                
                // 닫기 버튼들
                modal.querySelectorAll('.modal-close-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.remove();
                    });
                });
                
                // 오버레이 클릭으로 닫기
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // 다운로드
                modal.querySelector('#xml-download-export-btn').addEventListener('click', () => {
                    const format = modal.querySelector('input[name="xml-export-format"]:checked').value;
                    const data = generateXMLExportData(format);
                    const filename = `xml_telegrams_${new Date().getTime()}.txt`;
                    downloadFile(data, filename);
                });
                
                // 복사
                modal.querySelector('#xml-copy-export-btn').addEventListener('click', () => {
                    const textarea = modal.querySelector('#xml-export-preview-area');
                    textarea.select();
                    document.execCommand('copy');
                    
                    const btn = modal.querySelector('#xml-copy-export-btn');
                    const originalText = btn.textContent;
                    btn.textContent = '✓ 복사됨';
                    btn.style.backgroundColor = '#1e7e34';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                });
            }
            
            /**
             * XML 내보내기 미리보기 업데이트
             */
            function updateXMLExportPreview() {
                const format = document.querySelector('input[name="xml-export-format"]:checked').value;
                const data = generateXMLExportData(format);
                
                document.getElementById('xml-export-preview-area').value = data;
                document.getElementById('xml-export-total-bytes').textContent = `${data.length} bytes`;
            }
            
            /**
             * XML 내보내기 데이터 생성
             */
            function generateXMLExportData(format) {
                const records = window.xmlGeneratedRecords.slice().reverse(); // 원래 순서로
                const telegrams = records.map(r => r.telegram);
                
                switch(format) {
                    case 'continuous':
                        return telegrams.join('');
                    case 'lines':
                        return telegrams.join('\n');
                    case 'hex':
                        return telegrams.map(t => {
                            return Array.from(t).map(c => {
                                return c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                            }).join(' ');
                        }).join('\n');
                    default:
                        return telegrams.join('');
                }
            }
            
            /**
             * 생성 폼 초기화
             */
            function resetGenerateForm() {
                // 비활성화되지 않은 입력 필드만 초기화
                document.querySelectorAll('.field-input:not(:disabled)').forEach(function(input) {
                    input.value = '';
                    input.style.borderColor = '#ced4da';
                    input.style.backgroundColor = '#fff';
                });
                
                // 카운터 초기화
                document.querySelectorAll('.current-length').forEach(function(span) {
                    span.textContent = '0';
                    span.style.color = '#6c757d';
                });
                
                // 미리보기 초기화
                document.querySelectorAll('.preview-text').forEach(function(code) {
                    const row = code.closest('tr');
                    if (row && !row.querySelector('.auto-field')) {
                        code.textContent = '';
                    }
                });
                
                // 미리보기 박스 숨김
                const previewBox = document.getElementById('telegram-preview-box');
                if (previewBox) {
                    previewBox.style.display = 'none';
                }
                
                // 첫 입력 필드로 포커스
                const firstInput = document.querySelector('.field-input:not(:disabled)');
                if (firstInput) firstInput.focus();
            }
            
            /**
             * 레코드 수 반환
             */
            function getRecordCount() {
                return document.querySelectorAll('.record-item').length;
            }
            
            // add-to-list-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'add-to-list-btn') {
                    // 1. 폼 검증
                    const inputs = document.querySelectorAll('.field-input');
                    let telegram = '';
                    const fieldData = [];
                    let hasError = false;
                    
                    inputs.forEach(function(input) {
                        const fieldName = input.dataset.field;
                        const fieldSize = parseInt(input.dataset.size);
                        let value = input.disabled ? '\r\n' : input.value;
                        
                        // 필수 필드 체크
                        if (fieldName && fieldName.toLowerCase().match(/kubun|type/) && !value && !input.disabled) {
                            hasError = true;
                            input.style.borderColor = '#dc3545';
                            input.focus();
                            return;
                        }
                        
                        const paddedValue = padValue(value, fieldSize, fieldName);
                        telegram += paddedValue;
                        
                        fieldData.push({
                            name: fieldName,
                            size: fieldSize,
                            value: value,
                            padded: paddedValue
                        });
                    });
                    
                    if (hasError) {
                        alert('필수 필드를 입력하세요');
                        return;
                    }
                    
                    // 2. 레코드 객체 생성
                    const select = document.getElementById('generate-struct-select');
                    const structName = select.options[select.selectedIndex].text.split('(')[0].trim();
                    
                    const record = {
                        id: Date.now(),
                        structName: structName,
                        telegram: telegram,
                        fieldData: fieldData,
                        timestamp: new Date().toLocaleString('ko-KR'),
                        length: telegram.length
                    };
                    
                    // 3. 목록에 추가
                    addRecordToList(record);
                    
                    // 4. 폼 초기화 옵션
                    const shouldReset = confirm(
                        '레코드가 추가되었습니다.\n\n' +
                        '입력 폼을 초기화하시겠습니까?\n' +
                        '(아니오를 선택하면 같은 값으로 계속 추가할 수 있습니다)'
                    );
                    
                    if (shouldReset) {
                        resetGenerateForm();
                    }
                    
                    // 5. 성공 메시지
                    showTemporaryMessage('✓ 레코드 #' + getRecordCount() + '가 추가되었습니다');
                    
                    // 6. 레코드 영역으로 스크롤
                    document.getElementById('generated-records-area').scrollIntoView({ 
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            });
            
            // reset-form-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'reset-form-btn') {
                    if (confirm('입력한 내용을 모두 초기화하시겠습니까?')) {
                        resetGenerateForm();
                    }
                }
            });
            
            // load-generate-form-btn 클릭 이벤트
            document.getElementById('load-generate-form-btn').addEventListener('click', function() {
                // 1. 구조체 정의 수집
                const structDefs = collectStructDefinitions();
                
                if (!structDefs || structDefs.length === 0) {
                    alert('구조체를 먼저 정의하세요.');
                    return;
                }
                
                // 2. select 옵션 채우기
                const select = document.getElementById('generate-struct-select');
                select.innerHTML = '<option value="">구조체를 선택하세요</option>';
                
                structDefs.forEach(function(struct, index) {
                    const option = document.createElement('option');
                    option.value = index;
                    
                    // 구조체 정보 표시
                    const structInfo = (struct.name || ('구조체' + (index + 1))) + ' (' + struct.totalSize + ' bytes';
                    const fieldInfo = ', ' + struct.fields.length + '개 필드)';
                    option.textContent = structInfo + fieldInfo;
                    
                    select.appendChild(option);
                });
                
                // 3. select 활성화
                select.disabled = false;
                
                // 4. 구조체 선택 이벤트 (기존 이벤트 제거 후 추가)
                const newSelect = select.cloneNode(true);
                select.parentNode.replaceChild(newSelect, select);
                
                newSelect.addEventListener('change', function() {
                    const selectedIndex = parseInt(this.value);
                    
                    if (isNaN(selectedIndex)) {
                        document.getElementById('generate-form-container').style.display = 'none';
                        return;
                    }
                    
                    const selectedStruct = structDefs[selectedIndex];
                    displayGenerateForm(selectedStruct);
                });
                
                // 버튼 비활성화 (한 번만 로드)
                this.disabled = true;
                this.textContent = '✓ 로드 완료';
                
                showTemporaryMessage('구조체 목록을 불러왔습니다. 생성할 구조체를 선택하세요.');
            });
            
            // load-xml-form-btn 클릭 이벤트 (XML 규격 기반 폼 로드)
            document.getElementById('load-xml-form-btn').addEventListener('click', function() {
                const xmlText = document.getElementById('xml-generate-spec').value.trim();
                
                if (!xmlText) {
                    alert('XML 규격을 먼저 입력하세요');
                    return;
                }
                
                // XML 파싱
                const xmlSpec = parseXMLSpec(xmlText);
                
                if (!xmlSpec || xmlSpec.length === 0) {
                    alert('XML 파싱에 실패했습니다. 형식을 확인하세요');
                    return;
                }
                
                // 폼 표시
                displayXMLGenerateForm(xmlSpec);
                
                // 버튼 비활성화
                this.disabled = true;
                this.textContent = '✓ 로드 완료';
                
                showTemporaryMessage('✓ ' + xmlSpec.length + '개 필드가 로드되었습니다');
            });
            
            // XML 규격 textarea 변경 시 로드 버튼 초기화
            document.getElementById('xml-generate-spec').addEventListener('input', function() {
                const loadBtn = document.getElementById('load-xml-form-btn');
                if (loadBtn && loadBtn.disabled) {
                    loadBtn.disabled = false;
                    loadBtn.textContent = '폼 불러오기';
                    
                    // 폼 컨테이너 숨기기
                    document.getElementById('xml-generate-form-container').style.display = 'none';
                }
            });
            
            // 구조체 카드 추가/삭제 시 폼 로드 버튼 초기화
            // MutationObserver 사용 (DOMNodeInserted는 deprecated)
            const structObserver = new MutationObserver(function(mutations) {
                const loadBtn = document.getElementById('load-generate-form-btn');
                if (loadBtn && loadBtn.disabled) {
                    loadBtn.disabled = false;
                    loadBtn.textContent = '폼 불러오기';
                }
            });
            
            const structDefsContainer = document.getElementById('struct-definitions-container');
            if (structDefsContainer) {
                structObserver.observe(structDefsContainer, { childList: true, subtree: true });
            }
            
            // 초기 로드 버튼 활성화 확인
            setTimeout(function() {
                const loadBtn = document.getElementById('load-generate-form-btn');
                const cards = document.querySelectorAll('.struct-card');
                if (loadBtn && cards.length > 0) {
                    loadBtn.disabled = false;
                }
            }, 100);
        });
    </script>
</body>
</html>
