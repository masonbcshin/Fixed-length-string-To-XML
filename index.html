<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>통전문 파서</title>
    <style>
        /**
         * =====================================================
         * 통전문 파서 스타일시트
         * =====================================================
         * 주요 기능:
         * 1. XML 파싱 탭 - XML 규격 기반 통전문 파싱
         * 2. C 구조체 파싱 탭 - C 구조체 기반 파싱
         * 
         * UX 기능:
         * - 구조체 카드 접기/펼치기 (▼ ↔ ▶)
         * - 드래그 앤 드롭 카드 재정렬
         * - 로컬 스토리지 자동 저장/복원
         * - 다크모드 지원
         * - 키보드 단축키 (Ctrl+Enter, Ctrl+N)
         * =====================================================
         */

        /* =====================================================
         * 기본 레이아웃 스타일
         * ===================================================== */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        /* 입력 영역 */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
            color: #333;
            background: white;
        }

        textarea::placeholder {
            color: #999;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
            color: #333;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* =====================================================
         * 결과 표시 영역
         * ===================================================== */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* 테이블 스타일 */
        #result-table, .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td,
        .result-table th, .result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th, .result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even),
        .result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover,
        .result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7),
        .result-table td:last-child {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* 반응형 테이블 래퍼 */
        .table-wrapper {
            overflow-x: auto;
        }

        /* 버튼 그룹 */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #struct-test-btn {
            background: #17a2b8;
            margin-right: 10px;
        }

        #struct-test-btn:hover {
            background: #138496;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* 에러 메시지 스타일 */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* 파싱 에러 스타일 */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* =====================================================
         * 탭 네비게이션 스타일
         * ===================================================== */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            color: #333;
            font-size: 15px;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            background: #e0e0e0;
            color: #007bff;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 구조체 결과 그룹 스타일 */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* 구조체 요약 정보 스타일 */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* 복사 버튼 스타일 */
        .copy-result-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .copy-result-btn:hover {
            background: #1e7e34;
        }

        /* =====================================================
         * 도움말 섹션 (접기/펼치기)
         * ===================================================== */
        .help-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .help-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-toggle:hover {
            background: #dee2e6;
        }

        .help-toggle-icon {
            transition: transform 0.3s ease;
        }

        .help-toggle.expanded .help-toggle-icon {
            transform: rotate(180deg);
        }

        .help-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .help-content.expanded {
            padding: 16px;
            max-height: 500px;
        }

        .help-content h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .help-content p {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        .help-content ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }

        .help-content li {
            margin: 5px 0;
            color: #666;
            font-size: 13px;
        }

        .help-content code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .help-content pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin: 10px 0;
        }

        /* 테스트 버튼 스타일 */
        #run-tests-btn {
            background: #6f42c1;
            margin-left: auto;
        }

        #run-tests-btn:hover {
            background: #5a32a3;
        }

        /* 테스트 결과 스타일 */
        .test-results {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .test-results.success {
            background: #d4edda;
            border: 1px solid #28a745;
        }

        .test-results.failure {
            background: #f8d7da;
            border: 1px solid #dc3545;
        }

        .test-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-pass {
            color: #28a745;
        }

        .test-fail {
            color: #dc3545;
        }

        /* 섹션 헤더 스타일 */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        .header-options {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .option-checkbox {
            background: #e7f3ff;
            padding: 8px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #004085;
        }

        .option-checkbox:hover {
            background: #cce5ff;
        }

        .option-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .option-description {
            background: #f8f9fa;
            padding: 10px 15px;
            border-left: 4px solid #6c757d;
            margin-bottom: 15px;
            color: #495057;
        }

        .option-description small {
            font-size: 13px;
            line-height: 1.6;
        }

        /* =====================================================
         * 서브 탭 네비게이션 (파싱/생성 모드)
         * ===================================================== */
        .sub-tab-nav {
            display: flex;
            gap: 10px;
            margin-top: 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
        }

        .sub-tab-btn {
            padding: 12px 24px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s;
            color: #495057;
        }

        .sub-tab-btn:hover {
            background: #e9ecef;
            color: #007bff;
        }

        .sub-tab-btn.active {
            background: white;
            border-bottom: 3px solid white;
            font-weight: bold;
            color: #007bff;
            position: relative;
            bottom: -2px;
        }

        .sub-mode-content {
            display: none;
            padding: 20px 0;
        }

        .sub-mode-content.active {
            display: block;
        }

        /* =====================================================
         * 전문 생성 모드 스타일
         * ===================================================== */
        .generate-intro {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .generate-intro h4 {
            margin: 0 0 8px 0;
            font-size: 20px;
        }

        .generate-intro p {
            margin: 0;
            opacity: 0.95;
            font-size: 14px;
        }

        .struct-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 25px;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }

        .struct-selector label {
            font-weight: bold;
            min-width: 140px;
            color: #495057;
        }

        .form-select {
            flex: 1;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .form-select:focus {
            border-color: #007bff;
            outline: none;
        }

        .primary-btn {
            padding: 10px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .primary-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .primary-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .secondary-btn {
            padding: 10px 24px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .secondary-btn:hover {
            background: #5a6268;
        }

        .danger-btn {
            padding: 10px 24px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .danger-btn:hover {
            background: #c82333;
        }

        /* =====================================================
         * 전문 생성 폼 스타일
         * ===================================================== */
        .generate-form-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .generate-form-header h5 {
            margin: 0;
            font-size: 16px;
        }

        .generate-form-header .struct-info {
            font-size: 13px;
            opacity: 0.9;
        }

        .generate-fields-form {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .generate-field-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .generate-field-row:last-child {
            margin-bottom: 0;
        }

        .generate-field-row label {
            min-width: 180px;
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }

        .generate-field-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        .generate-field-input:focus {
            border-color: #17a2b8;
            outline: none;
        }

        .generate-field-input:disabled {
            background: #e9ecef;
            color: #6c757d;
        }

        .field-counter {
            min-width: 60px;
            text-align: right;
            font-size: 12px;
            color: #6c757d;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .field-counter.over {
            color: #dc3545;
            font-weight: bold;
        }

        .generate-form-actions {
            display: flex;
            gap: 12px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }

        /* 생성된 레코드 목록 스타일 */
        #generated-records-area {
            margin-top: 25px;
        }

        .generated-records-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: #28a745;
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .generated-records-header h5 {
            margin: 0;
            flex: 1;
        }

        .generated-records-header button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .generated-record-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
        }

        .generated-record-item:last-child {
            border-radius: 0 0 8px 8px;
        }

        .record-info {
            min-width: 150px;
            font-weight: 500;
            color: #495057;
            font-size: 13px;
        }

        .generated-record-content {
            flex: 1;
            padding: 8px 12px;
            background: #f1f3f4;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            word-break: break-all;
            color: #212529;
        }

        .copy-record-btn {
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .copy-record-btn:hover {
            background: #0056b3;
        }

        .delete-record-btn {
            padding: 6px 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-record-btn:hover {
            background: #c82333;
        }

        /* 레코드 아이템 개선 스타일 */
        .record-item {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
        }

        .record-item .record-info {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .record-number {
            display: inline-block;
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .record-struct-name {
            font-weight: 600;
            color: #212529;
        }

        .record-length {
            color: #6c757d;
            font-size: 12px;
        }

        .record-timestamp {
            color: #adb5bd;
            font-size: 11px;
        }

        .record-telegram {
            flex: 1;
            min-width: 200px;
        }

        .record-btn-group {
            display: flex;
            gap: 6px;
        }

        .toggle-details-btn {
            padding: 6px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .toggle-details-btn:hover {
            background: #5a6268;
        }

        .record-field-details {
            width: 100%;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #dee2e6;
        }

        .field-details-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .field-details-table th,
        .field-details-table td {
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            text-align: left;
        }

        .field-details-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .field-details-table td code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }

        /* =====================================================
         * 생성된 레코드 목록 (새 디자인)
         * ===================================================== */
        .records-header {
            background: #f8f9fa;
            padding: 20px;
            border: 2px solid #dee2e6;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-left h4 {
            margin: 0;
            color: #495057;
        }

        .record-count-badge {
            background: #007bff;
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .header-right {
            display: flex;
            gap: 10px;
        }

        .export-btn,
        .clear-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .export-btn {
            background: #28a745;
            color: white;
        }

        .export-btn:hover {
            background: #218838;
        }

        .clear-btn {
            background: #dc3545;
            color: white;
        }

        .clear-btn:hover {
            background: #c82333;
        }

        .records-list {
            background: #fff;
            border: 2px solid #dee2e6;
            border-top: none;
            padding: 15px;
            max-height: 600px;
            overflow-y: auto;
        }

        #generated-records-area .record-item {
            display: block;
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: all 0.2s;
            padding: 0;
        }

        #generated-records-area .record-item:hover {
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
            transform: translateY(-2px);
        }

        .record-item-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .record-meta {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #generated-records-area .record-item .record-number {
            background: rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 15px;
            color: white;
        }

        #generated-records-area .record-item .record-struct-name {
            font-weight: bold;
            font-size: 16px;
            color: white;
        }

        #generated-records-area .record-item .record-timestamp {
            opacity: 0.9;
            font-size: 13px;
            color: white;
        }

        .record-actions {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .record-item-body {
            padding: 20px;
        }

        .telegram-box {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }

        .telegram-text {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #495057;
            overflow-x: auto;
            white-space: pre;
        }

        .record-stats {
            margin-top: 12px;
            display: flex;
            gap: 20px;
        }

        .stat-item {
            font-size: 14px;
        }

        .stat-label {
            color: #6c757d;
            margin-left: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #495057;
        }

        .record-detail {
            padding: 20px;
            background: #f0f8ff;
            border-top: 2px solid #007bff;
        }

        .detail-table {
            width: 100%;
            border-collapse: collapse;
        }

        .detail-table th,
        .detail-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .detail-table th {
            background: #e7f3ff;
            font-weight: bold;
        }

        .detail-table code {
            background: #fff;
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            font-family: monospace;
        }

        /* =====================================================
         * 전문 생성 폼 (새 디자인)
         * ===================================================== */
        .generate-form {
            background: white;
            border: 2px solid #007bff;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .form-header {
            background: #e7f3ff;
            padding: 20px;
            border-bottom: 2px solid #007bff;
        }

        .form-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .form-title h4 {
            margin: 0;
            color: #004085;
        }

        .form-badge {
            background: #007bff;
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
        }

        .form-info {
            margin-top: 8px;
            color: #004085;
            opacity: 0.8;
        }

        .input-form-table {
            width: 100%;
            border-collapse: collapse;
        }

        .input-form-table th {
            background: #f8f9fa;
            padding: 14px;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #dee2e6;
        }

        .input-form-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }

        .input-form-table .field-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            box-sizing: border-box;
        }

        .input-form-table .field-input:focus {
            border-color: #007bff;
            outline: none;
        }

        .input-form-table .field-input:disabled {
            background: #e9ecef;
            color: #6c757d;
        }

        .input-form-table .field-preview {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: #6c757d;
            word-break: break-all;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .input-form-table .field-preview.filled {
            color: #28a745;
            font-weight: 500;
        }

        .input-form-table .field-preview.padded {
            color: #007bff;
        }

        .input-form-table .field-preview.over {
            color: #dc3545;
            font-weight: bold;
        }

        /* =====================================================
         * 필드 행 스타일 (createFieldRow)
         * ===================================================== */
        .field-name {
            font-weight: bold;
            color: #495057;
        }

        .field-tag {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
            font-weight: bold;
        }

        .auto-tag {
            background: #6c757d;
            color: white;
        }

        .numeric-tag {
            background: #ffc107;
            color: #000;
        }

        /* cd/code 필드용 타입 토글 스타일 */
        .type-toggle-label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            background: #e9ecef;
            color: #6c757d;
            border: 1px solid #ced4da;
            margin-left: 6px;
            transition: all 0.2s ease;
            user-select: none;
        }

        .type-toggle-label:hover {
            background: #dee2e6;
            border-color: #adb5bd;
        }

        .type-toggle-checkbox {
            width: 14px;
            height: 14px;
            margin: 0;
            cursor: pointer;
            accent-color: #ffc107;
        }

        .type-toggle-checkbox:checked + .type-toggle-text {
            color: #856404;
            font-weight: bold;
        }

        .type-toggle-label:has(.type-toggle-checkbox:checked) {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .type-toggle-text {
            font-weight: normal;
            transition: all 0.2s ease;
        }

        /* 다크모드 타입 토글 */
        body.dark-mode .type-toggle-label {
            background: #374151;
            color: #9ca3af;
            border-color: #4b5563;
        }

        body.dark-mode .type-toggle-label:hover {
            background: #4b5563;
            border-color: #6b7280;
        }

        body.dark-mode .type-toggle-label:has(.type-toggle-checkbox:checked) {
            background: #78350f;
            border-color: #ffc107;
            color: #fcd34d;
        }

        body.dark-mode .type-toggle-checkbox:checked + .type-toggle-text {
            color: #fcd34d;
        }

        .type-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .type-badge.numeric-type {
            background: #ffc107;
            color: #000;
        }

        .type-badge.string-type {
            background: #17a2b8;
            color: white;
        }

        .type-badge.type-X {
            background: #17a2b8;
            color: white;
        }

        .type-badge.type-N {
            background: #ffc107;
            color: #000;
        }

        .type-badge.type-A {
            background: #28a745;
            color: white;
        }

        .type-badge.type-FULL {
            background: #6f42c1;
            color: white;
        }

        .field-type-cell {
            text-align: center;
        }

        .field-size {
            color: #6c757d;
            text-align: center;
        }

        .input-form-table .field-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            transition: border 0.2s;
            box-sizing: border-box;
        }

        .input-form-table .field-input:focus {
            border-color: #007bff;
            outline: none;
            background: #f0f8ff;
        }

        .input-form-table .field-input.auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        .input-meta {
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
        }

        .char-counter {
            font-size: 12px;
            color: #6c757d;
        }

        .current-length {
            font-weight: bold;
        }

        .preview-cell {
            background: #f8f9fa;
        }

        .preview-text {
            display: block;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #495057;
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            overflow-x: auto;
            white-space: pre;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            padding: 20px;
            background: #f8f9fa;
        }

        .form-actions .btn-info {
            background: #17a2b8;
            flex: 1;
        }

        .form-actions .btn-info:hover {
            background: #138496;
        }

        .form-actions .btn-success {
            background: #28a745;
            flex: 1;
        }

        .form-actions .btn-success:hover {
            background: #218838;
        }

        .form-actions .btn-secondary {
            background: #6c757d;
            flex: 1;
        }

        .form-actions .btn-secondary:hover {
            background: #5a6268;
        }

        .form-actions button {
            padding: 12px;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .form-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .preview-box {
            margin-top: 20px;
            border-top: 3px solid #17a2b8;
        }

        .preview-box h5 {
            margin: 0 0 15px 0;
            color: #495057;
        }

        .preview-box .telegram-preview-content {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            word-break: break-all;
            white-space: pre-wrap;
        }

        .preview-box .preview-info {
            margin-top: 10px;
            font-size: 13px;
            color: #6c757d;
        }

        .preview-success {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 20px;
        }

        .preview-error h5 {
            margin: 0 0 12px 0;
            color: #721c24;
        }

        .preview-error ul {
            margin: 0;
            padding-left: 20px;
            color: #721c24;
        }

        .preview-header {
            background: #17a2b8;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h5 {
            margin: 0;
            color: white;
        }

        .copy-preview-btn {
            background: white;
            color: #17a2b8;
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-preview-btn:hover {
            background: #f8f9fa;
            transform: translateY(-1px);
        }

        .preview-content {
            padding: 20px;
        }

        .telegram-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #0c5460;
            white-space: pre;
            margin: 0;
            overflow-x: auto;
        }

        .preview-info {
            background: #bee5eb;
            padding: 15px 20px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .preview-info .info-item {
            display: flex;
            gap: 8px;
        }

        .preview-info .info-label {
            font-weight: bold;
            color: #0c5460;
        }

        .preview-info .info-value {
            color: #0c5460;
        }

        .preview-info .hex-value {
            font-family: monospace;
            font-size: 13px;
        }

        /* =====================================================
         * 구조체 정의 영역
         * ===================================================== */
        #add-struct-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #add-struct-btn:hover {
            background: #138496;
        }

        /* 구조체 정의 컨테이너 스타일 */
        #struct-definitions-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* 구조체 카드 스타일 */
        .struct-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        /* 드래그 앤 드롭 스타일 */
        .struct-card[draggable="true"] {
            cursor: grab;
        }

        .struct-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .struct-card.drag-over {
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        .struct-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .struct-card-header:hover {
            background: rgba(0, 0, 0, 0.02);
            margin: -5px -5px 10px -5px;
            padding: 5px 5px 15px 5px;
            border-radius: 5px 5px 0 0;
        }

        .struct-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapse-icon {
            font-size: 12px;
            color: #6c757d;
            transition: transform 0.3s ease;
            width: 16px;
            text-align: center;
        }

        .struct-card.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .struct-number {
            font-weight: bold;
            color: #495057;
            font-size: 16px;
        }

        /* 접힌 상태의 구조체명 미리보기 */
        .struct-preview {
            font-size: 14px;
            color: #6c757d;
            margin-left: 10px;
            font-style: italic;
        }

        .struct-card-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drag-handle {
            cursor: grab;
            color: #adb5bd;
            font-size: 18px;
            padding: 4px 8px;
        }

        .drag-handle:hover {
            color: #6c757d;
        }

        .remove-struct-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .remove-struct-btn:hover {
            background: #c82333;
        }

        /* 카드 본문 접기/펼치기 */
        .struct-card-body {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 1;
        }

        .struct-card.collapsed .struct-card-body {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .struct-card-body .input-row {
            margin-bottom: 12px;
        }

        .struct-card-body .input-row label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .struct-card-body .input-row input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .struct-card-body .input-row small {
            color: #6c757d;
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }

        .struct-card-body .input-row textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* 로컬 스토리지 복원 알림 스타일 */
        .restore-notification {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .restore-notification-text {
            color: #1565c0;
            font-size: 14px;
        }

        .restore-notification-actions {
            display: flex;
            gap: 10px;
        }

        .restore-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .restore-btn.primary {
            background: #1976d2;
            color: white;
        }

        .restore-btn.primary:hover {
            background: #1565c0;
        }

        .restore-btn.secondary {
            background: #e0e0e0;
            color: #424242;
        }

        .restore-btn.secondary:hover {
            background: #bdbdbd;
        }

        /* 단축키 힌트 스타일 */
        .shortcut-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-left: 5px;
        }

        /* 버튼 외부에서 사용될 때 */
        label .shortcut-hint,
        span:not([class]) .shortcut-hint {
            color: #6c757d;
        }

        /* 다크모드 토글 버튼 */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: #e0e0e0;
        }

        /* 파싱 설정 정보 스타일 */
        .parse-settings-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .parse-settings-info h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 15px;
        }

        .setting-item {
            display: flex;
            margin-bottom: 8px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-weight: bold;
            width: 150px;
        }

        .setting-value {
            padding: 4px 10px;
            border-radius: 4px;
        }

        .setting-value.enabled {
            background: #d4edda;
            color: #155724;
        }

        .setting-value.disabled {
            background: #f8d7da;
            color: #721c24;
        }

        .setting-value.mode-line-by-line {
            background: #d1ecf1;
            color: #0c5460;
        }

        .setting-value.mode-continuous {
            background: #d4edda;
            color: #155724;
        }

        /* 파싱 통계 스타일 */
        .parse-stats {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .parse-stats h3 {
            margin: 0 0 12px 0;
            color: #1565c0;
            font-size: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stats-grid > div {
            background: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }

        /* 에러 레코드 카드 스타일 */
        .error-record-card {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .error-record-card .error-header {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            font-weight: bold;
            align-items: center;
        }

        .error-record-card .error-icon {
            font-size: 24px;
        }

        .error-record-card .error-title {
            color: #856404;
            font-size: 16px;
        }

        .error-record-card .error-body .error-message {
            color: #856404;
            margin: 0 0 10px 0;
        }

        .error-record-card .error-data {
            background: #fff;
            padding: 10px;
            border: 1px solid #ffc107;
            font-family: monospace;
            overflow-x: auto;
            border-radius: 4px;
            margin: 0 0 10px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .error-record-card .error-info {
            color: #856404;
            font-size: 12px;
        }

        /* 레코드 헤더 스타일 */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        /* 구분값 배지 스타일 */
        .kubun-badge {
            background: #6610f2;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }

        /* 길이 검증 뱃지 스타일 */
        .length-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
        }

        .length-badge.success {
            background: #d4edda;
            color: #155724;
        }

        .length-badge.warning {
            background: #fff3cd;
            color: #856404;
        }

        .length-badge.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* 레코드 복사 버튼 스타일 */
        .copy-record-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .copy-record-btn:hover {
            background: #1e7e34;
        }

        /* 자동 설정 필드 스타일 (CRLF 등) */
        .auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        /* CRLF 필드 값 표시 스타일 */
        .crlf-value {
            background: #e3f2fd !important;
            font-family: 'Courier New', monospace;
            color: #1565c0;
            font-weight: bold;
        }

        /* 신규 레코드 폼 필드 입력 스타일 */
        .new-field-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .new-field-input:focus {
            border-color: #80bdff;
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        /* 미리보기 셀 스타일 */
        .preview-cell {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            color: #495057;
        }

        /* 모바일 대응 */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .record-header {
                flex-wrap: wrap;
                gap: 8px;
            }

            .theme-toggle {
                top: 10px;
                right: 10px;
                width: 35px;
                height: 35px;
            }
        }

        /* =====================================================
         * 다크모드 스타일
         * ===================================================== */
        body.dark-mode {
            background-color: #1a1a2e;
            color: #e0e0e0;
        }

        body.dark-mode h1 {
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn:hover {
            background: #3d3d5c;
            color: #64b5f6;
        }

        body.dark-mode .tab-btn.active {
            background: #1a1a2e;
            border-bottom-color: #1a1a2e;
            color: #64b5f6;
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"] {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode textarea::placeholder,
        body.dark-mode input::placeholder {
            color: #888;
        }

        body.dark-mode .struct-card {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .struct-number {
            color: #e0e0e0;
        }

        body.dark-mode .struct-preview {
            color: #aaa;
        }

        body.dark-mode .struct-card-body .input-row label {
            color: #e0e0e0;
        }

        body.dark-mode .struct-card-body .input-row small {
            color: #aaa;
        }

        body.dark-mode .help-section {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .help-toggle {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .help-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .help-content {
            color: #ccc;
        }

        body.dark-mode .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-content p,
        body.dark-mode .help-content li {
            color: #bbb;
        }

        body.dark-mode .help-content code {
            background: #3d3d5c;
            color: #64b5f6;
        }

        body.dark-mode .help-content pre {
            background: #1a1a2e;
        }

        body.dark-mode #result-table,
        body.dark-mode .result-table {
            border-color: #3d3d5c;
        }

        body.dark-mode #result-table th,
        body.dark-mode .result-table th {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table td,
        body.dark-mode .result-table td {
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table tr:nth-child(even),
        body.dark-mode .result-table tr:nth-child(even) {
            background: #252540;
        }

        body.dark-mode #result-table tr:hover,
        body.dark-mode .result-table tr:hover {
            background: #35355c;
        }

        body.dark-mode #result-table td:nth-child(7),
        body.dark-mode .result-table td:last-child {
            background: #2d2d44;
        }

        body.dark-mode .empty-value {
            background: #4a3030;
        }

        body.dark-mode .struct-result-group {
            border-color: #3d3d5c;
            background: #252540;
        }

        body.dark-mode .struct-result-group h3 {
            color: #e0e0e0;
        }

        body.dark-mode .record-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .record-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .length-badge.success {
            background: #1e4a2b;
            color: #90ee90;
        }

        body.dark-mode .length-badge.warning {
            background: #4a3d1e;
            color: #ffd700;
        }

        body.dark-mode .length-badge.error {
            background: #4a1e1e;
            color: #ff9090;
        }

        body.dark-mode .parse-settings-info {
            background: #2d2d3d;
            border-color: #4a4a5a;
        }

        body.dark-mode .parse-settings-info h4 {
            color: #b0b0c0;
        }

        body.dark-mode .setting-label {
            color: #e0e0e0;
        }

        body.dark-mode .setting-value.enabled {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .setting-value.disabled {
            background: #4a2020;
            color: #f5c6cb;
        }

        body.dark-mode .setting-value.mode-line-by-line {
            background: #1a3a4a;
            color: #8ecae6;
        }

        body.dark-mode .setting-value.mode-continuous {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .parse-stats {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .parse-stats h3 {
            color: #64b5f6;
        }

        body.dark-mode .stats-grid > div {
            background: #1a1a2e;
            color: #e0e0e0;
        }

        /* 다크모드 에러 레코드 카드 스타일 */
        body.dark-mode .error-record-card {
            background: #3d3520;
            border-color: #a68307;
        }

        body.dark-mode .error-record-card .error-title {
            color: #ffc107;
        }

        body.dark-mode .error-record-card .error-body .error-message {
            color: #ffd54f;
        }

        body.dark-mode .error-record-card .error-data {
            background: #2a2a3e;
            border-color: #a68307;
            color: #e0e0e0;
        }

        body.dark-mode .error-record-card .error-info {
            color: #ffd54f;
        }

        body.dark-mode .error-message {
            background: #4a2020;
            border-color: #8b3030;
            color: #ff8a80;
        }

        body.dark-mode .restore-notification {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .restore-notification-text {
            color: #64b5f6;
        }

        body.dark-mode .restore-btn.secondary {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .restore-btn.secondary:hover {
            background: #4d4d6c;
        }

        body.dark-mode .theme-toggle {
            background: #3d3d5c;
            border-color: #4d4d6c;
            color: #e0e0e0;
        }

        body.dark-mode .theme-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .test-results.success {
            background: #1e3a29;
            border-color: #2e8b57;
        }

        body.dark-mode .test-results.failure {
            background: #3a1e1e;
            border-color: #8b2e2e;
        }

        body.dark-mode .test-item {
            border-bottom-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .section-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox {
            background: #1e3a5f;
            border-color: #4a90d9;
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox:hover {
            background: #2a4a6f;
        }

        body.dark-mode .option-description {
            background: #2d2d2d;
            border-left-color: #6c757d;
            color: #b0b0b0;
        }

        /* 다크모드 - 서브 탭 네비게이션 */
        body.dark-mode .sub-tab-nav {
            border-bottom-color: #444;
        }

        body.dark-mode .sub-tab-btn {
            background: #2d2d2d;
            border-color: #444;
            color: #b0b0b0;
        }

        body.dark-mode .sub-tab-btn:hover {
            background: #3d3d3d;
        }

        body.dark-mode .sub-tab-btn.active {
            background: #1e1e1e;
            border-bottom-color: #1e1e1e;
            color: #64b5f6;
        }

        body.dark-mode .drag-handle {
            color: #6c757d;
        }

        body.dark-mode .drag-handle:hover {
            color: #adb5bd;
        }

        body.dark-mode .struct-card.drag-over {
            border-color: #64b5f6;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        /* 다크모드 - 자동 설정 필드 스타일 */
        body.dark-mode .auto-field {
            background: #3d3d5c;
            color: #adb5bd;
        }

        body.dark-mode .new-field-input {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .new-field-input:focus {
            border-color: #64b5f6;
            box-shadow: 0 0 0 0.2rem rgba(100, 181, 246, 0.25);
        }

        body.dark-mode .preview-cell {
            background: #2d2d44;
            color: #adb5bd;
        }

        /* =====================================================
         * 임시 메시지 스타일
         * ===================================================== */
        .temporary-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #17a2b8;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 9999;
            animation: slideIn 0.3s;
        }

        .temporary-message.fade-out {
            opacity: 0;
            transition: opacity 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
            }
            to {
                transform: translateX(0);
            }
        }

        /* =====================================================
         * 도움말 아이콘 및 모달 스타일
         * ===================================================== */
        .help-icon {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 14px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }

        .help-icon:hover {
            background: #138496;
        }

        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 10000;
        }

        .help-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal .help-content {
            background: white;
            width: 600px;
            max-width: 90%;
            max-height: 80vh;
            padding: 30px;
            border-radius: 8px;
            overflow-y: auto;
            position: relative;
        }

        .help-modal .help-content h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        }

        .help-modal .help-content h4 {
            margin-top: 15px;
            margin-bottom: 10px;
            color: #444;
        }

        .help-modal .close-help {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal .close-help:hover {
            background: #5a6268;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .help-section li {
            margin-bottom: 5px;
            line-height: 1.5;
        }

        .help-section code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .help-example {
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            white-space: pre-wrap;
            margin-top: 10px;
            overflow-x: auto;
        }

        .help-tip {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin-top: 20px;
            border-radius: 0 4px 4px 0;
        }

        .help-tip strong {
            color: #856404;
        }

        /* 다크모드 - 도움말 모달 */
        body.dark-mode .help-modal .help-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .help-modal .help-content h3,
        body.dark-mode .help-modal .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-section code {
            background: #3d3d3d;
            color: #e0e0e0;
        }

        body.dark-mode .help-example {
            background: #1e1e1e;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .help-tip {
            background: #3d3520;
            border-left-color: #ffc107;
            color: #e0e0e0;
        }

        /* 테스트 케이스 모달 */
        .test-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 10000;
        }

        .test-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-modal .test-content {
            background: white;
            width: 400px;
            max-width: 90%;
            padding: 25px;
            border-radius: 8px;
            position: relative;
        }

        .test-modal .test-content h4 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
        }

        .test-modal .close-test {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-modal .close-test:hover {
            background: #5a6268;
        }

        .test-modal .test-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .test-modal .test-buttons button {
            padding: 12px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s;
        }

        .test-modal .test-buttons button[data-case="normal"] {
            background: #28a745;
            color: white;
        }

        .test-modal .test-buttons button[data-case="normal"]:hover {
            background: #1e7e34;
        }

        .test-modal .test-buttons button[data-case="short"] {
            background: #ffc107;
            color: #212529;
        }

        .test-modal .test-buttons button[data-case="short"]:hover {
            background: #e0a800;
        }

        .test-modal .test-buttons button[data-case="long"] {
            background: #fd7e14;
            color: white;
        }

        .test-modal .test-buttons button[data-case="long"]:hover {
            background: #e96b02;
        }

        .test-modal .test-buttons button[data-case="mismatch"] {
            background: #dc3545;
            color: white;
        }

        .test-modal .test-buttons button[data-case="mismatch"]:hover {
            background: #c82333;
        }

        .test-modal .test-buttons button[data-case="mixed"] {
            background: #6f42c1;
            color: white;
        }

        .test-modal .test-buttons button[data-case="mixed"]:hover {
            background: #5a32a3;
        }

        /* 연속 데이터 테스트 케이스 버튼 스타일 */
        .test-modal .test-buttons button[data-case="continuous"] {
            background: #17a2b8;
            color: white;
        }

        .test-modal .test-buttons button[data-case="continuous"]:hover {
            background: #138496;
        }

        .test-modal .test-buttons button[data-case="continuous_multi"] {
            background: #20c997;
            color: white;
        }

        .test-modal .test-buttons button[data-case="continuous_multi"]:hover {
            background: #1aa179;
        }

        /* 테스트 그룹 스타일 */
        .test-modal .test-group {
            margin-bottom: 20px;
        }

        .test-modal .test-group h5 {
            margin: 0 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            color: #495057;
            font-size: 14px;
        }

        .test-modal .test-group:last-child {
            margin-bottom: 0;
        }

        /* 다크모드 - 테스트 모달 */
        body.dark-mode .test-modal .test-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .test-modal .test-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-tip strong {
            color: #ffc107;
        }

        /* =====================================================
         * 전체 내보내기 모달 스타일
         * ===================================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s;
        }

        .modal-container {
            background: white;
            width: 700px;
            max-height: 90vh;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
        }

        .modal-close-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .modal-close-btn:hover {
            opacity: 0.8;
        }

        .modal-body {
            padding: 25px;
            max-height: calc(90vh - 160px);
            overflow-y: auto;
        }

        .modal-description {
            color: #495057;
            margin-bottom: 20px;
        }

        .export-format-select > label {
            display: block;
            font-weight: bold;
            margin-bottom: 12px;
        }

        .format-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .format-option {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-option:hover {
            background: #e9ecef;
        }

        .format-option.selected {
            background: #e7f3ff;
            border-color: #007bff;
        }

        .format-option input[type="radio"] {
            width: 20px;
            height: 20px;
        }

        .option-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .option-text strong {
            color: #495057;
        }

        .option-text small {
            color: #6c757d;
        }

        .export-preview > label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #export-preview-area {
            width: 100%;
            font-family: monospace;
            font-size: 13px;
            padding: 15px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            background: #f8f9fa;
            box-sizing: border-box;
            resize: vertical;
        }

        .preview-stats {
            margin-top: 10px;
            color: #6c757d;
            text-align: right;
        }

        .modal-footer {
            background: #f8f9fa;
            padding: 20px 25px;
            display: flex;
            gap: 12px;
            border-top: 1px solid #dee2e6;
        }

        .modal-footer button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .modal-footer .btn-primary {
            background: #007bff;
            color: white;
        }

        .modal-footer .btn-primary:hover {
            background: #0056b3;
        }

        .modal-footer .btn-secondary {
            background: #28a745;
            color: white;
        }

        .modal-footer .btn-secondary:hover {
            background: #1e7e34;
        }

        .modal-footer .btn-cancel {
            background: #6c757d;
            color: white;
            flex: 0.5;
        }

        .modal-footer .btn-cancel:hover {
            background: #545b62;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* 다크모드 - 내보내기 모달 */
        body.dark-mode .modal-container {
            background: #2d2d2d;
        }

        body.dark-mode .modal-body {
            color: #e0e0e0;
        }

        body.dark-mode .modal-description {
            color: #b0b0b0;
        }

        body.dark-mode .format-option {
            background: #3d3d3d;
            border-color: #4d4d4d;
        }

        body.dark-mode .format-option:hover {
            background: #4d4d4d;
        }

        body.dark-mode .format-option.selected {
            background: #1a365d;
            border-color: #4a90d9;
        }

        body.dark-mode .option-text strong {
            color: #e0e0e0;
        }

        body.dark-mode .option-text small {
            color: #a0a0a0;
        }

        body.dark-mode #export-preview-area {
            background: #3d3d3d;
            border-color: #4d4d4d;
            color: #e0e0e0;
        }

        body.dark-mode .modal-footer {
            background: #252525;
            border-top-color: #4d4d4d;
        }

        body.dark-mode .preview-stats {
            color: #a0a0a0;
        }

        /* =====================================================
         * 파싱 결과 수정/반영 기능 스타일
         * ===================================================== */
        
        /* 편집 가능한 값 셀 */
        .editable-value {
            cursor: text;
            padding: 6px 10px !important;
            border-radius: 4px;
            transition: all 0.2s ease;
            min-height: 20px;
            position: relative;
        }
        
        .editable-value:hover {
            background: #e7f3ff !important;
            box-shadow: inset 0 0 0 2px #007bff40;
        }
        
        .editable-value:focus {
            outline: none;
            background: #fff !important;
            box-shadow: inset 0 0 0 2px #007bff;
        }
        
        .editable-value.modified {
            background: #fff3cd !important;
            border-left: 3px solid #ffc107;
        }
        
        .editable-value.modified:hover {
            background: #ffe69c !important;
        }
        
        body.dark-mode .editable-value:hover {
            background: #1a3a5c !important;
        }
        
        body.dark-mode .editable-value:focus {
            background: #1e2a3a !important;
        }
        
        body.dark-mode .editable-value.modified {
            background: #3d3500 !important;
            border-left-color: #ffc107;
        }
        
        /* 편집 불가 표시 (FULL 타입 등) */
        .readonly-value {
            background: #f0f0f0;
            color: #6c757d;
            cursor: not-allowed;
        }
        
        body.dark-mode .readonly-value {
            background: #2a2a2a;
            color: #888;
        }
        
        /* 수정 반영 버튼 그룹 */
        .reflect-changes-container {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        
        body.dark-mode .reflect-changes-container {
            background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
            border-color: #404040;
        }
        
        .reflect-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .reflect-info .modified-count {
            background: #ffc107;
            color: #333;
            padding: 4px 10px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 13px;
        }
        
        .reflect-info .modified-count.no-changes {
            background: #6c757d;
            color: white;
        }
        
        .reflect-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn-reflect {
            padding: 10px 20px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-reflect:hover {
            background: linear-gradient(135deg, #218838, #1aa179);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        
        .btn-reflect:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-reset-changes {
            padding: 10px 20px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-reset-changes:hover {
            background: #5a6268;
        }
        
        /* 재생성된 통데이터 결과 영역 */
        .regenerated-data-container {
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 8px;
        }
        
        body.dark-mode .regenerated-data-container {
            background: #1a3a1a;
            border-color: #28a745;
        }
        
        .regenerated-data-container h4 {
            margin: 0 0 15px 0;
            color: #155724;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        body.dark-mode .regenerated-data-container h4 {
            color: #a3d9a5;
        }
        
        .regenerated-data-content {
            background: white;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #c3e6cb;
        }
        
        body.dark-mode .regenerated-data-content {
            background: #1a1a1a;
            border-color: #28a745;
            color: #e0e0e0;
        }
        
        .regenerated-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn-copy-regenerated {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-copy-regenerated:hover {
            background: #0056b3;
        }
        
        .btn-apply-to-input {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-apply-to-input:hover {
            background: #138496;
        }
        
        /* 필드 편집 힌트 */
        .edit-hint {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        body.dark-mode .edit-hint {
            background: #2a2a2a;
            color: #a0a0a0;
        }
        
        .edit-hint .hint-icon {
            color: #17a2b8;
        }
    </style>
</head>
<body>
    <!-- 다크모드 토글 버튼 -->
    <button class="theme-toggle" id="theme-toggle" title="다크모드 전환">🌙</button>
    
    <h1>통전문 파서</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML 파싱</button>
        <button class="tab-btn" data-tab="struct">C 구조체 파싱</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        
        <!-- 서브 탭 네비게이션 (신규) -->
        <div class="sub-tab-nav">
            <button class="sub-tab-btn active" data-mode="parse">
                📖 파싱 모드
            </button>
            <button class="sub-tab-btn" data-mode="generate">
                ✏️ 생성 모드
            </button>
        </div>
        
        <!-- 파싱 모드 (기존 내용) -->
        <div id="xml-parse-mode" class="sub-mode-content active">
            <div id="input-section">
                <label for="xml-input">XML 규격</label>
                <textarea id="xml-input" rows="10" placeholder="XML 규격 입력"></textarea>
                
                <label for="telegram-input">통전문</label>
                <textarea id="telegram-input" rows="5" placeholder="통전문 입력"></textarea>
                
                <div class="button-group">
                    <button id="sample-btn">샘플 로드</button>
                    <button id="parse-btn">파싱 실행</button>
                    <button id="clear-btn">초기화</button>
                </div>
            </div>
        </div>
        
        <!-- 생성 모드 (신규) -->
        <div id="xml-generate-mode" class="sub-mode-content">
            <div class="generate-intro">
                <h4>✏️ 전문 생성 (XML 기반)</h4>
                <p>XML 규격을 입력하고 각 필드에 값을 입력하여 통전문을 생성합니다.</p>
                <div class="type-info-box">
                    <strong>지원 타입:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px; font-size: 13px;">
                        <li><code style="background:#17a2b8; color:white; padding:2px 6px; border-radius:3px;">X</code> 문자 타입 - 우측 공백 패딩</li>
                        <li><code style="background:#ffc107; color:#000; padding:2px 6px; border-radius:3px;">N</code> 숫자 타입 - 좌측 0 패딩</li>
                        <li><code style="background:#6f42c1; color:white; padding:2px 6px; border-radius:3px;">FULL</code> KSC-5601 2바이트 완성형 코드 - 한글 인코딩 (바이트 단위)</li>
                    </ul>
                </div>
            </div>
            
            <div class="xml-spec-input">
                <label for="xml-generate-spec">XML 규격</label>
                <textarea id="xml-generate-spec" rows="12" placeholder="<packet>...</packet>"></textarea>
                <button id="load-xml-form-btn" class="primary-btn">
                    폼 불러오기
                </button>
            </div>
            
            <div id="xml-generate-form-container" style="display: none;">
                <!-- 입력 폼 -->
            </div>
            
            <div id="xml-generated-records-area">
                <!-- 생성된 레코드 -->
            </div>
        </div>
        
        <!-- 결과 영역 (공통) -->
        <div id="result-container"></div>
        
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <!-- 도움말 섹션 -->
        <div class="help-section">
            <button class="help-toggle" type="button">
                <span>📖 사용 방법 안내</span>
                <span class="help-toggle-icon">▼</span>
            </button>
            <div class="help-content">
                <h4>C 구조체 파싱 사용법</h4>
                <p>고정 길이 데이터를 C 구조체 정의에 따라 파싱합니다.</p>
                
                <h4>1. 구조체 정의 형식</h4>
                <p><code>typedef struct { ... } 구조체명;</code> 형식으로 입력합니다.</p>
                <pre>typedef struct {
    char record_kubun[1];  // 레코드 구분
    char bank_cd[2];       // 은행 코드
    char cust_id[7];       // 고객 ID
} DHF_H;</pre>
                
                <h4>2. 데이터 입력 규칙</h4>
                <ul>
                    <li>각 줄이 하나의 데이터 레코드입니다</li>
                    <li>여러 구조체가 있을 경우, 첫 글자로 구조체를 자동 매칭합니다</li>
                    <li>예: <code>H</code>로 시작 → <code>DHF_H</code> (H로 끝나는 구조체)</li>
                    <li>예: <code>D</code>로 시작 → <code>DHF_D</code> (D로 끝나는 구조체)</li>
                </ul>
                
                <h4>3. 지원 기능</h4>
                <ul>
                    <li>여러 구조체 동시 정의 가능</li>
                    <li>주석 지원: <code>//</code> 한줄 주석, <code>/* */</code> 블록 주석</li>
                    <li>파싱 결과를 TSV 형식으로 클립보드에 복사 가능</li>
                </ul>
                
                <h4>4. 주의사항</h4>
                <ul>
                    <li>데이터 길이가 구조체 총 크기와 다르면 경고가 표시됩니다</li>
                    <li>char 배열만 정확히 지원됩니다 (int, short 등은 char로 처리)</li>
                </ul>
            </div>
        </div>

        <!-- 공통: 구조체 정의 영역 -->
        <div id="struct-definitions-area">
            <div class="section-header">
                <h3>
                    C 구조체 정의
                    <button class="help-icon" id="crlf-help">❓</button>
                </h3>
                <div class="header-options">
                    <label class="option-checkbox">
                        <input type="checkbox" id="recognize-crlf">
                        개행문자 인식 (CRLF)
                    </label>
                    <label class="option-checkbox">
                        <input type="checkbox" id="debug-mode">
                        🔍 디버그 모드
                    </label>
                    <button id="add-struct-btn">+ 구조체 추가 <span class="shortcut-hint">(Ctrl+N)</span></button>
                </div>
            </div>
            <div class="option-description">
                <small>
                    ℹ️ 체크 시: 각 레코드 끝에 CRLF(2 bytes) 존재로 간주<br>
                    📝 체크 해제: 줄바꿈 제거 후 연속 데이터로 처리
                </small>
            </div>
            
            <div id="struct-definitions-container">
                <!-- 구조체 입력 카드들이 여기 동적 추가됨 -->
            </div>
        </div>

        <!-- 서브 탭 네비게이션 -->
        <div class="sub-tab-nav">
            <button class="sub-tab-btn active" data-mode="parse">
                📖 파싱 모드
            </button>
            <button class="sub-tab-btn" data-mode="generate">
                ✏️ 생성 모드
            </button>
        </div>

        <!-- 파싱 모드 컨텐츠 -->
        <div id="parse-mode-content" class="sub-mode-content active">
            <label for="struct-data">통 데이터</label>
            <textarea id="struct-data" rows="10" placeholder="파싱할 데이터 입력 (줄바꿈 유무 무관)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">샘플 로드</button>
                <button id="struct-test-btn">테스트 케이스</button>
                <button id="struct-parse-btn">파싱 실행 <span class="shortcut-hint">(Ctrl+Enter)</span></button>
                <button id="struct-clear-btn">전체 초기화</button>
            </div>
        </div>

        <!-- 생성 모드 컨텐츠 -->
        <div id="generate-mode-content" class="sub-mode-content">
          
          <div class="generate-intro">
            <h4>✏️ 전문 생성</h4>
            <p>정의된 구조체를 선택하고 각 필드에 값을 입력하여 통전문을 생성합니다.</p>
          </div>
          
          <div class="struct-selector">
            <label for="generate-struct-select">생성할 구조체 선택</label>
            <select id="generate-struct-select" class="form-select">
              <option value="">구조체를 먼저 정의하세요</option>
            </select>
            <button id="load-generate-form-btn" class="primary-btn" disabled>
              폼 불러오기
            </button>
          </div>
          
          <div id="generate-form-container" style="display: none;">
            <!-- 입력 폼이 여기 동적 생성됨 -->
          </div>
          
          <div id="generated-records-area">
            <!-- 생성된 레코드 목록 -->
          </div>
          
        </div>

        <div id="struct-result-container"></div>

        <!-- 개행문자 인식 도움말 모달 -->
        <div class="help-modal" id="crlf-help-modal">
            <div class="help-content">
                <button class="close-help">✕</button>
                <h3>💡 개행문자 인식 옵션 설명</h3>
                
                <div class="help-section">
                    <h4>✓ 체크 시 (권장)</h4>
                    <ul>
                        <li>C 구조체에 <code>crlf[2]</code> 필드가 있는 경우 사용</li>
                        <li>각 레코드 끝에 자동으로 <code>\r\n</code> (2 bytes) 추가</li>
                        <li>textarea에 줄바꿈으로 레코드 구분</li>
                    </ul>
                    
                    <pre class="help-example">예시:
H881234567
D123456789012345600000000000000001000
       ↓
H881234567\r\n  (12 bytes)
D123456789012345600000000000000001000\r\n  (39 bytes)</pre>
                </div>
                
                <div class="help-section">
                    <h4>✗ 체크 해제 시</h4>
                    <ul>
                        <li>구조체에 CRLF 필드가 없는 경우</li>
                        <li>모든 줄바꿈 제거 후 연속 데이터로 처리</li>
                        <li>구분값으로 레코드 자동 인식</li>
                    </ul>
                </div>
                
                <div class="help-tip">
                    <strong>💡 팁:</strong> 일반적인 전문 파일은 개행문자를 포함합니다.
                    확실하지 않다면 체크 상태로 두세요.
                </div>
            </div>
        </div>

        <!-- 테스트 케이스 선택 모달 -->
        <div class="test-modal" id="test-case-modal">
            <div class="test-content">
                <button class="close-test">✕</button>
                <h4>🧪 테스트 케이스 선택</h4>
                
                <!-- 개행 인식 ON 테스트 (라인 단위 파싱) -->
                <div class="test-group">
                    <h5>📄 개행 인식 ON (라인 단위)</h5>
                    <div class="test-buttons">
                        <button data-case="normal">✅ 정상 데이터</button>
                        <button data-case="short">⚠️ 길이 부족</button>
                        <button data-case="long">📏 길이 초과</button>
                        <button data-case="mismatch">❌ 매칭 실패</button>
                        <button data-case="mixed">🔀 혼합</button>
                    </div>
                </div>
                
                <!-- 개행 인식 OFF 테스트 (연속 데이터 파싱) -->
                <div class="test-group">
                    <h5>🔗 개행 인식 OFF (연속 데이터)</h5>
                    <div class="test-buttons">
                        <button data-case="continuous">📦 연속 데이터</button>
                        <button data-case="continuous_multi">🔄 연속 다중 레코드</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * =====================================================
         * 전역 변수
         * =====================================================
         */
        let structCardIndex = 0;

        /**
         * =====================================================
         * 정규식 캐싱 - 성능 최적화를 위해 정규식을 미리 컴파일
         * =====================================================
         */
        const REGEX_CACHE = {
            // 한줄 주석 제거: // 부터 줄 끝까지 매칭
            singleLineComment: /\/\/.*$/gm,
            
            // 블록 주석 제거: /* 부터 */ 까지 (비탐욕적 매칭)
            blockComment: /\/\*[\s\S]*?\*\//g,
            
            // typedef struct 블록 추출:
            // - typedef\s+struct: "typedef struct" 키워드
            // - (\w+)?: 선택적 구조체 이름 (캡처 그룹 1)
            // - \s*\{([^}]+)\}: 중괄호와 내용 (캡처 그룹 2)
            // - \s*(\w+)\s*;: typedef 별칭 이름 (캡처 그룹 3)
            structPattern: /typedef\s+struct\s+(\w+)?\s*\{([^}]+)\}\s*(\w+)\s*;/g,
            
            // 필드 추출:
            // - (unsigned\s+)?: 선택적 unsigned 키워드 (캡처 그룹 1)
            // - (\w+): 기본 타입 (char, int 등) (캡처 그룹 2)
            // - \s+(\w+): 필드명 (캡처 그룹 3)
            // - \s*\[\s*(\d+)\s*\]: 배열 크기 (캡처 그룹 4)
            fieldPattern: /(unsigned\s+)?(\w+)\s+(\w+)\s*\[\s*(\d+)\s*\]/g,
            
            // 구조체명에서 숫자 추출: 문자열 끝의 연속된 숫자
            trailingNumber: /(\d+)$/
        };

        /**
         * 정규식 패턴을 복제하여 반환
         * 정규식은 상태를 가지므로(lastIndex), 사용 전 복제 필요
         * @param {string} name - REGEX_CACHE의 키 이름
         * @returns {RegExp} 복제된 정규식 객체
         */
        function getRegex(name) {
            const original = REGEX_CACHE[name];
            return new RegExp(original.source, original.flags);
        }

        /**
         * =====================================================
         * KSC-5601 (EUC-KR) 인코딩/디코딩 유틸리티
         * FULL 타입 처리를 위한 2바이트 완성형 한글 코드 변환
         * =====================================================
         */
        const KSC5601 = {
            /**
             * KSC-5601 바이트 배열을 문자열로 디코딩
             * @param {Uint8Array|string} bytes - 바이트 배열 또는 Latin1 문자열
             * @returns {string} 디코딩된 문자열
             */
            decode: function(bytes) {
                try {
                    // 문자열인 경우 바이트 배열로 변환
                    let byteArray;
                    if (typeof bytes === 'string') {
                        byteArray = new Uint8Array(bytes.length);
                        for (let i = 0; i < bytes.length; i++) {
                            byteArray[i] = bytes.charCodeAt(i) & 0xFF;
                        }
                    } else {
                        byteArray = bytes;
                    }
                    
                    // TextDecoder를 사용하여 EUC-KR 디코딩
                    const decoder = new TextDecoder('euc-kr');
                    return decoder.decode(byteArray);
                } catch (e) {
                    console.warn('KSC5601.decode 오류:', e.message);
                    return bytes;
                }
            },

            /**
             * 문자열을 KSC-5601 2바이트 완성형 바이트 배열로 인코딩
             * 모든 문자가 2바이트로 변환됨 (전각 문자)
             * @param {string} str - 인코딩할 문자열
             * @returns {Uint8Array} KSC-5601 바이트 배열
             */
            encode: function(str) {
                if (!str || str.length === 0) {
                    return new Uint8Array(0);
                }

                const result = [];
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    let code = char.charCodeAt(0);
                    
                    // ============================================
                    // 유니코드 전각 문자를 반각(ASCII)으로 정규화
                    // 한글 IME 상태에서 영문 입력 시 전각으로 들어올 수 있음
                    // ============================================
                    // 전각 공백 (U+3000) → 반각 공백
                    if (code === 0x3000) {
                        code = 0x20;
                    }
                    // 전각 ASCII (U+FF01~U+FF5E) → 반각 ASCII (0x21~0x7E)
                    else if (code >= 0xFF01 && code <= 0xFF5E) {
                        code = code - 0xFF01 + 0x21;
                    }
                    // 전각 숫자 0-9 (U+FF10~U+FF19) → 반각 숫자 (별도 처리 불필요, 위에서 처리됨)
                    // 전각 대문자 A-Z (U+FF21~U+FF3A) → 반각 대문자 (별도 처리 불필요, 위에서 처리됨)
                    // 전각 소문자 a-z (U+FF41~U+FF5A) → 반각 소문자 (별도 처리 불필요, 위에서 처리됨)
                    
                    // ============================================
                    // 정규화된 코드로 KSC-5601 인코딩
                    // ============================================
                    // 공백 → 전각 공백 (0xA1A1)
                    if (code === 0x20) {
                        result.push(0xA1);
                        result.push(0xA1);
                    }
                    // 숫자 0-9 → 전각 숫자 (0xA3B0-0xA3B9)
                    else if (code >= 0x30 && code <= 0x39) {
                        result.push(0xA3);
                        result.push(0xB0 + (code - 0x30));
                    }
                    // 대문자 A-Z → 전각 대문자 (0xA3C1-0xA3DA)
                    else if (code >= 0x41 && code <= 0x5A) {
                        result.push(0xA3);
                        result.push(0xC1 + (code - 0x41));
                    }
                    // 소문자 a-z → 전각 소문자 (0xA3E1-0xA3FA)
                    else if (code >= 0x61 && code <= 0x7A) {
                        result.push(0xA3);
                        result.push(0xE1 + (code - 0x61));
                    }
                    // 기타 ASCII 특수문자 → 전각 특수문자
                    else if (code >= 0x21 && code <= 0x7E) {
                        const fullwidthCode = this.asciiToFullwidth(code);
                        if (fullwidthCode) {
                            result.push((fullwidthCode >> 8) & 0xFF);
                            result.push(fullwidthCode & 0xFF);
                        } else {
                            // 변환 불가 시 전각 물음표
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 한글 완성형 (가-힣: 0xAC00-0xD7A3)
                    else if (code >= 0xAC00 && code <= 0xD7A3) {
                        const kscCode = this.unicodeToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            // 변환 불가 시 전각 물음표 대체
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 한글 자모 (ㄱ-ㅎ, ㅏ-ㅣ)
                    else if ((code >= 0x3131 && code <= 0x3163)) {
                        const kscCode = this.unicodeJamoToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 기타 2바이트 문자
                    else if (code > 0x7F) {
                        // 특수문자 등의 변환 시도
                        const kscCode = this.unicodeSpecialToKSC5601(code);
                        if (kscCode) {
                            result.push((kscCode >> 8) & 0xFF);
                            result.push(kscCode & 0xFF);
                        } else {
                            // 변환 불가 시 전각 물음표 대체
                            result.push(0xA3);
                            result.push(0xBF);
                        }
                    }
                    // 제어 문자 등 → 전각 공백으로 대체
                    else {
                        result.push(0xA1);
                        result.push(0xA1);
                    }
                }
                
                return new Uint8Array(result);
            },
            
            /**
             * ASCII 특수문자를 KSC-5601 전각 코드로 변환
             * @param {number} ascii - ASCII 코드 (0x21-0x7E)
             * @returns {number|null} KSC-5601 전각 코드 또는 null
             */
            asciiToFullwidth: function(ascii) {
                // KSC-5601 전각 특수문자 매핑 (0xA3xx 영역)
                const asciiToKsc = {
                    0x21: 0xA3A1, // !
                    0x22: 0xA3A2, // "
                    0x23: 0xA3A3, // #
                    0x24: 0xA3A4, // $
                    0x25: 0xA3A5, // %
                    0x26: 0xA3A6, // &
                    0x27: 0xA3A7, // '
                    0x28: 0xA3A8, // (
                    0x29: 0xA3A9, // )
                    0x2A: 0xA3AA, // *
                    0x2B: 0xA3AB, // +
                    0x2C: 0xA3AC, // ,
                    0x2D: 0xA3AD, // -
                    0x2E: 0xA3AE, // .
                    0x2F: 0xA3AF, // /
                    0x3A: 0xA3BA, // :
                    0x3B: 0xA3BB, // ;
                    0x3C: 0xA3BC, // <
                    0x3D: 0xA3BD, // =
                    0x3E: 0xA3BE, // >
                    0x3F: 0xA3BF, // ?
                    0x40: 0xA3C0, // @
                    0x5B: 0xA3DB, // [
                    0x5C: 0xA3DC, // \
                    0x5D: 0xA3DD, // ]
                    0x5E: 0xA3DE, // ^
                    0x5F: 0xA3DF, // _
                    0x60: 0xA3E0, // `
                    0x7B: 0xA3FB, // {
                    0x7C: 0xA3FC, // |
                    0x7D: 0xA3FD, // }
                    0x7E: 0xA3FE  // ~
                };
                return asciiToKsc[ascii] || null;
            },

            /**
             * KSC-5601 바이트를 Latin1 문자열로 변환 (통전문 생성용)
             * @param {string} str - 인코딩할 문자열
             * @returns {string} Latin1 인코딩된 문자열
             */
            encodeToString: function(str) {
                const bytes = this.encode(str);
                let result = '';
                for (let i = 0; i < bytes.length; i++) {
                    result += String.fromCharCode(bytes[i]);
                }
                return result;
            },

            /**
             * KSC-5601 2바이트 완성형 인코딩된 문자열의 바이트 길이 계산
             * 모든 문자가 2바이트로 처리됨
             * @param {string} str - 문자열
             * @returns {number} 바이트 길이
             */
            getByteLength: function(str) {
                if (!str) return 0;
                // KSC-5601 완성형에서는 모든 문자가 2바이트
                return str.length * 2;
            },

            /**
             * Unicode 한글 완성형을 KSC-5601 코드로 변환
             * @param {number} unicode - Unicode 코드 포인트
             * @returns {number|null} KSC-5601 코드 또는 null
             */
            unicodeToKSC5601: function(unicode) {
                // 한글 완성형 변환 테이블 (가-힣)
                // KSC-5601 한글 완성형은 0xB0A1 ~ 0xC8FE 범위
                // 유니코드 한글 완성형은 0xAC00 ~ 0xD7A3 (11172자)
                // KSC-5601은 2350자만 수록
                
                // KSC-5601 한글 배치표 기반 변환 (테이블 사용)
                if (!this._kscTable) {
                    this._initKSCTable();
                }
                
                return this._kscTable[unicode] || null;
            },

            /**
             * Unicode 자모를 KSC-5601 코드로 변환
             * @param {number} unicode - Unicode 자모 코드
             * @returns {number|null} KSC-5601 코드 또는 null
             */
            unicodeJamoToKSC5601: function(unicode) {
                // 한글 자모 변환 (ㄱ-ㅣ)
                const jamoTable = {
                    0x3131: 0xA4A1, // ㄱ
                    0x3132: 0xA4A2, // ㄲ
                    0x3133: 0xA4A3, // ㄳ
                    0x3134: 0xA4A4, // ㄴ
                    0x3135: 0xA4A5, // ㄵ
                    0x3136: 0xA4A6, // ㄶ
                    0x3137: 0xA4A7, // ㄷ
                    0x3138: 0xA4A8, // ㄸ
                    0x3139: 0xA4A9, // ㄹ
                    0x313A: 0xA4AA, // ㄺ
                    0x313B: 0xA4AB, // ㄻ
                    0x313C: 0xA4AC, // ㄼ
                    0x313D: 0xA4AD, // ㄽ
                    0x313E: 0xA4AE, // ㄾ
                    0x313F: 0xA4AF, // ㄿ
                    0x3140: 0xA4B0, // ㅀ
                    0x3141: 0xA4B1, // ㅁ
                    0x3142: 0xA4B2, // ㅂ
                    0x3143: 0xA4B3, // ㅃ
                    0x3144: 0xA4B4, // ㅄ
                    0x3145: 0xA4B5, // ㅅ
                    0x3146: 0xA4B6, // ㅆ
                    0x3147: 0xA4B7, // ㅇ
                    0x3148: 0xA4B8, // ㅈ
                    0x3149: 0xA4B9, // ㅉ
                    0x314A: 0xA4BA, // ㅊ
                    0x314B: 0xA4BB, // ㅋ
                    0x314C: 0xA4BC, // ㅌ
                    0x314D: 0xA4BD, // ㅍ
                    0x314E: 0xA4BE, // ㅎ
                    0x314F: 0xA4BF, // ㅏ
                    0x3150: 0xA4C0, // ㅐ
                    0x3151: 0xA4C1, // ㅑ
                    0x3152: 0xA4C2, // ㅒ
                    0x3153: 0xA4C3, // ㅓ
                    0x3154: 0xA4C4, // ㅔ
                    0x3155: 0xA4C5, // ㅕ
                    0x3156: 0xA4C6, // ㅖ
                    0x3157: 0xA4C7, // ㅗ
                    0x3158: 0xA4C8, // ㅘ
                    0x3159: 0xA4C9, // ㅙ
                    0x315A: 0xA4CA, // ㅚ
                    0x315B: 0xA4CB, // ㅛ
                    0x315C: 0xA4CC, // ㅜ
                    0x315D: 0xA4CD, // ㅝ
                    0x315E: 0xA4CE, // ㅞ
                    0x315F: 0xA4CF, // ㅟ
                    0x3160: 0xA4D0, // ㅠ
                    0x3161: 0xA4D1, // ㅡ
                    0x3162: 0xA4D2, // ㅢ
                    0x3163: 0xA4D3  // ㅣ
                };
                return jamoTable[unicode] || null;
            },

            /**
             * Unicode 특수문자를 KSC-5601 코드로 변환
             * @param {number} unicode - Unicode 코드
             * @returns {number|null} KSC-5601 코드 또는 null
             */
            unicodeSpecialToKSC5601: function(unicode) {
                // 일부 특수문자 매핑
                const specialTable = {
                    0x00A0: 0xA1A1, // Non-breaking space
                    0x00B7: 0xA1A4, // ·
                    0x2025: 0xA1A5, // ‥
                    0x2026: 0xA1A6, // …
                    0x00A8: 0xA1A7, // ¨
                    0x3001: 0xA1A2, // 、
                    0x3002: 0xA1A3, // 。
                    0xFF01: 0xA3A1, // ！
                    0xFF1F: 0xA3BF  // ？
                };
                return specialTable[unicode] || null;
            },

            /**
             * KSC-5601 한글 변환 테이블 초기화
             * 완성형 한글 2350자를 Unicode -> KSC-5601 매핑
             * 정확한 [유니코드, KSC코드] 쌍 사용
             */
            _initKSCTable: function() {
                this._kscTable = {};
                
                // KSC-5601 완성형 한글 2350자 매핑 데이터
                // format: "유니코드:KSC코드" 형태로 압축 저장
                // 자주 사용되는 한글 위주로 직접 매핑
                const mappingData = [
                    // 가 행 (0xB0xx)
                    [0xAC00,0xB0A1],[0xAC01,0xB0A2],[0xAC04,0xB0A3],[0xAC07,0xB0A4],[0xAC08,0xB0A5],
                    [0xAC09,0xB0A6],[0xAC0A,0xB0A7],[0xAC10,0xB0A8],[0xAC11,0xB0A9],[0xAC12,0xB0AA],
                    [0xAC13,0xB0AB],[0xAC14,0xB0AC],[0xAC15,0xB0AD],[0xAC16,0xB0AE],[0xAC17,0xB0AF],
                    [0xAC19,0xB0B0],[0xAC1A,0xB0B1],[0xAC1B,0xB0B2],[0xAC1C,0xB0B3],[0xAC1D,0xB0B4],
                    [0xAC20,0xB0B5],[0xAC24,0xB0B6],[0xAC2C,0xB0B7],[0xAC2D,0xB0B8],[0xAC2F,0xB0B9],
                    [0xAC30,0xB0BA],[0xAC31,0xB0BB],[0xAC38,0xB0BC],[0xAC39,0xB0BD],[0xAC3C,0xB0BE],
                    [0xAC40,0xB0BF],[0xAC4B,0xB0C0],[0xAC4D,0xB0C1],[0xAC54,0xB0C2],[0xAC58,0xB0C3],
                    [0xAC5C,0xB0C4],[0xAC70,0xB0C5],[0xAC71,0xB0C6],[0xAC74,0xB0C7],[0xAC77,0xB0C8],
                    [0xAC78,0xB0C9],[0xAC7A,0xB0CA],[0xAC80,0xB0CB],[0xAC81,0xB0CC],[0xAC83,0xB0CD],
                    [0xAC84,0xB0CE],[0xAC85,0xB0CF],[0xAC86,0xB0D0],[0xAC89,0xB0D1],[0xAC8A,0xB0D2],
                    [0xAC8B,0xB0D3],[0xAC8C,0xB0D4],[0xAC90,0xB0D5],[0xAC94,0xB0D6],[0xAC9C,0xB0D7],
                    [0xAC9D,0xB0D8],[0xAC9F,0xB0D9],[0xACA0,0xB0DA],[0xACA1,0xB0DB],[0xACA8,0xB0DC],
                    [0xACA9,0xB0DD],[0xACAA,0xB0DE],[0xACAC,0xB0DF],[0xACAF,0xB0E0],[0xACB0,0xB0E1],
                    [0xACB8,0xB0E2],[0xACB9,0xB0E3],[0xACBB,0xB0E4],[0xACBC,0xB0E5],[0xACBD,0xB0E6],
                    [0xACC1,0xB0E7],[0xACC4,0xB0E8],[0xACC8,0xB0E9],[0xACCC,0xB0EA],[0xACD5,0xB0EB],
                    [0xACD7,0xB0EC],[0xACE0,0xB0ED],[0xACE1,0xB0EE],[0xACE4,0xB0EF],[0xACE7,0xB0F0],
                    [0xACE8,0xB0F1],[0xACEA,0xB0F2],[0xACEC,0xB0F3],[0xACEF,0xB0F4],[0xACF0,0xB0F5],
                    [0xACF1,0xB0F6],[0xACF3,0xB0F7],[0xACF5,0xB0F8],[0xACF6,0xB0F9],[0xACFC,0xB0FA],
                    [0xACFD,0xB0FB],[0xAD00,0xB0FC],[0xAD04,0xB0FD],[0xAD06,0xB0FE],
                    // 괌~글 (0xB1xx)
                    [0xAD0C,0xB1A1],[0xAD0D,0xB1A2],[0xAD0F,0xB1A3],[0xAD11,0xB1A4],[0xAD18,0xB1A5],
                    [0xAD1C,0xB1A6],[0xAD20,0xB1A7],[0xAD29,0xB1A8],[0xAD2C,0xB1A9],[0xAD2D,0xB1AA],
                    [0xAD34,0xB1AB],[0xAD35,0xB1AC],[0xAD38,0xB1AD],[0xAD3C,0xB1AE],[0xAD44,0xB1AF],
                    [0xAD45,0xB1B0],[0xAD47,0xB1B1],[0xAD49,0xB1B2],[0xAD50,0xB1B3],[0xAD54,0xB1B4],
                    [0xAD58,0xB1B5],[0xAD61,0xB1B6],[0xAD63,0xB1B7],[0xAD6C,0xB1B8],[0xAD6D,0xB1B9],
                    [0xAD70,0xB1BA],[0xAD73,0xB1BB],[0xAD74,0xB1BC],[0xAD75,0xB1BD],[0xAD76,0xB1BE],
                    [0xAD7B,0xB1BF],[0xAD7C,0xB1C0],[0xAD7D,0xB1C1],[0xAD7F,0xB1C2],[0xAD81,0xB1C3],
                    [0xAD82,0xB1C4],[0xAD88,0xB1C5],[0xAD89,0xB1C6],[0xAD8C,0xB1C7],[0xAD90,0xB1C8],
                    [0xAD9C,0xB1C9],[0xAD9D,0xB1CA],[0xADA4,0xB1CB],[0xADB7,0xB1CC],[0xADC0,0xB1CD],
                    [0xADC1,0xB1CE],[0xADC4,0xB1CF],[0xADC8,0xB1D0],[0xADD0,0xB1D1],[0xADD1,0xB1D2],
                    [0xADD3,0xB1D3],[0xADDC,0xB1D4],[0xADE0,0xB1D5],[0xADE4,0xB1D6],[0xADF8,0xB1D7],
                    [0xADF9,0xB1D8],[0xADFC,0xB1D9],[0xADFF,0xB1DA],[0xAE00,0xB1DB],[0xAE01,0xB1DC],
                    [0xAE08,0xB1DD],[0xAE09,0xB1DE],[0xAE0B,0xB1DF],[0xAE0D,0xB1E0],[0xAE14,0xB1E1],
                    [0xAE30,0xB1E2],[0xAE31,0xB1E3],[0xAE34,0xB1E4],[0xAE37,0xB1E5],[0xAE38,0xB1E6],
                    [0xAE3A,0xB1E7],[0xAE40,0xB1E8],[0xAE41,0xB1E9],[0xAE43,0xB1EA],[0xAE45,0xB1EB],
                    [0xAE46,0xB1EC],[0xAE4A,0xB1ED],[0xAE4C,0xB1EE],[0xAE4D,0xB1EF],[0xAE4E,0xB1F0],
                    [0xAE50,0xB1F1],[0xAE54,0xB1F2],[0xAE5C,0xB1F3],[0xAE5D,0xB1F4],[0xAE5F,0xB1F5],
                    [0xAE60,0xB1F6],[0xAE61,0xB1F7],[0xAE65,0xB1F8],[0xAE68,0xB1F9],[0xAE69,0xB1FA],
                    [0xAE6C,0xB1FB],[0xAE70,0xB1FC],[0xAE78,0xB1FD],[0xAE79,0xB1FE],
                    // 나 행
                    [0xB098,0xB3AA],[0xB099,0xB3AB],[0xB09A,0xB3AC],[0xB09C,0xB3AD],[0xB09F,0xB3AE],
                    [0xB0A0,0xB3AF],[0xB0A1,0xB3B0],[0xB0A2,0xB3B1],[0xB0A8,0xB3B2],[0xB0A9,0xB3B3],
                    [0xB0AB,0xB3B4],[0xB0AC,0xB3B5],[0xB0AD,0xB3B6],[0xB0AE,0xB3B7],[0xB0AF,0xB3B8],
                    [0xB0B1,0xB3B9],[0xB0B3,0xB3BA],[0xB0B4,0xB3BB],[0xB0B5,0xB3BC],[0xB0B8,0xB3BD],
                    [0xB0BC,0xB3BE],[0xB0C4,0xB3BF],[0xB0C5,0xB3C0],[0xB0C7,0xB3C1],[0xB0C8,0xB3C2],
                    [0xB0C9,0xB3C3],[0xB0D0,0xB3C4],[0xB0D1,0xB3C5],[0xB0D4,0xB3C6],[0xB0D8,0xB3C7],
                    [0xB0E0,0xB3C8],[0xB0E5,0xB3C9],[0xB108,0xB3CA],[0xB109,0xB3CB],[0xB10B,0xB3CC],
                    [0xB10C,0xB3CD],[0xB110,0xB3CE],[0xB112,0xB3CF],[0xB113,0xB3D0],[0xB118,0xB3D1],
                    [0xB119,0xB3D2],[0xB11B,0xB3D3],[0xB11C,0xB3D4],[0xB11D,0xB3D5],[0xB123,0xB3D6],
                    [0xB124,0xB3D7],[0xB125,0xB3D8],[0xB128,0xB3D9],[0xB12C,0xB3DA],[0xB134,0xB3DB],
                    [0xB135,0xB3DC],[0xB137,0xB3DD],[0xB138,0xB3DE],[0xB139,0xB3DF],[0xB140,0xB3E0],
                    [0xB141,0xB3E1],[0xB144,0xB3E2],[0xB148,0xB3E3],[0xB150,0xB3E4],[0xB151,0xB3E5],
                    [0xB154,0xB3E6],[0xB155,0xB3E7],[0xB158,0xB3E8],[0xB15C,0xB3E9],[0xB160,0xB3EA],
                    [0xB178,0xB3EB],[0xB179,0xB3EC],[0xB17C,0xB3ED],[0xB180,0xB3EE],[0xB182,0xB3EF],
                    [0xB188,0xB3F0],[0xB189,0xB3F1],[0xB18B,0xB3F2],[0xB18D,0xB3F3],[0xB192,0xB3F4],
                    [0xB193,0xB3F5],[0xB194,0xB3F6],[0xB198,0xB3F7],[0xB19C,0xB3F8],[0xB1A8,0xB3F9],
                    [0xB1CC,0xB3FA],[0xB1D0,0xB3FB],[0xB1D4,0xB3FC],[0xB1DC,0xB3FD],[0xB1DD,0xB3FE],
                    // 다 행
                    [0xB2C8,0xB4CF],[0xB2C9,0xB4D0],[0xB2CC,0xB4D1],[0xB2D0,0xB4D2],[0xB2D2,0xB4D3],
                    [0xB2D8,0xB4D4],[0xB2D9,0xB4D5],[0xB2DB,0xB4D6],[0xB2DD,0xB4D7],[0xB2E2,0xB4D8],
                    [0xB2E4,0xB4D9],[0xB2E5,0xB4DA],[0xB2E6,0xB4DB],[0xB2E8,0xB4DC],[0xB2EB,0xB4DD],
                    [0xB2EC,0xB4DE],[0xB2ED,0xB4DF],[0xB2EE,0xB4E0],[0xB2EF,0xB4E1],[0xB2F3,0xB4E2],
                    [0xB2F4,0xB4E3],[0xB2F5,0xB4E4],[0xB2F7,0xB4E5],[0xB2F8,0xB4E6],[0xB2F9,0xB4E7],
                    [0xB2FA,0xB4E8],[0xB2FB,0xB4E9],[0xB2FF,0xB4EA],[0xB300,0xB4EB],[0xB301,0xB4EC],
                    [0xB304,0xB4ED],[0xB308,0xB4EE],[0xB310,0xB4EF],[0xB311,0xB4F0],[0xB313,0xB4F1],
                    [0xB314,0xB4F2],[0xB315,0xB4F3],[0xB31C,0xB4F4],[0xB354,0xB4F5],[0xB355,0xB4F6],
                    [0xB356,0xB4F7],[0xB358,0xB4F8],[0xB35B,0xB4F9],[0xB35C,0xB4FA],[0xB35E,0xB4FB],
                    [0xB35F,0xB4FC],[0xB364,0xB4FD],[0xB365,0xB4FE],
                    // 라 행
                    [0xB77C,0xB6F3],[0xB77D,0xB6F4],[0xB780,0xB6F5],[0xB784,0xB6F6],[0xB78C,0xB6F7],
                    [0xB78D,0xB6F8],[0xB78F,0xB6F9],[0xB790,0xB6FA],[0xB791,0xB6FB],[0xB792,0xB6FC],
                    [0xB796,0xB6FD],[0xB797,0xB6FE],
                    // 마 행
                    [0xB9C8,0xB8B6],[0xB9C9,0xB8B7],[0xB9CC,0xB8B8],[0xB9CE,0xB8B9],[0xB9CF,0xB8BA],
                    [0xB9D0,0xB8BB],[0xB9D1,0xB8BC],[0xB9D2,0xB8BD],[0xB9D8,0xB8BE],[0xB9D9,0xB8BF],
                    [0xB9DB,0xB8C0],[0xB9DD,0xB8C1],[0xB9DE,0xB8C2],[0xB9E1,0xB8C3],[0xB9E3,0xB8C4],
                    [0xB9E4,0xB8C5],[0xB9E5,0xB8C6],[0xB9E8,0xB8C7],[0xB9EC,0xB8C8],[0xB9F4,0xB8C9],
                    [0xB9F5,0xB8CA],[0xB9F7,0xB8CB],[0xB9F8,0xB8CC],[0xB9F9,0xB8CD],[0xB9FA,0xB8CE],
                    // 바 행
                    [0xBC14,0xB9D9],[0xBC15,0xB9DA],[0xBC16,0xB9DB],[0xBC17,0xB9DC],[0xBC18,0xB9DD],
                    [0xBC1B,0xB9DE],[0xBC1C,0xB9DF],[0xBC1D,0xB9E0],[0xBC1E,0xB9E1],[0xBC1F,0xB9E2],
                    [0xBC24,0xB9E3],[0xBC25,0xB9E4],[0xBC27,0xB9E5],[0xBC29,0xB9E6],[0xBC2D,0xB9E7],
                    [0xBC30,0xB9E8],[0xBC31,0xB9E9],[0xBC34,0xB9EA],[0xBC38,0xB9EB],[0xBC40,0xB9EC],
                    [0xBC41,0xB9ED],[0xBC43,0xB9EE],[0xBC44,0xB9EF],[0xBC45,0xB9F0],[0xBC49,0xB9F1],
                    // 사 행
                    [0xC0AC,0xBBE7],[0xC0AD,0xBBE8],[0xC0AF,0xBBE9],[0xC0B0,0xBBEA],[0xC0B3,0xBBEB],
                    [0xC0B4,0xBBEC],[0xC0B5,0xBBED],[0xC0B6,0xBBEE],[0xC0BC,0xBBEF],[0xC0BD,0xBBF0],
                    [0xC0BF,0xBBF1],[0xC0C0,0xBBF2],[0xC0C1,0xBBF3],[0xC0C5,0xBBF4],[0xC0C8,0xBBF5],
                    [0xC0C9,0xBBF6],[0xC0CC,0xBBF7],[0xC0D0,0xBBF8],[0xC0D8,0xBBF9],[0xC0D9,0xBBFA],
                    [0xC0DB,0xBBFB],[0xC0DC,0xBBFC],[0xC0DD,0xBBFD],[0xC0E4,0xBBFE],
                    // 스 (0xC2A4 -> 0xBDBA)
                    [0xC2A4,0xBDBA],
                    // 아 행
                    [0xC544,0xBEC6],[0xC545,0xBEC7],[0xC548,0xBEC8],[0xC549,0xBEC9],[0xC54A,0xBECA],
                    [0xC54C,0xBECB],[0xC54D,0xBECC],[0xC54E,0xBECD],[0xC553,0xBECE],[0xC554,0xBECF],
                    [0xC555,0xBED0],[0xC557,0xBED1],[0xC558,0xBED2],[0xC559,0xBED3],[0xC55D,0xBED4],
                    [0xC55E,0xBED5],[0xC560,0xBED6],[0xC561,0xBED7],[0xC564,0xBED8],[0xC568,0xBED9],
                    [0xC570,0xBEDA],[0xC571,0xBEDB],[0xC573,0xBEDC],[0xC574,0xBEDD],[0xC575,0xBEDE],
                    [0xC57C,0xBEDF],[0xC57D,0xBEE0],[0xC580,0xBEE1],[0xC584,0xBEE2],[0xC587,0xBEE3],
                    [0xC58C,0xBEE4],[0xC58D,0xBEE5],[0xC58F,0xBEE6],[0xC591,0xBEE7],[0xC595,0xBEE8],
                    [0xC597,0xBEE9],[0xC598,0xBEEA],[0xC59C,0xBEEB],[0xC5A0,0xBEEC],[0xC5A9,0xBEED],
                    [0xC5B4,0xBEEE],[0xC5B5,0xBEEF],[0xC5B8,0xBEF0],[0xC5B9,0xBEF1],[0xC5BB,0xBEF2],
                    [0xC5BC,0xBEF3],[0xC5BD,0xBEF4],[0xC5BE,0xBEF5],[0xC5C4,0xBEF6],[0xC5C5,0xBEF7],
                    [0xC5C6,0xBEF8],[0xC5C7,0xBEF9],[0xC5C8,0xBEFA],[0xC5C9,0xBEFB],[0xC5CA,0xBEFC],
                    [0xC5CC,0xBEFD],[0xC5CE,0xBEFE],
                    // 자 행
                    [0xC790,0xC0DA],[0xC791,0xC0DB],[0xC794,0xC0DC],[0xC796,0xC0DD],[0xC797,0xC0DE],
                    [0xC798,0xC0DF],[0xC79A,0xC0E0],[0xC7A0,0xC0E1],[0xC7A1,0xC0E2],[0xC7A3,0xC0E3],
                    [0xC7A4,0xC0E4],[0xC7A5,0xC0E5],[0xC7A6,0xC0E6],[0xC7AC,0xC0E7],[0xC7AD,0xC0E8],
                    [0xC7B0,0xC0E9],[0xC7B4,0xC0EA],[0xC7BC,0xC0EB],[0xC7BD,0xC0EC],[0xC7BF,0xC0ED],
                    [0xC7C0,0xC0EE],[0xC7C1,0xC0EF],[0xC7C8,0xC0F0],[0xC7C9,0xC0F1],[0xC7CC,0xC0F2],
                    [0xC7CE,0xC0F3],[0xC7D0,0xC0F4],[0xC7D8,0xC0F5],[0xC7DD,0xC0F6],[0xC7E4,0xC0F7],
                    [0xC7E8,0xC0F8],[0xC7EC,0xC0F9],[0xC800,0xC0FA],[0xC801,0xC0FB],[0xC804,0xC0FC],
                    [0xC808,0xC0FD],[0xC80A,0xC0FE],
                    // 차 행
                    [0xCC28,0xC2F7],[0xCC29,0xC2F8],[0xCC2C,0xC2F9],[0xCC2E,0xC2FA],[0xCC30,0xC2FB],
                    [0xCC38,0xC2FC],[0xCC39,0xC2FD],[0xCC3B,0xC2FE],
                    // 카 행
                    [0xCE74,0xC4AB],[0xCE75,0xC4AC],[0xCE78,0xC4AD],[0xCE7C,0xC4AE],[0xCE84,0xC4AF],
                    [0xCE85,0xC4B0],[0xCE87,0xC4B1],[0xCE89,0xC4B2],[0xCE90,0xC4B3],[0xCE91,0xC4B4],
                    [0xCE94,0xC4B5],[0xCE98,0xC4B6],[0xCEA0,0xC4B7],[0xCEA1,0xC4B8],[0xCEA3,0xC4B9],
                    [0xCEA4,0xC4BA],[0xCEA5,0xC4BB],[0xCEAC,0xC4BC],
                    // 타 행
                    [0xD0C0,0xC5B8],[0xD0C1,0xC5B9],[0xD0C4,0xC5BA],[0xD0C8,0xC5BB],[0xD0C9,0xC5BC],
                    [0xD0D0,0xC5BD],[0xD0D1,0xC5BE],[0xD0D3,0xC5BF],[0xD0D4,0xC5C0],[0xD0D5,0xC5C1],
                    [0xD0DC,0xC5C2],[0xD0DD,0xC5C3],[0xD0E0,0xC5C4],[0xD0E4,0xC5C5],[0xD0EC,0xC5C6],
                    [0xD0ED,0xC5C7],[0xD0EF,0xC5C8],[0xD0F0,0xC5C9],[0xD0F1,0xC5CA],
                    // 테 (0xD14C -> 0xC5D7)
                    [0xD14C,0xC5D7],
                    // 파 행
                    [0xD30C,0xC6C4],[0xD30D,0xC6C5],[0xD30E,0xC6C6],[0xD310,0xC6C7],[0xD314,0xC6C8],
                    [0xD316,0xC6C9],[0xD31C,0xC6CA],[0xD31D,0xC6CB],[0xD31F,0xC6CC],[0xD320,0xC6CD],
                    [0xD321,0xC6CE],[0xD325,0xC6CF],[0xD328,0xC6D0],[0xD329,0xC6D1],[0xD32C,0xC6D2],
                    [0xD330,0xC6D3],[0xD338,0xC6D4],[0xD339,0xC6D5],[0xD33B,0xC6D6],[0xD33C,0xC6D7],
                    [0xD33D,0xC6D8],[0xD344,0xC6D9],[0xD345,0xC6DA],[0xD37C,0xC6DB],[0xD37D,0xC6DC],
                    [0xD380,0xC6DD],[0xD384,0xC6DE],[0xD38C,0xC6DF],[0xD38D,0xC6E0],[0xD38F,0xC6E1],
                    [0xD390,0xC6E2],[0xD391,0xC6E3],[0xD398,0xC6E4],[0xD399,0xC6E5],[0xD39C,0xC6E6],
                    [0xD3A0,0xC6E7],[0xD3A8,0xC6E8],[0xD3A9,0xC6E9],[0xD3AB,0xC6EA],[0xD3AD,0xC6EB],
                    // 트 (0xD2B8 -> 0xC6AE)
                    [0xD2B8,0xC6AE],
                    // 하 행
                    [0xD558,0xC7CF],[0xD559,0xC7D0],[0xD55C,0xC7D1],[0xD560,0xC7D2],[0xD565,0xC7D3],
                    [0xD568,0xC7D4],[0xD569,0xC7D5],[0xD56B,0xC7D6],[0xD56D,0xC7D7],[0xD574,0xC7D8],
                    [0xD575,0xC7D9],[0xD578,0xC7DA],[0xD57C,0xC7DB],[0xD584,0xC7DC],[0xD585,0xC7DD],
                    [0xD587,0xC7DE],[0xD588,0xC7DF],[0xD589,0xC7E0],[0xD590,0xC7E1],[0xD5A5,0xC7E2],
                    [0xD5C8,0xC7E3],[0xD5C9,0xC7E4],[0xD5CC,0xC7E5],[0xD5D0,0xC7E6],[0xD5D2,0xC7E7],
                    [0xD5D8,0xC7E8],[0xD5D9,0xC7E9],[0xD5DB,0xC7EA],[0xD5DD,0xC7EB],[0xD5E4,0xC7EC],
                    [0xD5E5,0xC7ED],[0xD5E8,0xC7EE],[0xD5EC,0xC7EF],[0xD5F4,0xC7F0],[0xD5F5,0xC7F1],
                    [0xD5F7,0xC7F2],[0xD5F9,0xC7F3],[0xD600,0xC7F4],[0xD601,0xC7F5],[0xD604,0xC7F6],
                    [0xD608,0xC7F7],[0xD610,0xC7F8],[0xD611,0xC7F9],[0xD613,0xC7FA],[0xD614,0xC7FB],
                    [0xD615,0xC7FC],[0xD61C,0xC7FD],[0xD620,0xC7FE],
                    // 호 행
                    [0xD638,0xC8A3],[0xD639,0xC8A4],[0xD63C,0xC8A5],[0xD640,0xC8A6],[0xD645,0xC8A7],
                    [0xD648,0xC8A8],[0xD649,0xC8A9],[0xD64B,0xC8AA],[0xD64D,0xC8AB],[0xD651,0xC8AC],
                    [0xD654,0xC8AD],[0xD655,0xC8AE],[0xD658,0xC8AF],[0xD65C,0xC8B0],[0xD667,0xC8B1],
                    [0xD669,0xC8B2],[0xD670,0xC8B3],[0xD671,0xC8B4],[0xD674,0xC8B5],[0xD683,0xC8B6],
                    [0xD685,0xC8B7],[0xD68C,0xC8B8],[0xD68D,0xC8B9],[0xD690,0xC8BA],[0xD694,0xC8BB],
                    [0xD69D,0xC8BC],[0xD69F,0xC8BD],[0xD6A1,0xC8BE],[0xD6A8,0xC8BF],[0xD6AC,0xC8C0],
                    [0xD6B0,0xC8C1],[0xD6B9,0xC8C2],[0xD6BB,0xC8C3],[0xD6C4,0xC8C4],[0xD6C5,0xC8C5],
                    [0xD6C8,0xC8C6],[0xD6CC,0xC8C7],[0xD6D1,0xC8C8],[0xD6D4,0xC8C9],[0xD6D7,0xC8CA],
                    [0xD6D9,0xC8CB],[0xD6E0,0xC8CC],[0xD6E4,0xC8CD],[0xD6E8,0xC8CE],[0xD6F0,0xC8CF],
                    [0xD6F5,0xC8D0],[0xD6FC,0xC8D1],[0xD6FD,0xC8D2],[0xD700,0xC8D3],[0xD704,0xC8D4],
                    [0xD711,0xC8D5],[0xD718,0xC8D6],[0xD719,0xC8D7],[0xD71C,0xC8D8],[0xD720,0xC8D9],
                    [0xD728,0xC8DA],[0xD729,0xC8DB],[0xD72B,0xC8DC],[0xD72D,0xC8DD],[0xD734,0xC8DE],
                    [0xD735,0xC8DF],[0xD738,0xC8E0],[0xD73C,0xC8E1],[0xD744,0xC8E2],[0xD747,0xC8E3],
                    [0xD749,0xC8E4],[0xD750,0xC8E5],[0xD751,0xC8E6],[0xD754,0xC8E7],[0xD756,0xC8E8],
                    [0xD757,0xC8E9],[0xD758,0xC8EA],[0xD759,0xC8EB],[0xD760,0xC8EC],[0xD761,0xC8ED],
                    [0xD763,0xC8EE],[0xD765,0xC8EF],[0xD769,0xC8F0],[0xD76C,0xC8F1],[0xD770,0xC8F2],
                    [0xD774,0xC8F3],[0xD77C,0xC8F4],[0xD77D,0xC8F5],[0xD781,0xC8F6],[0xD788,0xC8F7],
                    [0xD789,0xC8F8],[0xD78C,0xC8F9],[0xD790,0xC8FA],[0xD798,0xC8FB],[0xD799,0xC8FC],
                    [0xD79B,0xC8FD],[0xD79D,0xC8FE],
                    // 추가 자주 사용 한글
                    [0xC138,0xBCBC], // 세
                    [0xC694,0xBFE4], // 요
                    [0xC548,0xBEC8], // 안
                    [0xB155,0xB3E7], // 녕
                    [0xC785,0xC0D4], // 입
                    [0xB825,0xB7C2], // 력
                    [0xAE40,0xB1E8], // 김
                    [0xCCA0,0xC3B6], // 철
                    [0xC218,0xBCF6], // 수
                    [0xD55C,0xC7D1], // 한
                    [0xAE00,0xB1DB], // 글
                    [0xD64D,0xC8AB], // 홍
                    [0xAE38,0xB1E6], // 길
                    [0xB3D9,0xB5BF], // 동
                    [0xBE44,0xBEE4], // 비
                    [0xACE0,0xB0ED], // 고
                    [0xC601,0xBFB5], // 영
                    [0xD76C,0xC8F1], // 희
                    [0xC131,0xBCBA], // 성
                    [0xC774,0xC0CC], // 이
                    [0xBC15,0xB9DA], // 박
                    [0xCD5C,0xC3D6], // 최
                    [0xC815,0xC0A4], // 정
                    [0xC870,0xC1B6], // 조
                    [0xC724,0xC0B1], // 윤
                    [0xC7A5,0xC0E5], // 장
                    [0xC784,0xC0D3], // 임
                    [0xD55C,0xC7D1], // 한
                    [0xC624,0xBFEC], // 오
                    [0xC11C,0xBCB3], // 서
                    [0xC2E0,0xBDC5], // 신
                    [0xAD8C,0xB1C7], // 권
                    [0xD669,0xC8B2], // 황
                    [0xC1A1,0xBCF1], // 송
                    [0xC548,0xBEC8], // 안
                    [0xC720,0xC0AF], // 유
                    [0xC704,0xC0A7], // 위
                    [0xBBFC,0xB9CE]  // 민
                ];
                
                // 테이블 구축
                for (let i = 0; i < mappingData.length; i++) {
                    this._kscTable[mappingData[i][0]] = mappingData[i][1];
                }
            },

            /**
             * FULL 타입 필드의 패딩 처리 (바이트 단위)
             * @param {string} value - 입력값
             * @param {number} byteSize - 목표 바이트 크기
             * @returns {string} 패딩된 Latin1 문자열
             */
            padToByteSize: function(value, byteSize) {
                const encoded = this.encodeToString(value);
                const currentByteLength = encoded.length;
                
                if (currentByteLength > byteSize) {
                    // 바이트 단위로 자르기 (2바이트 단위로 정렬)
                    return this.truncateToByteSize(value, byteSize);
                }
                
                if (currentByteLength < byteSize) {
                    // 우측 전각 공백 패딩 (0xA1A1 = 2바이트)
                    // 전각 공백: String.fromCharCode(0xA1, 0xA1)
                    const fullwidthSpace = String.fromCharCode(0xA1) + String.fromCharCode(0xA1);
                    const remainingBytes = byteSize - currentByteLength;
                    const paddingCount = Math.floor(remainingBytes / 2);
                    let result = encoded;
                    
                    for (let i = 0; i < paddingCount; i++) {
                        result += fullwidthSpace;
                    }
                    
                    // 홀수 바이트가 남으면 반각 공백으로 채움 (비정상 케이스)
                    if (remainingBytes % 2 === 1) {
                        result += ' ';
                    }
                    
                    return result;
                }
                
                return encoded;
            },

            /**
             * 바이트 크기로 문자열 자르기 (2바이트 경계 유지)
             * @param {string} str - 원본 문자열
             * @param {number} maxBytes - 최대 바이트 수
             * @returns {string} 잘린 Latin1 문자열
             */
            truncateToByteSize: function(str, maxBytes) {
                // 2바이트 경계로 조정 (짝수로 내림)
                const adjustedMaxBytes = Math.floor(maxBytes / 2) * 2;
                
                let result = '';
                let currentBytes = 0;
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    const encoded = this.encodeToString(char);
                    const charBytes = encoded.length; // 항상 2바이트
                    
                    if (currentBytes + charBytes > adjustedMaxBytes) {
                        break;
                    }
                    
                    result += encoded;
                    currentBytes += charBytes;
                }
                
                return result;
            }
        };

        /**
         * =====================================================
         * 구조체 카드 생성 함수
         * 구조체 입력을 위한 카드 DOM 요소 생성
         * - 접기/펼치기 기능 지원
         * - 드래그 앤 드롭 재정렬 지원
         * =====================================================
         * @param {number} index - 구조체 인덱스 번호
         * @returns {HTMLElement} div.struct-card DOM 요소
         */
        function createStructCard(index) {
            // 1. div 생성, class="struct-card", data-index="${index}"
            const div = document.createElement('div');
            div.className = 'struct-card';
            div.setAttribute('data-index', index);
            div.setAttribute('draggable', 'true'); // 드래그 앤 드롭 활성화

            // 2. 내부 HTML 설정 (접기/펼치기 아이콘 및 드래그 핸들 포함)
            div.innerHTML = `
                <div class="struct-card-header">
                    <div class="struct-header-left">
                        <span class="collapse-icon">▼</span>
                        <span class="struct-number">구조체 #${index + 1}</span>
                        <span class="struct-preview"></span>
                    </div>
                    <div class="struct-card-header-actions">
                        <span class="drag-handle" title="드래그하여 순서 변경">⋮⋮</span>
                        <button class="remove-struct-btn" data-index="${index}">✕ 삭제</button>
                    </div>
                </div>
                
                <div class="struct-card-body">
                    <div class="input-row">
                        <label>구조체명 (선택)</label>
                        <input type="text" class="struct-name" placeholder="예: DHF_H, HeaderRecord" />
                    </div>
                    
                    <div class="input-row">
                        <label>구분값 (선택)</label>
                        <input type="text" class="struct-kubun" maxlength="5" placeholder="예: H, 01, HEADER" />
                        <small>여러 구조체 사용 시 필수. 데이터 첫 글자로 구조체 식별</small>
                    </div>
                    
                    <div class="input-row">
                        <label>구조체 정의</label>
                        <textarea class="struct-definition" rows="8" placeholder="typedef struct { ... } 구조체명;"></textarea>
                    </div>
                </div>
            `;

            // 3. 요소 반환
            return div;
        }

        /**
         * =====================================================
         * XML 규격 파싱 함수
         * XML 문자열을 파싱하여 col 요소 배열로 변환
         * =====================================================
         * @param {string} xmlString - XML 규격 문자열
         * @returns {Array|null} col 요소 배열 또는 null (에러 시)
         */
        function parseXMLSpec(xmlString) {
            // 입력값 유효성 검사
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: 입력값이 문자열이 아닙니다.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: 빈 문자열이 입력되었습니다.');
                return null;
            }

            // DOMParser를 사용해 XML 문서로 변환
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML 파싱 오류:', e.message);
                return null;
            }

            // parsererror 체크
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML 파싱 오류:', parseError.textContent);
                return null;
            }

            // 모든 col 요소 선택
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col 요소를 찾을 수 없습니다.');
                return [];
            }

            // 유효한 col 요소들을 담을 배열
            const result = [];

            // 각 col 요소 처리
            colElements.forEach((col, index) => {
                // 속성 추출
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // 필수 속성 검증
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소에 필수 속성이 누락되었습니다: ${missingAttrs.join(', ')}`
                    );
                    return; // 해당 요소 건너뛰기
                }

                // size를 정수로 변환
                const size = parseInt(sizeAttr, 10);

                // size가 유효한 정수인지 검증
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소의 size 속성이 유효한 숫자가 아닙니다: "${sizeAttr}"`
                    );
                    return; // 해당 요소 건너뛰기
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소의 size 속성이 음수입니다: ${size}`
                    );
                    return; // 해당 요소 건너뛰기
                }

                // 유효한 col 정보를 결과 배열에 추가
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        /**
         * =====================================================
         * 통전문 파싱 함수
         * 통전문 문자열을 XML 규격에 맞게 분리
         * =====================================================
         * @param {string} telegramString - 통전문 문자열
         * @param {Array} xmlSpec - parseXMLSpec의 결과 배열
         * @returns {Array} 파싱된 결과 배열
         */
        /**
         * 입력 데이터가 이미 KSC-5601로 인코딩된 Latin1인지 유니코드인지 감지
         * @param {string} str - 검사할 문자열
         * @returns {boolean} true면 Latin1 (이미 인코딩됨), false면 유니코드
         */
        function isLatin1Encoded(str) {
            // 문자열 내 모든 문자가 0x00-0xFF 범위인지 확인
            for (let i = 0; i < str.length; i++) {
                if (str.charCodeAt(i) > 0xFF) {
                    return false; // 유니코드 문자 발견
                }
            }
            return true;
        }

        /**
         * 유니코드 문자열을 KSC-5601 인코딩된 Latin1 문자열로 변환
         * FULL 타입이 아닌 필드는 그대로 유지, FULL 타입만 변환
         * @param {string} telegramString - 원본 통전문
         * @param {Array} xmlSpec - XML 규격 배열
         * @returns {string} 변환된 통전문 (Latin1)
         */
        function convertToKSC5601Telegram(telegramString, xmlSpec) {
            let result = '';
            let unicodePos = 0;
            
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];
                
                if (spec.type === 'FULL') {
                    // FULL 타입: 유니코드 문자를 KSC-5601 바이트로 변환
                    // 바이트 크기 / 2 = 문자 수 (모든 문자가 2바이트)
                    const charCount = Math.floor(spec.size / 2);
                    const unicodeValue = telegramString.substring(unicodePos, unicodePos + charCount);
                    
                    // KSC-5601로 인코딩 후 패딩
                    const encoded = KSC5601.padToByteSize(unicodeValue, spec.size);
                    result += encoded;
                    
                    unicodePos += unicodeValue.length;
                } else {
                    // 일반 타입: 그대로 추출
                    const value = telegramString.substring(unicodePos, unicodePos + spec.size);
                    result += value;
                    unicodePos += spec.size;
                }
            }
            
            return result;
        }

        function parseTelegram(telegramString, xmlSpec) {
            // 현재 위치 초기화
            let currentPos = 0;

            // 빈 결과 배열 생성
            const result = [];
            
            // 입력 데이터가 유니코드인지 이미 인코딩된 Latin1인지 감지
            const isEncoded = isLatin1Encoded(telegramString);
            
            // 유니코드 입력인 경우 FULL 타입 필드가 있으면 변환 필요
            let processedTelegram = telegramString;
            const hasFullType = xmlSpec.some(spec => spec.type === 'FULL');
            
            if (!isEncoded && hasFullType) {
                // 유니코드 입력 + FULL 타입 존재: 변환 수행
                processedTelegram = convertToKSC5601Telegram(telegramString, xmlSpec);
                console.log('parseTelegram: 유니코드 입력을 KSC-5601로 변환했습니다.');
            }

            // xmlSpec 배열 순회
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // 시작/종료 위치 계산
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substring으로 값 추출 (인덱스 범위 초과해도 오류 없이 처리됨)
                const value = processedTelegram.substring(startPos, endPos);

                // 결과 배열에 추가
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // 현재 위치 이동
                currentPos += spec.size;
            }

            // 통전문 전체 길이와 예상 길이 비교
            if (processedTelegram.length !== currentPos) {
                console.warn(
                    `parseTelegram: 통전문 길이(${processedTelegram.length})와 예상 길이(${currentPos})가 일치하지 않습니다.`
                );
            }

            return result;
        }

        /**
         * =====================================================
         * 값 패딩 함수
         * 값을 지정된 크기에 맞게 패딩 (공백으로 채움)
         * =====================================================
         * @param {string} value - 패딩할 값
         * @param {number} size - 목표 크기
         * @param {string} fieldName - 필드명 (로깅용)
         * @returns {string} 패딩된 값
         */
        function padValue(value, size, fieldName) {
            // 값이 없으면 빈 문자열로 설정
            if (value === null || value === undefined) {
                value = '';
            }
            
            // 문자열로 변환
            value = String(value);
            
            // 값이 크기보다 크면 자르기
            if (value.length > size) {
                console.warn('padValue: 필드 "' + fieldName + '"의 값이 크기(' + size + ')를 초과합니다. 값을 자릅니다.');
                return value.substring(0, size);
            }
            
            // 값이 크기보다 작으면 패딩
            if (value.length < size) {
                // 숫자 필드: 좌측 0 패딩
                if (isNumericField(fieldName)) {
                    return value.padStart(size, '0');
                }
                // 문자 필드: 우측 공백 패딩
                return value.padEnd(size, ' ');
            }
            
            // 정확히 일치
            return value;
        }

        /**
         * =====================================================
         * 통전문 생성 함수 (29단계)
         * 필드 배열을 받아서 통전문 문자열 생성
         * CRLF 필드는 개행 인식 옵션에 따라 자동 처리
         * =====================================================
         * @param {Array} fields - 필드 배열 [{name, value, size}, ...]
         * @returns {string} 생성된 통전문 문자열
         */
        function generateTelegram(fields) {
            // 개행문자 인식 옵션 확인
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // 결과 통전문 문자열
            let telegram = '';
            
            // 각 필드 처리
            for (let i = 0; i < fields.length; i++) {
                const field = fields[i];
                
                // CRLF 필드 여부 확인
                if (field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                    // CRLF 필드 자동 처리
                    if (recognizeCRLF) {
                        telegram += '\r\n';  // 무조건 CRLF
                    } else {
                        // 개행 인식 비활성화 시에도 필드는 채워야 함
                        telegram += '  ';    // 공백 2개
                        console.warn('CRLF 필드를 공백으로 채웁니다 (개행 인식 비활성화됨)');
                    }
                } else {
                    // 일반 필드 처리
                    telegram += padValue(field.value, field.size, field.name);
                }
            }
            
            return telegram;
        }

        /**
         * =====================================================
         * C 구조체 정의 파싱 함수
         * 구조체 정의 문자열을 파싱하여 구조체 배열로 변환
         * =====================================================
         * @param {string} structText - C 구조체 정의 문자열
         * @returns {Array|null} 구조체 배열 또는 null (에러 시)
         */
        function parseStructDefinitions(structText) {
            // 입력값 유효성 검사
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 주석 제거 처리 - 캐시된 정규식 사용
            let cleanedText = structText.replace(getRegex('singleLineComment'), '');
            cleanedText = cleanedText.replace(getRegex('blockComment'), '');

            // 2. typedef struct 블록 추출 - 캐시된 정규식 사용
            const structPattern = getRegex('structPattern');
            
            // 타입별 크기 정의 (바이트)
            const typeSizes = {
                'char': 1,
                'unsigned char': 1,
                'short': 2,
                'unsigned short': 2,
                'int': 4,
                'unsigned int': 4,
                'long': 4,
                'unsigned long': 4
            };
            
            // 결과 배열
            const result = [];
            
            // typedef struct 블록들 추출
            let structMatch;
            while ((structMatch = structPattern.exec(cleanedText)) !== null) {
                const fieldsContent = structMatch[2]; // 중괄호 안의 내용
                const structName = structMatch[3];    // typedef 구조체명 (마지막 이름)
                
                // 필드 배열
                const fields = [];
                
                // 필드들 추출 - 새로운 정규식 인스턴스 사용
                const fieldPattern = getRegex('fieldPattern');
                let fieldMatch;
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    const unsignedPrefix = fieldMatch[1] ? fieldMatch[1].trim() : '';
                    const baseType = fieldMatch[2];
                    const fieldName = fieldMatch[3];
                    const arraySize = parseInt(fieldMatch[4], 10);
                    
                    // 전체 타입명 구성
                    const fullType = unsignedPrefix ? unsignedPrefix + ' ' + baseType : baseType;
                    
                    // 타입별 크기 계산
                    let typeSize = typeSizes[fullType] || typeSizes[baseType] || 1;
                    
                    // char 외의 타입은 경고 출력 (하지만 char 기준으로 처리)
                    if (baseType !== 'char') {
                        console.warn('parseStructDefinitions: "' + structName + '"의 필드 "' + fieldName + '"의 타입 "' + fullType + '"은 char로 처리됩니다. 크기 계산이 정확하지 않을 수 있습니다.');
                        // char 기준으로 처리 (배열 크기만 사용)
                        typeSize = 1;
                    }
                    
                    fields.push({
                        name: fieldName,
                        type: fullType,
                        size: arraySize * typeSize
                    });
                }
                
                // 빈 구조체 검증 - fields가 0개인 구조체는 제외
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: 구조체 "' + structName + '"에 유효한 필드가 없어 제외됩니다.');
                    continue;
                }
                
                // 구조체 객체 추가
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // 구조체가 하나도 없으면 null 반환
            if (result.length === 0) {
                console.error('parseStructDefinitions: 파싱된 구조체가 없습니다.');
                return null;
            }
            
            // 파싱된 구조체 개수 출력
            console.log('parseStructDefinitions: ' + result.length + '개의 구조체가 파싱되었습니다.');
            
            return result;
        }

        /**
         * =====================================================
         * 단일 C 구조체 정의 파싱 함수
         * 하나의 구조체 정의 문자열을 파싱하여 필드 배열로 변환
         * char 타입만 지원 (unsigned char도 char로 처리)
         * =====================================================
         * @param {string} structText - 단일 C 구조체 정의 문자열
         * @returns {Object|null} { fields: [...], totalSize: number } 또는 null (에러 시)
         */
        function parseStructDefinition(structText) {
            // 입력값 유효성 검사
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinition: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 주석 제거
            // // 주석 제거
            let cleanedText = structText.replace(/\/\/.*$/gm, '');
            // /* */ 주석 제거
            cleanedText = cleanedText.replace(/\/\*[\s\S]*?\*\//g, '');

            // 2. 필드 추출 정규식
            // char 또는 unsigned char 타입의 배열 필드 매칭
            // unsigned char도 char로 처리
            const fieldPattern = /char\s+(\w+)\s*\[\s*(\d+)\s*\]/g;

            // 3. matchAll로 모든 매칭 결과 순회
            const matches = cleanedText.matchAll(fieldPattern);
            const fields = [];

            for (const match of matches) {
                const fieldName = match[1];
                const size = parseInt(match[2], 10);

                // 필드 정보를 fields 배열에 추가
                fields.push({
                    name: fieldName,
                    size: size
                });
            }

            // 4. fields가 비어있으면 null 반환
            if (fields.length === 0) {
                console.error('parseStructDefinition: 유효한 필드가 없습니다.');
                return null;
            }

            // 5. 총 크기 계산
            const totalSize = fields.reduce((sum, f) => sum + f.size, 0);

            // 6. 결과 반환
            return { fields, totalSize };
        }

        /**
         * =====================================================
         * 구조체 정의 수집 함수
         * 모든 구조체 카드에서 정의를 수집하여 배열로 반환
         * =====================================================
         * @returns {Array|null} 구조체 정보 배열 또는 null (에러 시)
         */
        function collectStructDefinitions() {
            // 1. 모든 .struct-card 요소 선택
            const cards = document.querySelectorAll('.struct-card');

            // 2. 빈 배열 structDefs = []
            const structDefs = [];

            // 3. 각 카드마다 처리
            for (let index = 0; index < cards.length; index++) {
                const card = cards[index];

                // a. .struct-name 값 가져오기 (trim)
                const structNameInput = card.querySelector('.struct-name');
                const structName = structNameInput ? structNameInput.value.trim() : '';

                // b. .struct-kubun 값 가져오기 (trim)
                const kubunInput = card.querySelector('.struct-kubun');
                const kubunValue = kubunInput ? kubunInput.value.trim() : '';

                // c. .struct-definition 값 가져오기 (trim)
                const definitionInput = card.querySelector('.struct-definition');
                const definitionText = definitionInput ? definitionInput.value.trim() : '';

                // d. 구조체 정의가 비어있으면 해당 카드 건너뛰기
                if (definitionText === '') {
                    continue;
                }

                // e. parseStructDefinition(정의 텍스트) 호출
                const parsed = parseStructDefinition(definitionText);

                // f. 파싱 성공 시 structDefs에 추가
                if (parsed !== null) {
                    // CRLF 필드 존재 확인
                    const hasCRLFField = parsed.fields.some(function(f) {
                        return f.name.toLowerCase().match(/crlf|cr_lf|newline/);
                    });
                    
                    // 옵션과 일치 여부 확인
                    const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                    const currentName = structName || ('구조체' + (index + 1));
                    
                    if (recognizeCRLF && !hasCRLFField) {
                        console.warn('구조체 "' + currentName + '": 개행 인식 활성화되었으나 crlf 필드 없음');
                    }
                    
                    if (!recognizeCRLF && hasCRLFField) {
                        console.warn('구조체 "' + currentName + '": crlf 필드가 있으나 개행 인식 비활성화됨');
                    }
                    
                    structDefs.push({
                        name: currentName,
                        kubun: kubunValue || null,
                        fields: parsed.fields,
                        totalSize: parsed.totalSize,
                        hasCRLFField: hasCRLFField
                    });
                } else {
                    // g. 파싱 실패 시 에러 표시 후 null 반환
                    displayError('구조체 #' + (index + 1) + ' 파싱 실패', 'struct-result-container');
                    return null;
                }
            }

            // 4. structDefs가 비어있으면 에러 표시 후 null 반환
            if (structDefs.length === 0) {
                displayError('유효한 구조체가 없습니다', 'struct-result-container');
                return null;
            }

            // 5. 입력 검증 강화
            for (let i = 0; i < structDefs.length; i++) {
                const def = structDefs[i];
                
                // 구조체명에 특수문자 있으면 경고 (영문, 숫자, 언더스코어만 허용)
                if (def.name && !/^[a-zA-Z0-9_가-힣]+$/.test(def.name)) {
                    console.warn('collectStructDefinitions: 구조체 "' + def.name + '"의 이름에 특수문자가 포함되어 있습니다. 예상치 못한 동작이 발생할 수 있습니다.');
                }
                
                // 구분값이 너무 길면 (10자 이상) 경고
                if (def.kubun && def.kubun.length >= 10) {
                    console.warn('collectStructDefinitions: 구조체 "' + def.name + '"의 구분값이 ' + def.kubun.length + '자로 너무 깁니다. 10자 미만을 권장합니다.');
                }
            }

            // 6. 구분값 검증
            if (structDefs.length >= 2) {
                // 구조체가 2개 이상인데 kubun이 null인 것이 있으면 경고
                const hasNullKubun = structDefs.some(function(def) {
                    return def.kubun === null;
                });
                
                if (hasNullKubun) {
                    console.warn('collectStructDefinitions: 여러 구조체 중 구분값이 없는 것이 있습니다. 데이터 매칭이 정확하지 않을 수 있습니다.');
                }

                // 중복된 kubun 값이 있으면 에러
                const kubunValues = structDefs
                    .filter(function(def) { return def.kubun !== null; })
                    .map(function(def) { return def.kubun; });
                
                const duplicates = kubunValues.filter(function(value, idx, arr) {
                    return arr.indexOf(value) !== idx;
                });

                if (duplicates.length > 0) {
                    displayError('중복된 구분값이 있습니다: ' + duplicates.join(', '), 'struct-result-container');
                    return null;
                }

                // 구분값 길이 일관성 검사 (모두 같은 길이 권장)
                const kubunLengths = kubunValues.map(function(k) { return k.length; });
                const uniqueLengths = kubunLengths.filter(function(len, idx, arr) {
                    return arr.indexOf(len) === idx;
                });
                
                if (uniqueLengths.length > 1) {
                    console.warn('collectStructDefinitions: 구분값 길이가 일관되지 않습니다. 길이: ' + uniqueLengths.join(', ') + '. 모두 같은 길이로 통일하는 것을 권장합니다.');
                }
            }

            // 7. structDefs 반환
            console.log('collectStructDefinitions: ' + structDefs.length + '개의 구조체가 수집되었습니다.');
            return structDefs;
        }

        /**
         * =====================================================
         * kubun 기반 구조체 찾기 함수
         * 데이터의 첫 부분을 kubun 값과 비교하여 구조체 탐색
         * =====================================================
         * @param {string} data - 현재 위치부터의 데이터
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object|null} 매칭된 구조체 또는 null
         */
        function findStructByKubun(data, structDefs) {
            // 입력값 유효성 검사
            if (!data || !Array.isArray(structDefs) || structDefs.length === 0) {
                return null;
            }

            // 1. kubun이 null이 아닌 구조체들을 순회하며 매칭 시도
            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];
                const kubun = structDef.kubun;

                // kubun이 null이면 건너뛰기
                if (kubun === null || kubun === undefined) {
                    continue;
                }

                // kubun 길이만큼 data에서 추출하여 비교
                const kubunLength = kubun.length;
                const dataKubun = data.substring(0, kubunLength);

                // 매칭되면 해당 구조체 반환
                if (dataKubun === kubun) {
                    return structDef;
                }
            }

            // 2. 모두 실패 시 kubun이 null인 구조체 반환 (fallback)
            for (let i = 0; i < structDefs.length; i++) {
                if (structDefs[i].kubun === null || structDefs[i].kubun === undefined) {
                    return structDefs[i];
                }
            }

            // 3. fallback도 없으면 null 반환
            return null;
        }

        /**
         * =====================================================
         * 매칭 구조체 찾기 함수
         * 데이터 라인의 첫 글자로 매칭되는 구조체 탐색
         * =====================================================
         * @param {string} line - 데이터 라인
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object|null} 매칭된 구조체 또는 null
         */
        function findMatchingStruct(line, structDefs) {
            // 입력값 유효성 검사
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 구조체가 1개만 있으면 그것 반환
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. 여러 개일 경우 매칭 로직
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // 필드가 없으면 건너뛰기
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // 첫 번째 필드의 size만큼 line에서 추출
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // 구조체명에서 구분 패턴 추출
                // 예: DHF_H → 'H', DHF_D → 'D', ST_HEADER_1 → '1'
                const structName = structDef.name;
                
                // 구조체명 마지막 부분 추출 (언더스코어 뒤 또는 마지막 문자/숫자)
                let structIdentifier = '';
                
                // 언더스코어로 분리하여 마지막 부분 추출
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // 마지막 부분이 단일 문자 또는 숫자인 경우
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // 마지막 부분에서 숫자 추출 시도 - 캐시된 정규식 사용
                    const numMatch = lastPart.match(getRegex('trailingNumber'));
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // 마지막 문자 사용
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // 구조체명 마지막 문자/숫자와 line 첫 문자 비교
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // 첫 필드 값과 구조체 식별자 비교
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. 매칭 실패 시 null 반환, 콘솔에 경고
            console.warn('findMatchingStruct: 라인 "' + line.substring(0, 20) + '..."에 매칭되는 구조체를 찾을 수 없습니다.');
            return null;
        }

        /**
         * =====================================================
         * 구조체 데이터 파싱 함수 (메인 진입점)
         * =====================================================
         * 
         * [기능 설명]
         * 개행문자 인식 옵션(recognize-crlf)에 따라 파싱 모드를 결정합니다.
         * 
         * [파싱 모드]
         * 1. 라인 기반 파싱 (개행 인식 ON)
         *    - 각 줄을 독립적인 레코드로 처리
         *    - 줄 끝에 CRLF(2 bytes) 자동 추가
         *    - 길이 부족 시 다음 라인 침범 안 함
         * 
         * 2. 연속 데이터 파싱 (개행 인식 OFF)
         *    - 모든 줄바꿈 제거 후 연속 데이터로 처리
         *    - 구분값(kubun) 기반으로 레코드 분리
         *    - CRLF 필드 없는 구조체 사용
         * 
         * @param {string} dataText - 파싱할 통 데이터 텍스트
         * @param {Array} structDefs - 구조체 정의 배열 [{name, kubun, fields, totalSize}, ...]
         * @returns {Object} 파싱 결과
         *   - records: 파싱된 레코드 배열
         *   - stats: 통계 정보 {totalBytes, parsedBytes, recordCount, errorBytes, mode}
         */
        function parseStructData(dataText, structDefs) {
            // 입력값 유효성 검사
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: 데이터 텍스트가 유효하지 않습니다.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: 구조체 정의가 유효하지 않습니다.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            // 1. 옵션 읽기
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // 2. 데이터 전처리 및 파싱 분기
            if (recognizeCRLF) {
                // === 라인 기반 파싱 ===
                return parseLineByLine(dataText, structDefs);
            } else {
                // === 연속 데이터 파싱 ===
                return parseContinuous(dataText, structDefs);
            }
        }

        /**
         * =====================================================
         * 라인 기반 파싱 함수 (개행 인식 ON 모드)
         * =====================================================
         * 
         * [처리 흐름]
         * 1. 이스케이프 처리 (\\r\\n → \r\n)
         * 2. 줄 단위 분리 (CRLF/LF 기준)
         * 3. 각 라인별 구조체 매칭 (구분값 기반)
         * 4. 필드별 데이터 추출
         * 5. 길이 검증 (부족/초과 시 경고)
         * 
         * [특징]
         * - 각 라인은 독립적으로 처리 (다음 라인 침범 안 함)
         * - 라인 끝에 CRLF(2 bytes) 자동 추가됨
         * - 매칭 실패 시 에러 레코드로 기록
         * - 길이 부족 시 경고만 표시하고 파싱은 진행
         * 
         * [에러 처리]
         * - 구조체 매칭 실패: 에러 레코드 생성, 다음 라인으로 진행
         * - 길이 부족/초과: 콘솔 경고, 가능한 만큼 파싱
         * 
         * @param {string} dataText - 통 데이터 텍스트 (줄바꿈 포함)
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object} { records: [...], stats: {...} } 형식의 파싱 결과
         */
        function parseLineByLine(dataText, structDefs) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            
            // 1. 이스케이프 처리
            let processedText = dataText
                .replace(/\\r\\n/g, '\r\n')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r');

            // 2. 줄 단위로 분리
            const lines = processedText.split(/\r?\n/)
                .map(line => line.trimEnd())  // 우측 공백만 제거
                .filter(line => line.length > 0);  // 빈 줄 제거

            console.log(`라인 기반 파싱: 총 ${lines.length}개 라인`);
            
            // 디버그 모드: 초기 정보 로깅
            if (isDebugMode) {
                console.group('🔍 파싱 디버그 - Line By Line 모드');
                console.log('📋 모드:', 'line-by-line');
                console.log('📊 전체 라인 수:', lines.length);
                console.log('📐 정의된 구조체:', structDefs.map(s => `${s.name}(구분값:${s.kubun})`).join(', '));
                console.log('---');
                
                lines.forEach((line, i) => {
                    console.log(`📝 라인 ${i+1}:`, {
                        length: line.length,
                        kubun: line[0] || '(없음)',
                        preview: line.substring(0, 30) + (line.length > 30 ? '...' : ''),
                        hex: Array.from(line.substring(0, 10)).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ')
                    });
                });
                console.log('---');
            }

            // 3. 변수 초기화
            const records = [];
            let recordIndex = 0;
            let totalBytes = 0;
            let parsedBytes = 0;
            let errorLines = 0;

            // 4. 각 라인 순회
            lines.forEach((line, lineIndex) => {
                totalBytes += line.length + 2;  // +2 for CRLF

                // 구조체 매칭
                const matched = findStructByKubun(line, structDefs);

                if (!matched) {
                    console.warn(`라인 ${lineIndex + 1}: 매칭 실패 - "${line.substring(0, 20)}..."`);
                    errorLines++;
                    
                    // 디버그: 매칭 실패 상세 정보
                    if (isDebugMode) {
                        console.warn(`  ❌ 구분값 '${line[0]}'에 해당하는 구조체 없음`);
                        console.warn(`  📋 등록된 구분값들:`, structDefs.map(s => s.kubun));
                    }

                    // 에러 레코드 추가
                    records.push({
                        error: true,
                        lineNumber: lineIndex + 1,
                        lineData: line,
                        message: '매칭되는 구조체 없음'
                    });
                    return;  // 다음 라인으로
                }

                // 디버그: 매칭된 구조체 정보
                if (isDebugMode) {
                    console.group(`✅ 라인 ${lineIndex + 1} → ${matched.name}`);
                    console.log('📌 구분값:', matched.kubun);
                    console.log('📏 필드 수:', matched.fields.length);
                }

                // 길이 검증
                const expectedSize = matched.totalSize;
                const actualSize = line.length + 2;  // CRLF 포함

                // 디버그: 길이 비교
                if (isDebugMode) {
                    const lengthStatus = actualSize === expectedSize ? '✅ 일치' : 
                                        actualSize < expectedSize ? '⚠️ 부족' : '⚠️ 초과';
                    console.log(`📐 길이 비교: 예상=${expectedSize}, 실제=${actualSize} ${lengthStatus}`);
                }

                if (actualSize < expectedSize) {
                    console.warn(
                        `라인 ${lineIndex + 1}: 길이 부족 ` +
                        `(예상: ${expectedSize}, 실제: ${actualSize})`
                    );
                } else if (actualSize > expectedSize) {
                    console.warn(
                        `라인 ${lineIndex + 1}: 길이 초과 ` +
                        `(예상: ${expectedSize}, 실제: ${actualSize})`
                    );
                }

                // 라인 데이터에 CRLF 추가
                const lineWithCRLF = line + '\r\n';

                // 필드별 파싱
                let fieldOffset = 0;
                
                // 디버그: 필드 파싱 시작
                if (isDebugMode) {
                    console.log('📋 필드별 추출:');
                }
                
                matched.fields.forEach(field => {
                    const startPos = fieldOffset;
                    const endPos = startPos + field.size;
                    const value = lineWithCRLF.substring(startPos, endPos);
                    
                    // 디버그: 각 필드 값 로깅
                    if (isDebugMode) {
                        const hexValue = Array.from(value).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
                        const displayValue = value.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                        console.log(`  📍 ${field.name}[${field.size}]: "${displayValue}" | HEX: ${hexValue}`);
                    }

                    records.push({
                        recordIndex,
                        lineNumber: lineIndex + 1,
                        structName: matched.name,
                        kubun: matched.kubun,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value,
                        startPos,
                        endPos
                    });

                    fieldOffset += field.size;
                });
                
                // 디버그: 그룹 종료
                if (isDebugMode) {
                    console.groupEnd();
                }

                parsedBytes += Math.min(actualSize, expectedSize);
                recordIndex++;
            });

            // 5. 통계 계산
            const stats = {
                totalBytes,
                parsedBytes,
                recordCount: recordIndex,
                errorLines,
                mode: 'line-by-line'
            };
            
            // 디버그: 최종 통계 로깅
            if (isDebugMode) {
                console.log('---');
                console.log('📊 파싱 완료 통계:', {
                    모드: stats.mode,
                    전체바이트: stats.totalBytes,
                    파싱바이트: stats.parsedBytes,
                    레코드수: stats.recordCount,
                    에러라인: stats.errorLines
                });
                console.groupEnd();
            }

            // 6. 반환
            return { records, stats };
        }

        /**
         * =====================================================
         * 연속 데이터 파싱 함수 (개행 인식 OFF 모드)
         * =====================================================
         * 
         * [처리 흐름]
         * 1. 전처리: 모든 줄바꿈 제거 (\r, \n)
         * 2. 현재 위치에서 구조체 매칭 (구분값 기반)
         * 3. 매칭 성공: 필드별 데이터 추출, 구조체 크기만큼 이동
         * 4. 매칭 실패: 1바이트 스킵, 에러 바이트 카운트 증가
         * 5. 데이터 끝까지 반복
         * 
         * [특징]
         * - 줄바꿈이 완전히 무시됨
         * - 구조체에 CRLF 필드가 없어야 함
         * - 구분값으로 레코드 시작점 탐지
         * - 연속된 여러 레코드 자동 분리
         * 
         * [에러 처리]
         * - 구조체 매칭 실패: 1바이트 스킵 후 재시도
         * - 에러 바이트 수 통계에 누적
         * - 과도한 에러 로그 방지 (최대 10개까지만 출력)
         * 
         * [사용 예시]
         * - CRLF 없는 구조체: "H881234567D1234567890123456..." 형태
         * - 구분값 H, D, T 등으로 레코드 분리
         * 
         * @param {string} dataText - 통 데이터 텍스트 (줄바꿈 포함 가능)
         * @param {Array} structDefs - 구조체 정의 배열 (CRLF 필드 없음)
         * @returns {Object} { records: [...], stats: {...} } 형식의 파싱 결과
         */
        function parseContinuous(dataText, structDefs) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            
            // 1. 전처리: 모든 개행 제거
            const processedData = dataText.replace(/[\r\n]/g, '');
            console.log(`연속 파싱: 총 ${processedData.length} bytes`);
            
            // 디버그 모드: 초기 정보 로깅
            if (isDebugMode) {
                console.group('🔍 파싱 디버그 - Continuous 모드');
                console.log('📋 모드:', 'continuous');
                console.log('📊 전체 데이터 길이:', processedData.length, 'bytes');
                console.log('📐 정의된 구조체:', structDefs.map(s => `${s.name}(구분값:${s.kubun}, 크기:${s.totalSize})`).join(', '));
                console.log('📝 데이터 미리보기:', processedData.substring(0, 50) + (processedData.length > 50 ? '...' : ''));
                console.log('📝 HEX 미리보기:', Array.from(processedData.substring(0, 20)).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' '));
                console.log('---');
            }

            // 2. 변수 초기화
            const records = [];
            let currentPos = 0;
            let recordIndex = 0;
            let errorBytes = 0;

            // 3. 메인 루프
            while (currentPos < processedData.length) {
                const remainingData = processedData.substring(currentPos);

                // 구조체 매칭
                const matched = findStructByKubun(remainingData, structDefs);

                if (!matched) {
                    // 디버그: 매칭 실패 정보
                    if (isDebugMode && errorBytes < 10) { // 너무 많은 로그 방지
                        console.warn(`  ❌ 위치 ${currentPos}: 구분값 '${remainingData[0]}'에 매칭 실패, 1바이트 스킵`);
                    }
                    errorBytes++;
                    currentPos++;
                    continue;
                }
                
                // 디버그: 매칭된 구조체 정보
                if (isDebugMode) {
                    console.group(`✅ 레코드 ${recordIndex + 1} (위치: ${currentPos}) → ${matched.name}`);
                    console.log('📌 구분값:', matched.kubun);
                    console.log('📏 구조체 크기:', matched.totalSize, 'bytes');
                    
                    // 길이 비교
                    const remainingLength = processedData.length - currentPos;
                    const lengthStatus = remainingLength >= matched.totalSize ? '✅ 충분' : '⚠️ 부족';
                    console.log(`📐 길이 비교: 필요=${matched.totalSize}, 남은 데이터=${remainingLength} ${lengthStatus}`);
                    console.log('📋 필드별 추출:');
                }

                // 필드 파싱
                let fieldOffset = 0;
                matched.fields.forEach(field => {
                    const startPos = currentPos + fieldOffset;
                    const endPos = startPos + field.size;
                    const value = processedData.substring(startPos, endPos);
                    
                    // 디버그: 각 필드 값 로깅
                    if (isDebugMode) {
                        const hexValue = Array.from(value).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
                        const displayValue = value.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                        console.log(`  📍 ${field.name}[${field.size}]: "${displayValue}" | HEX: ${hexValue}`);
                    }

                    records.push({
                        recordIndex,
                        structName: matched.name,
                        kubun: matched.kubun,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value,
                        startPos,
                        endPos
                    });

                    fieldOffset += field.size;
                });
                
                // 디버그: 그룹 종료
                if (isDebugMode) {
                    console.groupEnd();
                }

                currentPos += matched.totalSize;
                recordIndex++;
            }

            // 4. 통계
            const stats = {
                totalBytes: processedData.length,
                parsedBytes: processedData.length - errorBytes,
                recordCount: recordIndex,
                errorBytes,
                mode: 'continuous'
            };
            
            // 디버그: 최종 통계 로깅
            if (isDebugMode) {
                console.log('---');
                console.log('📊 파싱 완료 통계:', {
                    모드: stats.mode,
                    전체바이트: stats.totalBytes,
                    파싱바이트: stats.parsedBytes,
                    레코드수: stats.recordCount,
                    에러바이트: stats.errorBytes
                });
                if (errorBytes > 0) {
                    console.warn(`⚠️ ${errorBytes}바이트가 매칭되지 않았습니다.`);
                }
                console.groupEnd();
            }

            // 5. 반환
            return { records, stats };
        }

        /**
         * =====================================================
         * 에러 메시지 표시 함수
         * 지정된 컨테이너에 에러 메시지 표시
         * =====================================================
         * @param {string} message - 에러 메시지
         * @param {string} targetContainer - 타겟 컨테이너 ID (기본: struct-result-container)
         */
        function displayError(message, targetContainer) {
            // 1. targetContainer 가져오기 (기본값: struct-result-container)
            const containerId = targetContainer || 'struct-result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTML을 에러 메시지로 설정
            container.innerHTML = `<div class="error-message">⚠️ ${message}</div>`;
        }

        /**
         * =====================================================
         * XML 파싱 결과 표시 함수
         * DocumentFragment를 사용하여 DOM 조작 최적화
         * 편집 가능한 값 셀 및 통데이터 재생성 기능 포함
         * =====================================================
         * @param {Array} parsedData - parseTelegram의 결과 배열
         */
        function displayResults(parsedData) {
            // 1. result-container 요소 가져오기
            const container = document.getElementById('result-container');

            // 2. innerHTML 초기화
            container.innerHTML = '';

            // 원본 데이터 저장 (재생성 시 사용)
            window.xmlParsedDataOriginal = JSON.parse(JSON.stringify(parsedData));
            window.xmlParsedDataCurrent = parsedData;

            // DocumentFragment 생성 - DOM 조작 최적화
            const fragment = document.createDocumentFragment();

            // 편집 힌트 추가
            const hintDiv = document.createElement('div');
            hintDiv.className = 'edit-hint';
            hintDiv.innerHTML = '<span class="hint-icon">💡</span> <span>값 셀을 클릭하여 직접 수정할 수 있습니다. FULL 타입(KSC-5601)은 수정이 제한됩니다.</span>';
            fragment.appendChild(hintDiv);

            // 3. table 요소 생성
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead 생성 후 tr 추가, th 7개
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['순번', '필드명', '타입', '크기', '시작', '종료', '값'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody 생성
            const tbody = document.createElement('tbody');

            // 6. parsedData 배열 순회
            parsedData.forEach(function(item, index) {
                // tr 생성
                const tr = document.createElement('tr');
                tr.setAttribute('data-field-index', index);

                // FULL 타입인 경우 값을 KSC-5601 디코딩
                let displayValue = item.value;
                let decodedValue = null;
                
                if (item.type === 'FULL' && item.value) {
                    try {
                        decodedValue = KSC5601.decode(item.value);
                    } catch (e) {
                        console.warn('KSC-5601 디코딩 실패:', e);
                    }
                }

                // td 7개 생성
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    displayValue
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    
                    // 값 컬럼 (마지막 컬럼)
                    if (tdIndex === 6) {
                        // FULL 타입: 편집 불가 (인코딩 문제)
                        if (item.type === 'FULL') {
                            td.classList.add('readonly-value');
                            if (decodedValue) {
                                // 디코딩된 한글 텍스트 표시
                                const decodedSpan = document.createElement('span');
                                decodedSpan.textContent = decodedValue;
                                decodedSpan.style.fontWeight = 'bold';
                                decodedSpan.style.color = '#6f42c1';
                                td.appendChild(decodedSpan);
                                
                                // HEX 값 (작은 글씨로)
                                const hexSpan = document.createElement('small');
                                hexSpan.style.display = 'block';
                                hexSpan.style.color = '#666';
                                hexSpan.style.fontSize = '11px';
                                const hexValue = Array.from(item.value.substring(0, 20))
                                    .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                                    .join(' ');
                                hexSpan.textContent = 'HEX: ' + hexValue + (item.value.length > 20 ? '...' : '');
                                td.appendChild(hexSpan);
                                
                                // FULL 타입 편집 불가 안내
                                const infoSpan = document.createElement('small');
                                infoSpan.style.display = 'block';
                                infoSpan.style.color = '#999';
                                infoSpan.style.fontSize = '10px';
                                infoSpan.textContent = '(FULL 타입: 편집 불가)';
                                td.appendChild(infoSpan);
                            } else {
                                td.textContent = value;
                            }
                        } else {
                            // 일반 타입: 편집 가능
                            td.classList.add('editable-value');
                            td.setAttribute('contenteditable', 'true');
                            td.setAttribute('data-field-index', index);
                            td.setAttribute('data-original-value', value);
                            td.setAttribute('data-field-size', item.size);
                            td.setAttribute('data-field-type', item.type);
                            td.textContent = value;
                            
                            // 수정 감지 이벤트
                            td.addEventListener('input', function() {
                                const originalValue = this.getAttribute('data-original-value');
                                const currentValue = this.textContent;
                                
                                if (currentValue !== originalValue) {
                                    this.classList.add('modified');
                                    // 현재 파싱 데이터 업데이트
                                    const fieldIndex = parseInt(this.getAttribute('data-field-index'));
                                    window.xmlParsedDataCurrent[fieldIndex].value = currentValue;
                                } else {
                                    this.classList.remove('modified');
                                }
                                
                                // 수정 카운터 업데이트
                                updateXMLModifiedCount();
                            });
                            
                            // 포커스 아웃 시 길이 검증
                            td.addEventListener('blur', function() {
                                const fieldSize = parseInt(this.getAttribute('data-field-size'));
                                const fieldType = this.getAttribute('data-field-type');
                                let currentValue = this.textContent;
                                
                                // 길이 초과 시 자르기
                                if (currentValue.length > fieldSize) {
                                    currentValue = currentValue.substring(0, fieldSize);
                                    this.textContent = currentValue;
                                }
                                
                                // N 타입이면서 숫자가 아닌 경우 경고
                                if (fieldType === 'N' && currentValue && !/^[0-9]*$/.test(currentValue)) {
                                    this.style.borderColor = '#ffc107';
                                    this.title = '숫자 타입 필드입니다. 숫자만 입력하세요.';
                                } else {
                                    this.style.borderColor = '';
                                    this.title = '';
                                }
                                
                                // 현재 파싱 데이터 업데이트
                                const fieldIndex = parseInt(this.getAttribute('data-field-index'));
                                window.xmlParsedDataCurrent[fieldIndex].value = currentValue;
                            });
                        }
                        
                        // value가 공백만 있으면 class="empty-value" 추가
                        if (typeof value === 'string' && value.trim() === '') {
                            td.classList.add('empty-value');
                        }
                    } else {
                        td.textContent = value;
                    }

                    tr.appendChild(td);
                });

                // tbody에 tr 추가
                tbody.appendChild(tr);
            });

            // 7. table에 thead, tbody 추가
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. 반응형을 위한 wrapper div 생성
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. fragment에 추가
            fragment.appendChild(wrapper);

            // 10. 수정 반영 컨트롤 추가
            const reflectContainer = document.createElement('div');
            reflectContainer.className = 'reflect-changes-container';
            reflectContainer.id = 'xml-reflect-container';
            reflectContainer.innerHTML = `
                <div class="reflect-info">
                    <span>수정된 필드:</span>
                    <span class="modified-count no-changes" id="xml-modified-count">0개</span>
                </div>
                <div class="reflect-buttons">
                    <button class="btn-reset-changes" id="xml-reset-changes-btn" disabled>
                        ↩️ 원래대로
                    </button>
                    <button class="btn-reflect" id="xml-reflect-btn" disabled>
                        ✅ 통데이터 재생성
                    </button>
                </div>
            `;
            fragment.appendChild(reflectContainer);

            // 11. 재생성된 통데이터 표시 영역 (초기에는 숨김)
            const regeneratedContainer = document.createElement('div');
            regeneratedContainer.className = 'regenerated-data-container';
            regeneratedContainer.id = 'xml-regenerated-container';
            regeneratedContainer.style.display = 'none';
            fragment.appendChild(regeneratedContainer);

            // 12. 한 번에 DOM 업데이트
            container.appendChild(fragment);

            // 13. 버튼 이벤트 연결
            attachXMLReflectEvents();
        }

        /**
         * XML 파싱 결과 수정 카운터 업데이트
         */
        function updateXMLModifiedCount() {
            const modifiedCells = document.querySelectorAll('#result-table .editable-value.modified');
            const countSpan = document.getElementById('xml-modified-count');
            const reflectBtn = document.getElementById('xml-reflect-btn');
            const resetBtn = document.getElementById('xml-reset-changes-btn');
            
            if (countSpan) {
                countSpan.textContent = modifiedCells.length + '개';
                
                if (modifiedCells.length > 0) {
                    countSpan.classList.remove('no-changes');
                    reflectBtn.disabled = false;
                    resetBtn.disabled = false;
                } else {
                    countSpan.classList.add('no-changes');
                    reflectBtn.disabled = true;
                    resetBtn.disabled = true;
                }
            }
        }

        /**
         * XML 파싱 결과 수정 반영 이벤트 연결
         */
        function attachXMLReflectEvents() {
            // 원래대로 버튼
            const resetBtn = document.getElementById('xml-reset-changes-btn');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    // 원본 데이터로 복원
                    window.xmlParsedDataCurrent = JSON.parse(JSON.stringify(window.xmlParsedDataOriginal));
                    
                    // 수정된 셀 초기화
                    const modifiedCells = document.querySelectorAll('#result-table .editable-value.modified');
                    modifiedCells.forEach(function(cell) {
                        const originalValue = cell.getAttribute('data-original-value');
                        cell.textContent = originalValue;
                        cell.classList.remove('modified');
                    });
                    
                    // 카운터 업데이트
                    updateXMLModifiedCount();
                    
                    // 재생성 결과 숨기기
                    document.getElementById('xml-regenerated-container').style.display = 'none';
                    
                    showTemporaryMessage('✓ 원래 값으로 복원되었습니다.');
                });
            }
            
            // 통데이터 재생성 버튼
            const reflectBtn = document.getElementById('xml-reflect-btn');
            if (reflectBtn) {
                reflectBtn.addEventListener('click', function() {
                    regenerateXMLTelegram();
                });
            }
        }

        /**
         * XML 파싱 결과를 기반으로 통데이터 재생성
         */
        function regenerateXMLTelegram() {
            const parsedData = window.xmlParsedDataCurrent;
            
            if (!parsedData || parsedData.length === 0) {
                showTemporaryMessage('재생성할 데이터가 없습니다.');
                return;
            }
            
            let regeneratedData = '';
            
            // 각 필드를 순서대로 조합
            parsedData.forEach(function(field) {
                let value = field.value || '';
                const size = field.size;
                const type = field.type;
                
                // FULL 타입: KSC-5601 인코딩 적용
                if (type === 'FULL') {
                    // 이미 인코딩된 원본 데이터 사용 (파싱 시 저장된 바이트 데이터)
                    // FULL 타입은 편집 불가이므로 원본 value 그대로 사용
                    regeneratedData += value;
                    return;
                }
                
                // 패딩 처리
                if (value.length < size) {
                    if (type === 'N') {
                        // 숫자 타입: 왼쪽 0 패딩
                        value = '0'.repeat(size - value.length) + value;
                    } else {
                        // 문자 타입: 오른쪽 공백 패딩
                        value = value + ' '.repeat(size - value.length);
                    }
                } else if (value.length > size) {
                    // 길이 초과 시 자르기
                    value = value.substring(0, size);
                }
                
                regeneratedData += value;
            });
            
            // 결과 표시
            const container = document.getElementById('xml-regenerated-container');
            container.style.display = 'block';
            container.innerHTML = `
                <h4>✅ 재생성된 통데이터</h4>
                <div class="regenerated-data-content" id="xml-regenerated-data">${escapeHtml(regeneratedData)}</div>
                <div style="margin-top: 10px; font-size: 13px; color: #666;">
                    총 ${regeneratedData.length} bytes
                </div>
                <div class="regenerated-actions">
                    <button class="btn-copy-regenerated" id="copy-xml-regenerated">
                        📋 클립보드에 복사
                    </button>
                    <button class="btn-apply-to-input" id="apply-xml-to-input">
                        📥 입력창에 적용
                    </button>
                </div>
            `;
            
            // 복사 버튼 이벤트
            document.getElementById('copy-xml-regenerated').addEventListener('click', function() {
                navigator.clipboard.writeText(regeneratedData).then(function() {
                    showTemporaryMessage('✓ 클립보드에 복사되었습니다.');
                });
            });
            
            // 입력창에 적용 버튼 이벤트
            document.getElementById('apply-xml-to-input').addEventListener('click', function() {
                const telegramInput = document.getElementById('telegram-input');
                if (telegramInput) {
                    telegramInput.value = regeneratedData;
                    showTemporaryMessage('✓ 통데이터 입력창에 적용되었습니다.');
                }
            });
            
            // 스크롤 이동
            container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        /**
         * =====================================================
         * calculateRecordLength(record, mode)
         * =====================================================
         * 레코드의 실제 길이를 계산
         * @param {Object} record - 레코드 객체 (fields 배열 포함)
         * @param {string} mode - 파싱 모드 ('line-by-line' 또는 'continuous')
         * @returns {number} 레코드의 실제 바이트 길이
         */
        function calculateRecordLength(record, mode) {
            if (!record || !record.fields || !Array.isArray(record.fields)) {
                return 0;
            }
            
            // 모든 필드 크기 합계
            let totalSize = record.fields.reduce(function(sum, field) {
                return sum + (field.fieldSize || 0);
            }, 0);
            
            return totalSize;
        }

        /**
         * =====================================================
         * getExpectedLength(structName, structDefs)
         * =====================================================
         * 구조체 정의에서 예상 길이를 가져옴
         * @param {string} structName - 구조체 이름
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {number} 예상 바이트 길이
         */
        function getExpectedLength(structName, structDefs) {
            if (!structName || !Array.isArray(structDefs)) {
                return 0;
            }
            
            const struct = structDefs.find(function(s) {
                return s.name === structName;
            });
            
            return struct ? struct.totalSize : 0;
        }

        /**
         * =====================================================
         * escapeHtml(text)
         * =====================================================
         * HTML 특수문자를 이스케이프 처리 (XSS 방지)
         * 
         * @param {string} text - 이스케이프할 텍스트
         * @returns {string} 이스케이프된 텍스트
         */
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * =====================================================
         * escapeForDisplay(str)
         * =====================================================
         * 문자열의 특수문자를 표시용 이스케이프 시퀀스로 변환
         * 
         * @param {string} str - 변환할 문자열
         * @returns {string} 이스케이프된 문자열
         */
        function escapeForDisplay(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/\r/g, '\\r')
                .replace(/\n/g, '\\n')
                .replace(/\t/g, '\\t');
        }

        /**
         * =====================================================
         * toHexPreview(str)
         * =====================================================
         * 문자열의 앞부분을 HEX로 변환하여 미리보기 생성
         * 
         * @param {string} str - 변환할 문자열
         * @returns {string} HEX 미리보기 문자열 (최대 16바이트)
         */
        function toHexPreview(str) {
            if (typeof str !== 'string') return '';
            const hex = Array.from(str.substring(0, 16))
                .map(function(c) {
                    return c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                })
                .join(' ');
            
            return hex + (str.length > 16 ? ' ...' : '');
        }

        /**
         * =====================================================
         * formatFieldValue(value, isCRLFField)
         * =====================================================
         * 필드 값을 표시용으로 포맷팅
         * - CRLF 필드: 특수문자를 이스케이프 시퀀스로 표시 (\r\n)
         * - 일반 필드: 공백 여부만 확인
         * 
         * @param {string} value - 필드 값
         * @param {boolean} isCRLFField - CRLF 필드 여부
         * @returns {string} 포맷팅된 값
         */
        function formatFieldValue(value, isCRLFField) {
            if (typeof value !== 'string') {
                return value;
            }
            
            // CRLF 필드인 경우 특수문자를 이스케이프 표시
            if (isCRLFField) {
                // \r\n → "\\r\\n" 형태로 표시
                return value
                    .replace(/\r/g, '\\r')
                    .replace(/\n/g, '\\n');
            }
            
            // 일반 필드: 그대로 반환
            return value;
        }

        /**
         * =====================================================
         * createLengthBadge(record, structDefs, mode)
         * =====================================================
         * 길이 검증 뱃지 HTML을 생성
         * @param {Object} record - 레코드 객체
         * @param {Array} structDefs - 구조체 정의 배열
         * @param {string} mode - 파싱 모드
         * @returns {string} 뱃지 HTML 문자열
         */
        function createLengthBadge(record, structDefs, mode) {
            const actualLength = calculateRecordLength(record, mode);
            const expectedLength = getExpectedLength(record.structName, structDefs);
            
            if (expectedLength === 0) {
                return '<span class="length-badge warning">? 길이 정보 없음</span>';
            }
            
            if (actualLength === expectedLength) {
                return '<span class="length-badge success">\u2713 ' + actualLength + 'B</span>';
            } else if (actualLength < expectedLength) {
                return '<span class="length-badge warning">\u26a0\ufe0f ' + actualLength + 'B / ' + expectedLength + 'B (부족)</span>';
            } else {
                return '<span class="length-badge error">\u26a0\ufe0f ' + actualLength + 'B / ' + expectedLength + 'B (초과)</span>';
            }
        }

        /**
         * =====================================================
         * 구조체 파싱 결과 표시 함수
         * DocumentFragment를 사용하여 DOM 조작 최적화
         * 편집 가능한 값 셀 및 통데이터 재생성 기능 포함
         * =====================================================
         * @param {Object} parseResult - { records, stats, structDefs } 형식의 파싱 결과
         *   - records: 레코드 배열 (각 레코드: { recordIndex, structName, kubun, fields })
         *   - stats: 통계 정보 { totalBytes, parsedBytes, recordCount, errorBytes }
         *   - structDefs: 구조체 정의 배열
         */
        function displayStructResults(parseResult) {
            // 1. struct-result-container 초기화
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // 입력값 유효성 검사
            if (!parseResult || !parseResult.records) {
                container.innerHTML = '<div class="error-message">⚠️ 파싱 결과가 없습니다.</div>';
                return;
            }

            const { records, stats, structDefs } = parseResult;

            // 파싱 설정 정보 가져오기
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // DocumentFragment 생성 - DOM 조작 최적화
            const fragment = document.createDocumentFragment();

            // 파싱 설정 정보 표시
            const settingsDiv = document.createElement('div');
            settingsDiv.className = 'parse-settings-info';
            settingsDiv.innerHTML = `
                <h4>⚙️ 파싱 설정</h4>
                <div class="setting-item">
                    <span class="setting-label">파싱 모드:</span>
                    <span class="setting-value mode-${stats.mode}">
                        ${stats.mode === 'line-by-line' ? '📄 라인 단위' : '🔗 연속 데이터'}
                    </span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">개행문자 인식:</span>
                    <span class="setting-value ${recognizeCRLF ? 'enabled' : 'disabled'}">
                        ${recognizeCRLF ? '✓ 활성' : '✗ 비활성'}
                    </span>
                </div>
                ${stats.mode === 'line-by-line' ? `
                <div class="setting-item">
                    <span class="setting-label">처리 라인:</span>
                    <span class="setting-value">${stats.recordCount}개 라인</span>
                </div>
                ` : ''}
            `;
            fragment.appendChild(settingsDiv);

            // 2. 통계 정보 표시
            if (stats) {
                const percent = stats.totalBytes > 0 
                    ? ((stats.parsedBytes / stats.totalBytes) * 100).toFixed(1) 
                    : 0;

                const statsDiv = document.createElement('div');
                statsDiv.className = 'parse-stats';

                statsDiv.innerHTML = `
                    <h3>📊 파싱 통계</h3>
                    <div class="stats-grid">
                        <div>전체: ${stats.totalBytes} bytes</div>
                        <div>파싱: ${stats.parsedBytes} bytes (${percent}%)</div>
                        <div>레코드: ${stats.recordCount}개</div>
                        <div>오류: ${stats.errorBytes} bytes</div>
                    </div>
                `;

                fragment.appendChild(statsDiv);
            }

            // 레코드가 없으면 메시지 표시
            if (records.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'error-message';
                noDataDiv.textContent = '⚠️ 파싱된 레코드가 없습니다.';
                fragment.appendChild(noDataDiv);
                container.appendChild(fragment);
                return;
            }

            // 편집 힌트 추가
            const hintDiv = document.createElement('div');
            hintDiv.className = 'edit-hint';
            hintDiv.innerHTML = '<span class="hint-icon">💡</span> <span>값 셀을 클릭하여 직접 수정할 수 있습니다. CRLF 필드는 수정이 제한됩니다.</span>';
            fragment.appendChild(hintDiv);

            /**
             * 3. 레코드별 그룹화 (recordIndex 기준)
             * 
             * [최적화된 그룹화 로직]
             * - 한 번의 순회로 레코드와 필드를 동시에 그룹화
             * - 에러 레코드는 즉시 DOM에 추가
             * - 정상 레코드는 Map에 필드 배열과 함께 저장
             */
            const recordMap = new Map();
            const errorCards = [];  // 에러 카드 별도 수집
            
            records.forEach(function(record) {
                // 에러 레코드 처리
                if (record.error) {
                    errorCards.push(record);
                    return;
                }
                
                // 정상 레코드: recordIndex로 그룹화, 필드 배열 수집
                const idx = record.recordIndex;
                if (!recordMap.has(idx)) {
                    // 레코드 초기화 (필드 배열 포함)
                    recordMap.set(idx, {
                        recordIndex: record.recordIndex,
                        lineNumber: record.lineNumber,
                        structName: record.structName,
                        kubun: record.kubun,
                        fields: []  // 필드 배열 초기화
                    });
                }
                
                // 필드 추가
                recordMap.get(idx).fields.push({
                    fieldName: record.fieldName,
                    fieldSize: record.fieldSize,
                    value: record.value,
                    startPos: record.startPos,
                    endPos: record.endPos
                });
            });

            // 원본 데이터 저장 (재생성 시 사용)
            window.structParsedDataOriginal = JSON.parse(JSON.stringify(Array.from(recordMap.values())));
            window.structParsedDataCurrent = Array.from(recordMap.values());
            window.structParseStats = stats;
            
            // 에러 카드 먼저 표시 (순서 보장)
            errorCards.forEach(function(errorRecord) {
                const errorCard = document.createElement('div');
                errorCard.className = 'error-record-card';
                errorCard.innerHTML = `
                    <div class="error-header">
                        <span class="error-icon">⚠️</span>
                        <span class="error-title">라인 ${errorRecord.lineNumber} 파싱 실패</span>
                    </div>
                    <div class="error-body">
                        <p class="error-message">${errorRecord.message}</p>
                        <pre class="error-data">${escapeHtml(errorRecord.lineData)}</pre>
                        <div class="error-info">
                            <small>데이터 길이: ${errorRecord.lineData.length} bytes</small>
                        </div>
                    </div>
                `;
                fragment.appendChild(errorCard);
            });

            // 4. 각 레코드마다 테이블 생성
            let globalFieldIndex = 0;  // 전역 필드 인덱스 (수정 추적용)
            
            recordMap.forEach(function(record, recordIndex) {
                // 그룹 컨테이너 생성
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';
                groupDiv.setAttribute('data-record-index', recordIndex);

                // 레코드 헤더 생성
                const headerDiv = document.createElement('div');
                headerDiv.className = 'record-header';

                // 제목: "레코드 #N - 구조체명"
                const title = document.createElement('h3');
                title.textContent = '레코드 #' + (recordIndex + 1) + ' - ' + record.structName;
                headerDiv.appendChild(title);

                // 구분값 배지
                const kubunBadge = document.createElement('span');
                kubunBadge.className = 'kubun-badge';
                kubunBadge.textContent = '구분: ' + (record.kubun || 'N/A');
                headerDiv.appendChild(kubunBadge);

                // 길이 검증 뱃지 추가
                const lengthBadgeHtml = createLengthBadge(record, structDefs, stats.mode);
                const lengthBadgeContainer = document.createElement('span');
                lengthBadgeContainer.innerHTML = lengthBadgeHtml;
                if (lengthBadgeContainer.firstChild) {
                    headerDiv.appendChild(lengthBadgeContainer.firstChild);
                }

                // 복사 버튼
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.setAttribute('data-record', recordIndex);
                copyBtn.textContent = '📋 복사';
                headerDiv.appendChild(copyBtn);

                groupDiv.appendChild(headerDiv);

                // 테이블 생성
                const table = document.createElement('table');
                table.className = 'result-table struct-editable-table';
                table.setAttribute('data-record-index', recordIndex);

                // thead 생성
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['필드명', '크기', '시작', '종료', '값'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody 생성
                const tbody = document.createElement('tbody');

                // 해당 레코드의 모든 필드를 행으로 추가
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field, fieldIndex) {
                        const tr = document.createElement('tr');
                        tr.setAttribute('data-record-index', recordIndex);
                        tr.setAttribute('data-field-index', fieldIndex);

                        /**
                         * 필드 값 표시 처리
                         * - CRLF 필드: 특수문자를 이스케이프하여 "\r\n" 형태로 표시
                         * - 일반 필드: 그대로 표시
                         */
                        const isCRLFField = field.fieldName && 
                            field.fieldName.toLowerCase().match(/crlf|cr_lf|newline/);
                        
                        // 값 포맷팅: 특수문자 이스케이프 (가시성 향상)
                        const formattedValue = formatFieldValue(field.value, isCRLFField);

                        const values = [
                            field.fieldName,   // 필드명
                            field.fieldSize,   // 크기
                            field.startPos,    // 시작
                            field.endPos,      // 종료
                            formattedValue     // 값 (포맷팅 적용)
                        ];

                        values.forEach(function(value, tdIndex) {
                            const td = document.createElement('td');

                            // 값 컬럼 (마지막 컬럼)
                            if (tdIndex === 4) {
                                // CRLF 필드: 편집 불가
                                if (isCRLFField) {
                                    td.classList.add('readonly-value');
                                    td.classList.add('crlf-value');
                                    td.textContent = value;
                                    td.title = 'CRLF 필드: 편집 불가';
                                } else {
                                    // 일반 필드: 편집 가능
                                    td.classList.add('editable-value');
                                    td.setAttribute('contenteditable', 'true');
                                    td.setAttribute('data-record-index', recordIndex);
                                    td.setAttribute('data-field-index', fieldIndex);
                                    td.setAttribute('data-original-value', field.value);
                                    td.setAttribute('data-field-size', field.fieldSize);
                                    td.setAttribute('data-field-name', field.fieldName);
                                    td.textContent = value;
                                    
                                    // 수정 감지 이벤트
                                    td.addEventListener('input', function() {
                                        const originalValue = this.getAttribute('data-original-value');
                                        const currentValue = this.textContent;
                                        
                                        if (currentValue !== originalValue) {
                                            this.classList.add('modified');
                                            // 현재 파싱 데이터 업데이트
                                            const recIdx = parseInt(this.getAttribute('data-record-index'));
                                            const fldIdx = parseInt(this.getAttribute('data-field-index'));
                                            if (window.structParsedDataCurrent[recIdx] && 
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                                window.structParsedDataCurrent[recIdx].fields[fldIdx].value = currentValue;
                                            }
                                        } else {
                                            this.classList.remove('modified');
                                        }
                                        
                                        // 수정 카운터 업데이트
                                        updateStructModifiedCount();
                                    });
                                    
                                    // 포커스 아웃 시 길이 검증
                                    td.addEventListener('blur', function() {
                                        const fieldSize = parseInt(this.getAttribute('data-field-size'));
                                        let currentValue = this.textContent;
                                        
                                        // 길이 초과 시 자르기
                                        if (currentValue.length > fieldSize) {
                                            currentValue = currentValue.substring(0, fieldSize);
                                            this.textContent = currentValue;
                                        }
                                        
                                        // 현재 파싱 데이터 업데이트
                                        const recIdx = parseInt(this.getAttribute('data-record-index'));
                                        const fldIdx = parseInt(this.getAttribute('data-field-index'));
                                        if (window.structParsedDataCurrent[recIdx] && 
                                            window.structParsedDataCurrent[recIdx].fields[fldIdx]) {
                                            window.structParsedDataCurrent[recIdx].fields[fldIdx].value = currentValue;
                                        }
                                    });
                                }
                                
                                // value가 공백만 있으면 class="empty-value" 추가
                                if (typeof value === 'string' && value.trim() === '') {
                                    td.classList.add('empty-value');
                                }
                            } else {
                                td.textContent = value;
                            }

                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                        globalFieldIndex++;
                    });
                }

                table.appendChild(thead);
                table.appendChild(tbody);

                // 반응형 wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // fragment에 그룹 추가
                fragment.appendChild(groupDiv);
            });

            // 5. 수정 반영 컨트롤 추가
            const reflectContainer = document.createElement('div');
            reflectContainer.className = 'reflect-changes-container';
            reflectContainer.id = 'struct-reflect-container';
            reflectContainer.innerHTML = `
                <div class="reflect-info">
                    <span>수정된 필드:</span>
                    <span class="modified-count no-changes" id="struct-modified-count">0개</span>
                </div>
                <div class="reflect-buttons">
                    <button class="btn-reset-changes" id="struct-reset-changes-btn" disabled>
                        ↩️ 원래대로
                    </button>
                    <button class="btn-reflect" id="struct-reflect-btn" disabled>
                        ✅ 통데이터 재생성
                    </button>
                </div>
            `;
            fragment.appendChild(reflectContainer);

            // 6. 재생성된 통데이터 표시 영역 (초기에는 숨김)
            const regeneratedContainer = document.createElement('div');
            regeneratedContainer.className = 'regenerated-data-container';
            regeneratedContainer.id = 'struct-regenerated-container';
            regeneratedContainer.style.display = 'none';
            fragment.appendChild(regeneratedContainer);

            // 한 번에 DOM 업데이트
            container.appendChild(fragment);

            // 7. 버튼 이벤트 연결
            attachStructReflectEvents();
        }

        /**
         * 구조체 파싱 결과 수정 카운터 업데이트
         */
        function updateStructModifiedCount() {
            const modifiedCells = document.querySelectorAll('.struct-editable-table .editable-value.modified');
            const countSpan = document.getElementById('struct-modified-count');
            const reflectBtn = document.getElementById('struct-reflect-btn');
            const resetBtn = document.getElementById('struct-reset-changes-btn');
            
            if (countSpan) {
                countSpan.textContent = modifiedCells.length + '개';
                
                if (modifiedCells.length > 0) {
                    countSpan.classList.remove('no-changes');
                    reflectBtn.disabled = false;
                    resetBtn.disabled = false;
                } else {
                    countSpan.classList.add('no-changes');
                    reflectBtn.disabled = true;
                    resetBtn.disabled = true;
                }
            }
        }

        /**
         * 구조체 파싱 결과 수정 반영 이벤트 연결
         */
        function attachStructReflectEvents() {
            // 원래대로 버튼
            const resetBtn = document.getElementById('struct-reset-changes-btn');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    // 원본 데이터로 복원
                    window.structParsedDataCurrent = JSON.parse(JSON.stringify(window.structParsedDataOriginal));
                    
                    // 수정된 셀 초기화
                    const modifiedCells = document.querySelectorAll('.struct-editable-table .editable-value.modified');
                    modifiedCells.forEach(function(cell) {
                        const originalValue = cell.getAttribute('data-original-value');
                        cell.textContent = originalValue;
                        cell.classList.remove('modified');
                    });
                    
                    // 카운터 업데이트
                    updateStructModifiedCount();
                    
                    // 재생성 결과 숨기기
                    document.getElementById('struct-regenerated-container').style.display = 'none';
                    
                    showTemporaryMessage('✓ 원래 값으로 복원되었습니다.');
                });
            }
            
            // 통데이터 재생성 버튼
            const reflectBtn = document.getElementById('struct-reflect-btn');
            if (reflectBtn) {
                reflectBtn.addEventListener('click', function() {
                    regenerateStructTelegram();
                });
            }
        }

        /**
         * 구조체 파싱 결과를 기반으로 통데이터 재생성
         */
        function regenerateStructTelegram() {
            const parsedData = window.structParsedDataCurrent;
            const stats = window.structParseStats;
            
            if (!parsedData || parsedData.length === 0) {
                showTemporaryMessage('재생성할 데이터가 없습니다.');
                return;
            }
            
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            const isLineByLine = stats && stats.mode === 'line-by-line';
            
            let regeneratedData = '';
            
            // 각 레코드를 순서대로 조합
            parsedData.forEach(function(record, recordIdx) {
                let recordData = '';
                
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field) {
                        let value = field.value || '';
                        const size = field.fieldSize;
                        const fieldName = field.fieldName || '';
                        
                        // CRLF 필드 여부 확인
                        const isCRLFField = fieldName.toLowerCase().match(/crlf|cr_lf|newline/);
                        
                        if (isCRLFField) {
                            if (recognizeCRLF) {
                                // 개행문자 인식 활성화: 무조건 실제 \r\n 개행문자로 변환
                                value = '\r\n';
                            } else {
                                // 개행문자 인식 비활성화: 일반 필드처럼 패딩 처리
                                if (value.length < size) {
                                    value = value + ' '.repeat(size - value.length);
                                } else if (value.length > size) {
                                    value = value.substring(0, size);
                                }
                            }
                        } else {
                            // 일반 필드: 패딩 처리
                            if (value.length < size) {
                                // 오른쪽 공백 패딩
                                value = value + ' '.repeat(size - value.length);
                            } else if (value.length > size) {
                                // 길이 초과 시 자르기
                                value = value.substring(0, size);
                            }
                        }
                        
                        recordData += value;
                    });
                }
                
                regeneratedData += recordData;
                
                // 라인 단위 모드에서는 각 레코드 끝에 개행 추가 (마지막 레코드 제외, CRLF가 없는 경우)
                if (isLineByLine && recordIdx < parsedData.length - 1) {
                    // 레코드 끝에 CRLF가 이미 있는지 확인
                    if (!recordData.endsWith('\r\n') && !recordData.endsWith('\n')) {
                        regeneratedData += '\r\n';
                    }
                }
            });
            
            // 결과 표시
            const container = document.getElementById('struct-regenerated-container');
            container.style.display = 'block';
            
            // 표시용 데이터 (이스케이프 시퀀스 처리)
            const displayData = regeneratedData
                .replace(/\r/g, '\\r')
                .replace(/\n/g, '\\n');
            
            container.innerHTML = `
                <h4>✅ 재생성된 통데이터</h4>
                <div class="regenerated-data-content" id="struct-regenerated-data">${escapeHtml(displayData)}</div>
                <div style="margin-top: 10px; font-size: 13px; color: #666;">
                    총 ${regeneratedData.length} bytes | ${parsedData.length}개 레코드
                </div>
                <div class="regenerated-actions">
                    <button class="btn-copy-regenerated" id="copy-struct-regenerated">
                        📋 클립보드에 복사
                    </button>
                    <button class="btn-apply-to-input" id="apply-struct-to-input">
                        📥 입력창에 적용
                    </button>
                </div>
            `;
            
            // 원본 데이터 저장 (복사용)
            container.setAttribute('data-raw-value', regeneratedData);
            
            // 복사 버튼 이벤트
            document.getElementById('copy-struct-regenerated').addEventListener('click', function() {
                const rawValue = document.getElementById('struct-regenerated-container').getAttribute('data-raw-value');
                navigator.clipboard.writeText(rawValue).then(function() {
                    showTemporaryMessage('✓ 클립보드에 복사되었습니다.');
                });
            });
            
            // 입력창에 적용 버튼 이벤트
            document.getElementById('apply-struct-to-input').addEventListener('click', function() {
                const rawValue = document.getElementById('struct-regenerated-container').getAttribute('data-raw-value');
                const dataInput = document.getElementById('struct-data');
                if (dataInput) {
                    dataInput.value = rawValue;
                    showTemporaryMessage('✓ 통데이터 입력창에 적용되었습니다.');
                }
            });
            
            // 스크롤 이동
            container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        /**
         * =====================================================
         * 신규 레코드 입력 폼 표시 함수 (33단계)
         * 구조체 필드 배열을 받아 입력 폼을 생성
         * CRLF 필드는 개행 인식 옵션에 따라 자동 처리
         * =====================================================
         * @param {Array} fields - 필드 배열 [{name, size}, ...]
         * @param {HTMLElement} container - 폼을 표시할 컨테이너 요소
         * @returns {HTMLElement} 생성된 테이블 요소
         */
        function showNewRecordForm(fields, container) {
            // 입력값 유효성 검사
            if (!Array.isArray(fields) || fields.length === 0) {
                console.error('showNewRecordForm: 유효하지 않은 필드 배열입니다.');
                return null;
            }
            
            if (!container || !(container instanceof HTMLElement)) {
                console.error('showNewRecordForm: 유효하지 않은 컨테이너입니다.');
                return null;
            }
            
            // 개행문자 인식 옵션 확인
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // 테이블 생성
            const table = document.createElement('table');
            table.className = 'result-table new-record-form';
            
            // thead 생성
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['필드명', '크기', '입력값', '미리보기'];
            
            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // tbody 생성
            const tbody = document.createElement('tbody');
            
            // 각 필드에 대해 행 생성
            fields.forEach(function(field) {
                const tr = document.createElement('tr');
                
                // CRLF 필드 여부 확인
                const isCRLFField = field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/);
                
                // 필드명 셀
                const tdName = document.createElement('td');
                tdName.textContent = field.name;
                tr.appendChild(tdName);
                
                // 크기 셀
                const tdSize = document.createElement('td');
                tdSize.textContent = field.size;
                tr.appendChild(tdSize);
                
                // 입력값 셀
                const tdInput = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                
                if (isCRLFField && recognizeCRLF) {
                    // CRLF 필드이고 개행 인식 활성화: 자동 설정
                    input.value = '\\r\\n';
                    input.disabled = true;
                    input.className = 'auto-field';
                    input.title = '자동 설정됨';
                } else {
                    // 일반 필드 또는 개행 인식 비활성화된 CRLF 필드: 수동 입력 가능
                    input.className = 'new-field-input';
                    input.setAttribute('data-field', field.name);
                    input.setAttribute('data-size', field.size);
                    input.maxLength = field.size;
                    
                    if (isCRLFField) {
                        input.placeholder = '예: CR+LF 또는 공백';
                    } else {
                        input.placeholder = field.name + ' 값 입력';
                    }
                    
                    // 입력값 변경 시 미리보기 업데이트
                    input.addEventListener('input', function() {
                        const previewCell = tr.querySelector('.preview-cell');
                        if (previewCell) {
                            previewCell.textContent = input.value || '';
                        }
                    });
                }
                
                tdInput.appendChild(input);
                tr.appendChild(tdInput);
                
                // 미리보기 셀
                const tdPreview = document.createElement('td');
                tdPreview.className = 'preview-cell';
                
                if (isCRLFField && recognizeCRLF) {
                    tdPreview.textContent = '\\r\\n';
                } else {
                    tdPreview.textContent = '';
                }
                
                tr.appendChild(tdPreview);
                tbody.appendChild(tr);
            });
            
            table.appendChild(tbody);
            
            // 컨테이너 비우고 테이블 추가
            container.innerHTML = '';
            container.appendChild(table);
            
            console.log('showNewRecordForm: ' + fields.length + '개 필드의 입력 폼이 생성되었습니다.');
            
            return table;
        }

        /**
         * =====================================================
         * 테스트 케이스 실행 함수
         * 다양한 입력 상황에 대한 자동화된 테스트
         * =====================================================
         * @returns {Object} 테스트 결과 객체 { passed, failed, results }
         */
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            /**
             * 개별 테스트 실행 헬퍼
             */
            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        passed++;
                        results.push({ name: name, passed: true });
                    } else {
                        failed++;
                        results.push({ name: name, passed: false, reason: result || '실패' });
                    }
                } catch (e) {
                    failed++;
                    results.push({ name: name, passed: false, reason: e.message });
                }
            }

            // =========================================
            // 테스트 케이스 1: 구조체 1개만 있는 경우
            // =========================================
            test('구조체 1개만 있는 경우', function() {
                const structDef = `typedef struct {
                    char field1[5];
                    char field2[10];
                } SingleStruct;`;
                
                const data = 'HELLO1234567890';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                
                const result = parseStructData(data, defs);
                if (result.records.length !== 1) return '레코드 파싱 실패';
                if (result.records[0].fields.length !== 2) return '필드 파싱 실패';
                if (result.records[0].fields[0].value !== 'HELLO') return '첫 번째 필드 값 불일치';
                if (result.records[0].fields[1].value !== '1234567890') return '두 번째 필드 값 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 2: 구조체 5개 이상인 경우
            // =========================================
            test('구조체 5개 이상인 경우', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Type_A;
                    typedef struct { char type[1]; char data[4]; } Type_B;
                    typedef struct { char type[1]; char data[4]; } Type_C;
                    typedef struct { char type[1]; char data[4]; } Type_D;
                    typedef struct { char type[1]; char data[4]; } Type_E;
                `;
                
                const data = 'AAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 5) return '구조체 개수 불일치: ' + (defs ? defs.length : 0);
                
                const result = parseStructData(data, defs);
                // 5줄 = 5개 레코드
                if (result.records.length !== 5) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                return true;
            });

            // =========================================
            // 테스트 케이스 3: 데이터 라인 100개 이상
            // =========================================
            test('데이터 라인 100개 이상', function() {
                const structDef = `typedef struct { char id[4]; char val[6]; } DataLine;`;
                
                // 100개 라인 생성
                let dataLines = [];
                for (let i = 0; i < 100; i++) {
                    const id = ('0000' + i).slice(-4);
                    dataLines.push(id + 'VALUE1');
                }
                const data = dataLines.join('\n');
                
                const defs = parseStructDefinitions(structDef);
                if (!defs) return '구조체 파싱 실패';
                
                const result = parseStructData(data, defs);
                // 100줄 = 100개 레코드
                if (result.records.length !== 100) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                // 첫 번째와 마지막 레코드 검증
                if (result.records[0].fields[0].value !== '0000') return '첫 레코드 첫 필드 불일치';
                if (result.records[99].fields[0].value !== '0099') return '마지막 레코드 첫 필드 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 4: 길이가 안 맞는 데이터
            // =========================================
            test('길이가 안 맞는 데이터 (짧음)', function() {
                const structDef = `typedef struct { char field1[10]; char field2[10]; } TestStruct;`;
                const data = 'SHORTDATA'; // 9자 (예상: 20자)
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // 파싱은 성공해야 함 (부족한 부분은 빈 문자열)
                if (result.records.length !== 1) return '레코드 파싱 실패';
                if (result.records[0].fields.length !== 2) return '필드 파싱 실패';
                if (result.records[0].fields[0].value !== 'SHORTDATA') return '첫 번째 필드 값 불일치';
                if (result.records[0].fields[1].value !== '') return '두 번째 필드가 빈 문자열이어야 함';
                
                return true;
            });

            test('길이가 안 맞는 데이터 (김)', function() {
                const structDef = `typedef struct { char field1[5]; } ShortStruct;`;
                const data = 'EXTRALONG_DATA_HERE'; // 예상보다 긴 데이터
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // 정의된 필드까지만 파싱
                if (result.records.length !== 1) return '레코드 파싱 개수 불일치';
                if (result.records[0].fields[0].value !== 'EXTRA') return '값 불일치: ' + result.records[0].fields[0].value;
                
                return true;
            });

            // =========================================
            // 테스트 케이스 5: 잘못된 구조체 문법
            // =========================================
            test('잘못된 구조체 문법 - typedef 누락', function() {
                const structDef = `struct { char field[5]; } BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // null을 반환해야 함
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('잘못된 구조체 문법 - 중괄호 누락', function() {
                const structDef = `typedef struct char field[5]; BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('잘못된 구조체 문법 - 세미콜론 누락', function() {
                const structDef = `typedef struct { char field[5]; } BadStruct`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('빈 구조체 (필드 없음)', function() {
                const structDef = `typedef struct { } EmptyStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // 빈 구조체는 제외되므로 null 반환
                if (defs !== null) return '빈 구조체인데 파싱됨';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 6: 빈 입력
            // =========================================
            test('빈 입력 - 구조체 정의', function() {
                const defs = parseStructDefinitions('');
                if (defs !== null) return '빈 입력인데 파싱됨';
                return true;
            });

            test('빈 입력 - 데이터', function() {
                const structDef = `typedef struct { char field[5]; } TestStruct;`;
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData('', defs);
                
                if (result.records.length !== 0) return '빈 데이터인데 결과 있음';
                return true;
            });

            test('공백만 있는 입력', function() {
                const defs = parseStructDefinitions('   \n\t\n   ');
                if (defs !== null) return '공백만 있는데 파싱됨';
                return true;
            });

            // =========================================
            // 테스트 케이스 7: 주석 처리
            // =========================================
            test('한줄 주석 처리', function() {
                const structDef = `typedef struct {
                    // 이것은 주석입니다
                    char field1[5]; // 필드 설명
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                if (defs[0].fields.length !== 2) return '필드 개수 불일치';
                
                return true;
            });

            test('블록 주석 처리', function() {
                const structDef = `typedef struct {
                    /* 블록 주석
                       여러 줄 */
                    char field1[5];
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                if (defs[0].fields.length !== 2) return '필드 개수 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 8: 구조체 매칭 로직
            // =========================================
            test('구조체 매칭 - 첫 글자 기준', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Record_H;
                    typedef struct { char type[1]; char data[9]; } Record_D;
                `;
                
                const data = 'H1234\nD123456789';
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // H 라인: 1레코드, D 라인: 1레코드 = 2개 레코드
                if (result.records.length !== 2) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                // 첫 라인은 Record_H
                if (result.records[0].structName !== 'Record_H') return '첫 라인 구조체 매칭 실패';
                // 두 번째 라인은 Record_D
                if (result.records[1].structName !== 'Record_D') return '두 번째 라인 구조체 매칭 실패';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 9: XML 파싱
            // =========================================
            test('XML 파싱 - 정상', function() {
                const xml = `<packet>
                    <col id="field1" type="X" size="5" />
                    <col id="field2" type="N" size="10" />
                </packet>`;
                
                const spec = parseXMLSpec(xml);
                if (!spec || spec.length !== 2) return 'XML 파싱 실패';
                if (spec[0].id !== 'field1') return '첫 번째 필드 ID 불일치';
                if (spec[1].size !== 10) return '두 번째 필드 크기 불일치';
                
                return true;
            });

            test('XML 파싱 - 빈 입력', function() {
                const spec = parseXMLSpec('');
                if (spec !== null) return '빈 입력인데 파싱됨';
                return true;
            });

            test('XML 파싱 - 잘못된 형식', function() {
                const spec = parseXMLSpec('<invalid><unclosed>');
                if (spec !== null) return '잘못된 XML인데 파싱됨';
                return true;
            });

            // =========================================
            // 테스트 케이스 10: 통전문 파싱
            // =========================================
            test('통전문 파싱 - 정상', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="3" />
                    <col id="name" type="X" size="5" />
                </packet>`;
                const telegram = 'ABCHELLO';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return '필드 개수 불일치';
                if (parsed[0].value !== 'ABC') return '첫 번째 값 불일치';
                if (parsed[1].value !== 'HELLO') return '두 번째 값 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 11: KSC-5601 인코딩/디코딩
            // =========================================
            test('KSC-5601 인코딩 - 영문자', function() {
                const encoded = KSC5601.encode('ABC');
                // 영문 대문자는 전각으로 변환: A=0xA3C1, B=0xA3C2, C=0xA3C3
                if (encoded.length !== 6) return '인코딩 길이 불일치 (예상: 6, 실제: ' + encoded.length + ')';
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xC1) return 'A 인코딩 실패';
                if (encoded[2] !== 0xA3 || encoded[3] !== 0xC2) return 'B 인코딩 실패';
                if (encoded[4] !== 0xA3 || encoded[5] !== 0xC3) return 'C 인코딩 실패';
                return true;
            });

            test('KSC-5601 인코딩 - 숫자', function() {
                const encoded = KSC5601.encode('123');
                // 숫자는 전각으로 변환: 1=0xA3B1, 2=0xA3B2, 3=0xA3B3
                if (encoded.length !== 6) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xB1) return '1 인코딩 실패';
                if (encoded[2] !== 0xA3 || encoded[3] !== 0xB2) return '2 인코딩 실패';
                if (encoded[4] !== 0xA3 || encoded[5] !== 0xB3) return '3 인코딩 실패';
                return true;
            });

            test('KSC-5601 인코딩 - 공백', function() {
                const encoded = KSC5601.encode(' ');
                // 공백은 전각 공백: 0xA1A1
                if (encoded.length !== 2) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA1 || encoded[1] !== 0xA1) return '공백 인코딩 실패';
                return true;
            });

            test('KSC-5601 디코딩 - EUC-KR', function() {
                // '가' = 0xB0A1 in EUC-KR
                const bytes = new Uint8Array([0xB0, 0xA1]);
                const decoded = KSC5601.decode(bytes);
                if (decoded !== '가') return '가 디코딩 실패 (결과: ' + decoded + ')';
                return true;
            });

            test('KSC-5601 바이트 길이 계산', function() {
                // 모든 문자가 2바이트
                const len1 = KSC5601.getByteLength('ABC');
                if (len1 !== 6) return 'ABC 길이 불일치 (예상: 6, 실제: ' + len1 + ')';
                
                const len2 = KSC5601.getByteLength('한글');
                if (len2 !== 4) return '한글 길이 불일치 (예상: 4, 실제: ' + len2 + ')';
                
                return true;
            });

            test('KSC-5601 패딩 - 바이트 단위', function() {
                // 'A'를 6바이트로 패딩
                const padded = KSC5601.padToByteSize('A', 6);
                // A(2bytes) + 전각공백 2개(4bytes) = 6bytes
                if (padded.length !== 6) return '패딩 길이 불일치 (예상: 6, 실제: ' + padded.length + ')';
                return true;
            });

            test('KSC-5601 자르기 - 바이트 경계', function() {
                // 'ABC'(6바이트)를 4바이트로 자르기
                const truncated = KSC5601.truncateToByteSize('ABC', 4);
                // 4바이트 = 2문자
                if (truncated.length !== 4) return '자르기 길이 불일치 (예상: 4, 실제: ' + truncated.length + ')';
                return true;
            });

            // =========================================
            // 테스트 케이스 12: 유니코드 입력 감지 및 변환
            // =========================================
            test('Latin1 인코딩 감지 - 이미 인코딩됨', function() {
                // KSC-5601로 인코딩된 Latin1 문자열
                const encoded = String.fromCharCode(0xB0, 0xA1, 0xB0, 0xA2); // '가각'
                if (!isLatin1Encoded(encoded)) return 'Latin1을 유니코드로 잘못 감지';
                return true;
            });

            test('Latin1 인코딩 감지 - 유니코드', function() {
                // 유니코드 한글
                const unicode = '홍길동';
                if (isLatin1Encoded(unicode)) return '유니코드를 Latin1으로 잘못 감지';
                return true;
            });

            test('유니코드 FULL 타입 파싱', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="4" />
                    <col id="name" type="FULL" size="6" />
                </packet>`;
                // 유니코드로 직접 입력: "TEST" + "홍길동"
                const telegram = 'TEST홍길동';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return '필드 개수 불일치';
                if (parsed[0].value !== 'TEST') return 'code 값 불일치';
                // FULL 필드는 KSC-5601로 변환되어 6바이트여야 함
                if (parsed[1].value.length !== 6) return 'name 바이트 길이 불일치 (예상: 6, 실제: ' + parsed[1].value.length + ')';
                
                // 디코딩해서 원본 확인
                const decoded = KSC5601.decode(parsed[1].value);
                if (decoded !== '홍길동') return 'name 디코딩 실패 (결과: ' + decoded + ')';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 13: 유니코드 전각 문자 처리
            // =========================================
            test('KSC-5601 인코딩 - 전각 영문자 정규화', function() {
                // 전각 K (U+FF2B) 입력 시 반각 K로 정규화 후 KSC-5601 인코딩
                const fullwidthK = String.fromCharCode(0xFF2B); // 'Ｋ'
                const encoded = KSC5601.encode(fullwidthK);
                
                // 반각 K와 동일하게 A3CB로 인코딩되어야 함
                if (encoded.length !== 2) return '인코딩 길이 불일치 (예상: 2, 실제: ' + encoded.length + ')';
                if (encoded[0] !== 0xA3) return '첫 번째 바이트 불일치 (예상: A3, 실제: ' + encoded[0].toString(16) + ')';
                if (encoded[1] !== 0xCB) return '두 번째 바이트 불일치 (예상: CB, 실제: ' + encoded[1].toString(16) + ')';
                
                return true;
            });

            test('KSC-5601 인코딩 - 전각 숫자 정규화', function() {
                // 전각 1 (U+FF11) 입력 시 반각 1로 정규화 후 KSC-5601 인코딩
                const fullwidth1 = String.fromCharCode(0xFF11); // '１'
                const encoded = KSC5601.encode(fullwidth1);
                
                // 반각 1과 동일하게 A3B1로 인코딩되어야 함
                if (encoded.length !== 2) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xB1) return '인코딩 값 불일치';
                
                return true;
            });

            test('KSC-5601 인코딩 - 전각 공백 정규화', function() {
                // 전각 공백 (U+3000) 입력 시 KSC-5601 전각 공백으로 인코딩
                const fullwidthSpace = String.fromCharCode(0x3000); // '　'
                const encoded = KSC5601.encode(fullwidthSpace);
                
                // A1A1 (KSC-5601 전각 공백)로 인코딩되어야 함
                if (encoded.length !== 2) return '인코딩 길이 불일치';
                if (encoded[0] !== 0xA1 || encoded[1] !== 0xA1) return '인코딩 값 불일치';
                
                return true;
            });

            test('KSC-5601 인코딩 - 반각/전각 혼합', function() {
                // 반각 'A' + 전각 'Ｂ' (U+FF22) + 한글 '가'
                const mixed = 'A' + String.fromCharCode(0xFF22) + '가';
                const encoded = KSC5601.encode(mixed);
                
                // 3문자 = 6바이트
                if (encoded.length !== 6) return '인코딩 길이 불일치 (예상: 6, 실제: ' + encoded.length + ')';
                // A: A3C1
                if (encoded[0] !== 0xA3 || encoded[1] !== 0xC1) return 'A 인코딩 실패';
                // B: A3C2
                if (encoded[2] !== 0xA3 || encoded[3] !== 0xC2) return 'B 인코딩 실패';
                // 가: B0A1
                if (encoded[4] !== 0xB0 || encoded[5] !== 0xA1) return '가 인코딩 실패';
                
                return true;
            });

            return { passed: passed, failed: failed, results: results };
        }

        /**
         * =====================================================
         * 테스트 결과 표시 함수
         * 테스트 결과를 UI에 표시
         * =====================================================
         * @param {Object} testResult - runTests()의 반환값
         */
        function displayTestResults(testResult) {
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            const div = document.createElement('div');
            div.className = 'test-results ' + (testResult.failed === 0 ? 'success' : 'failure');

            const title = document.createElement('h3');
            title.textContent = '테스트 결과: ' + testResult.passed + '개 통과, ' + testResult.failed + '개 실패';
            div.appendChild(title);

            testResult.results.forEach(function(result) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                if (result.passed) {
                    item.innerHTML = '<span class="test-pass">✓</span> ' + result.name;
                } else {
                    item.innerHTML = '<span class="test-fail">✗</span> ' + result.name + 
                                   ' <small>(' + result.reason + ')</small>';
                }
                
                div.appendChild(item);
            });

            container.appendChild(div);
        }

        // =========================================
        // DOMContentLoaded 이벤트 - 이벤트 리스너 등록
        // =========================================
        document.addEventListener('DOMContentLoaded', function() {
            // =========================================
            // 서브 탭 (파싱/생성 모드) 전환 이벤트 - struct-tab
            // =========================================
            document.querySelectorAll('#struct-tab .sub-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    
                    // struct-tab 내 버튼 비활성화
                    document.querySelectorAll('#struct-tab .sub-tab-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    
                    // 클릭된 버튼 활성화
                    this.classList.add('active');
                    
                    // struct-tab 내 컨텐츠 숨김
                    document.querySelectorAll('#struct-tab .sub-mode-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 선택된 모드 컨텐츠 표시
                    const selectedContent = document.getElementById(`${mode}-mode-content`);
                    selectedContent.classList.add('active');
                    
                    // 결과 영역 초기화
                    document.getElementById('struct-result-container').innerHTML = '';
                    
                    console.log(`struct-tab 모드 전환: ${mode}`);
                });
            });

            // =========================================
            // 서브 탭 (파싱/생성 모드) 전환 이벤트 - xml-tab
            // =========================================
            document.querySelectorAll('#xml-tab .sub-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    
                    // xml-tab 내 버튼 비활성화
                    document.querySelectorAll('#xml-tab .sub-tab-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    
                    // 클릭된 버튼 활성화
                    this.classList.add('active');
                    
                    // xml-tab 내 컨텐츠 숨김
                    document.querySelectorAll('#xml-tab .sub-mode-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 선택된 모드 컨텐츠 표시
                    document.getElementById(`xml-${mode}-mode`).classList.add('active');
                    
                    // 결과 영역 초기화
                    document.getElementById('result-container').innerHTML = '';
                    
                    console.log(`xml-tab 모드 전환: ${mode}`);
                });
            });

            // =========================================
            // 구조체 카드 초기화 - 첫 번째 카드 자동 추가
            // =========================================
            const structContainer = document.getElementById('struct-definitions-container');
            structContainer.appendChild(createStructCard(0));
            structCardIndex = 1;

            // =========================================
            // 구조체 추가 버튼 클릭 이벤트
            // =========================================
            document.getElementById('add-struct-btn').addEventListener('click', function() {
                const newCard = createStructCard(structCardIndex);
                structContainer.appendChild(newCard);
                structCardIndex++;
            });

            // =========================================
            // 구조체 삭제 버튼 이벤트 위임
            // =========================================
            structContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-struct-btn')) {
                    // 클릭된 버튼의 부모 .struct-card 찾기
                    const card = e.target.closest('.struct-card');
                    if (!card) return;

                    // 확인 대화상자
                    if (confirm('이 구조체를 삭제하시겠습니까?')) {
                        // 해당 카드 제거
                        card.remove();

                        // 남은 카드가 0개면 structCardIndex를 0으로 리셋
                        const remainingCards = structContainer.querySelectorAll('.struct-card');
                        if (remainingCards.length === 0) {
                            structCardIndex = 0;
                        }
                    }
                }
            });

            // =========================================
            // 미리보기 복사 버튼 이벤트 위임
            // =========================================
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('copy-preview-btn')) {
                    const telegram = e.target.dataset.telegram;
                    // HTML 엔티티 디코딩
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = telegram;
                    const decodedTelegram = textarea.value;
                    
                    navigator.clipboard.writeText(decodedTelegram).then(function() {
                        e.target.textContent = '✓ 복사됨';
                        setTimeout(function() {
                            e.target.textContent = '📋 복사';
                        }, 2000);
                    }).catch(function(err) {
                        console.error('복사 실패:', err);
                        // 폴백: 수동 복사 안내
                        alert('자동 복사에 실패했습니다. 텍스트를 직접 선택하여 복사해주세요.');
                    });
                }
            });

            // 도움말 토글 이벤트
            const helpToggle = document.querySelector('.help-toggle');
            const helpContent = document.querySelector('.help-content');
            
            if (helpToggle && helpContent) {
                helpToggle.addEventListener('click', function() {
                    helpToggle.classList.toggle('expanded');
                    helpContent.classList.toggle('expanded');
                });
            }

            // 탭 전환 이벤트
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // 모든 탭 버튼에서 active 제거
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // 클릭된 버튼에 active 추가
                    this.classList.add('active');

                    // 모든 탭 콘텐츠 숨기기
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // 선택된 탭 콘텐츠 표시
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // 샘플 로드 버튼 클릭 이벤트
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML 규격 샘플 설정
                const sampleXml = `<packet id="송금전문" default=" ">
  <col id="헤더시작" type="X" size="6" />
  <col id="거래구분" type="X" size="2" />
  <col id="계좌번호" type="N" size="12" />
  <col id="송금액" type="N" size="15" />
  <col id="받는사람" type="X" size="20" />
  <col id="비고" type="FULL" size="10" />
</packet>`;
                
                // 통전문 샘플 설정 (65 bytes: 55 + 10bytes FULL)
                // FULL 타입 필드는 KSC-5601 2바이트 완성형 인코딩
                // 'OK테스트' (영문2 + 한글3 = 5글자) = 10bytes
                // O→A3CF, K→A3CB, 테→C5D7, 스→BDBA, 트→C6AE
                const kscMixed = String.fromCharCode(
                    0xA3, 0xCF,  // O (전각)
                    0xA3, 0xCB,  // K (전각)
                    0xC5, 0xD7,  // 테
                    0xBD, 0xBA,  // 스
                    0xC6, 0xAE   // 트
                );
                const sampleTelegram = 'HEADER01123456789012000000000100000Hong Gil Dong       ' + kscMixed;
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // 파싱 실행 버튼 클릭 이벤트
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-input과 telegram-input 값 가져오기
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. 둘 다 trim()해서 빈 문자열이면 에러 표시 후 return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("입력값을 확인하세요", 'result-container');
                    return;
                }

                // 3. parseXMLSpec 호출, 결과가 null이면 에러 표시 후 return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML 파싱 실패: 형식을 확인하세요", 'result-container');
                    return;
                }

                // 4. parseTelegram 호출
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults 호출
                displayResults(parsedData);
            });

            // 초기화 버튼 클릭 이벤트
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // 구조체 샘플 로드 버튼 클릭 이벤트
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // 1. recognize-crlf 체크박스 자동 체크
                document.getElementById('recognize-crlf').checked = true;
                
                // 2. 기존 모든 구조체 카드 삭제
                structContainer.innerHTML = '';
                
                // 3. structCardIndex = 0 리셋
                structCardIndex = 0;

                // 4. 구조체 3개 추가
                const sampleStructs = [
                    {
                        // 카드 1: DHF_H
                        name: 'DHF_H',
                        kubun: 'H',
                        definition: `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
  char crlf[2];
} DHF_H;`
                    },
                    {
                        // 카드 2: DHF_D
                        name: 'DHF_D',
                        kubun: 'D',
                        definition: `typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
  char crlf[2];
} DHF_D;`
                    },
                    {
                        // 카드 3: DHF_T
                        name: 'DHF_T',
                        kubun: 'T',
                        definition: `typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
  char crlf[2];
} DHF_T;`
                    }
                ];

                // 각 샘플 구조체마다 카드 생성
                sampleStructs.forEach(function(sample) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);
                    
                    // 카드 내부 입력 필드에 값 설정
                    card.querySelector('.struct-name').value = sample.name;
                    card.querySelector('.struct-kubun').value = sample.kubun;
                    card.querySelector('.struct-definition').value = sample.definition;
                    
                    structCardIndex++;
                });

                // 5. 데이터 설정
                // DHF_H: 1+2+7+2 = 12 bytes (데이터 10 + CRLF 2)
                // DHF_D: 1+16+20+2 = 39 bytes (데이터 37 + CRLF 2)
                // DHF_T: 1+10+20+2 = 33 bytes (데이터 31 + CRLF 2)
                // 일반적인 줄바꿈으로 입력, 각 줄에 \r\n 자동 추가됨
                const sampleData = `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`;

                document.getElementById('struct-data').value = sampleData;
                
                // 6. 완료 메시지 표시
                alert('✓ 샘플 로드 완료\n\n개행문자 인식이 활성화되었습니다.\n각 레코드 끝에 자동으로 CRLF가 추가됩니다.');
            });

            /**
             * =====================================================
             * 테스트 케이스 정의
             * =====================================================
             * 
             * [개행 인식 ON 모드 테스트]
             * - normal: 정상 데이터 - 각 라인이 올바른 길이
             * - short: 길이 부족 - 라인 길이가 구조체 정의보다 짧음
             * - long: 길이 초과 - 라인 길이가 구조체 정의보다 김
             * - mismatch: 매칭 실패 - 구분값에 해당하는 구조체 없음
             * - mixed: 혼합 - 다양한 에러 상황 조합
             * 
             * [개행 인식 OFF 모드 테스트]
             * - continuous: 연속 데이터 - 개행 없이 연속된 레코드
             * - continuous_multi: 연속 다중 - 여러 타입 연속 레코드
             * 
             * 테스트 시 주의사항:
             * - 개행 인식 ON: 각 줄 끝에 CRLF(2 bytes) 자동 추가
             * - 개행 인식 OFF: 모든 줄바꿈 제거 후 연속 파싱
             */
            const testCases = {
                // ========== 개행 인식 ON 테스트 케이스 ==========
                normal: {
                    name: '정상 데이터 (개행 ON)',
                    description: '각 라인 독립 파싱, CRLF 필드 정확히 표시, 길이 뱃지 녹색',
                    mode: 'line-by-line',
                    data: `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`
                },
                short: {
                    name: '길이 부족 (개행 ON)',
                    description: '경고 표시, 다음 라인 침범 안 함, 에러 카드 표시',
                    mode: 'line-by-line',
                    data: `H88123
D12345678901234560000000000000000100
T00000000020000000000000000300`
                },
                long: {
                    name: '길이 초과 (개행 ON)',
                    description: '길이 초과 경고 표시',
                    mode: 'line-by-line',
                    data: `H88123456789999
D123456789012345600000000000000001000`
                },
                mismatch: {
                    name: '매칭 실패 (개행 ON)',
                    description: '에러 카드로 표시, 다음 라인 정상 파싱',
                    mode: 'line-by-line',
                    data: `X1234567890
D123456789012345600000000000000001000`
                },
                mixed: {
                    name: '혼합 테스트 (개행 ON)',
                    description: '정상/부족/초과/매칭실패 혼합',
                    mode: 'line-by-line',
                    data: `H881234567
D123456789012345600000000000000001000
X9999999999
D12345
H88123456789999
T000000000200000000000000003000`
                },
                
                // ========== 개행 인식 OFF 테스트 케이스 ==========
                continuous: {
                    name: '연속 데이터 (개행 OFF)',
                    description: '구분값으로 자동 분리, 줄바꿈 완전 무시',
                    mode: 'continuous',
                    data: `H881234567D123456789012345600000000000000001000D987654321098765400000000000000002000T000000000200000000000000003000`
                },
                continuous_multi: {
                    name: '연속 다중 레코드 (개행 OFF)',
                    description: 'H-D-D-T 순서 연속, 여러 레코드 파싱',
                    mode: 'continuous',
                    data: `H881234567D123456789012345600000000000000001000T0000000001000000000000000010H991234567D987654321098765400000000000000002000T0000000001000000000000000020`
                }
            };

            // 테스트 케이스 모달 관련 요소
            const testModal = document.getElementById('test-case-modal');
            const testBtn = document.getElementById('struct-test-btn');
            const closeTestBtn = testModal.querySelector('.close-test');
            const testButtons = testModal.querySelectorAll('.test-buttons button');

            // 테스트 케이스 버튼 클릭 시 모달 표시
            testBtn.addEventListener('click', function() {
                testModal.classList.add('show');
            });

            // 닫기 버튼 클릭 시 모달 닫기
            closeTestBtn.addEventListener('click', function() {
                testModal.classList.remove('show');
            });

            // 모달 배경 클릭 시 닫기
            testModal.addEventListener('click', function(e) {
                if (e.target === testModal) {
                    testModal.classList.remove('show');
                }
            });

            /**
             * 테스트 케이스 버튼 클릭 이벤트 핸들러
             * - 테스트 케이스 mode에 따라 개행 인식 옵션 자동 설정
             * - line-by-line: 개행 인식 ON (각 줄 독립 파싱)
             * - continuous: 개행 인식 OFF (연속 데이터 파싱)
             */
            testButtons.forEach(function(button) {
                button.addEventListener('click', function() {
                    const caseType = this.getAttribute('data-case');
                    const testCase = testCases[caseType];
                    
                    if (!testCase) return;

                    // 1. 테스트 케이스 모드에 따라 개행 인식 체크박스 설정
                    // line-by-line 모드 = 개행 인식 ON
                    // continuous 모드 = 개행 인식 OFF
                    const isLineByLineMode = testCase.mode === 'line-by-line';
                    document.getElementById('recognize-crlf').checked = isLineByLineMode;
                    
                    // 2. 기존 모든 구조체 카드 삭제
                    structContainer.innerHTML = '';
                    
                    // 3. structCardIndex = 0 리셋
                    structCardIndex = 0;

                    // 4. 구조체 정의 설정
                    // 개행 인식 ON: CRLF 필드 포함
                    // 개행 인식 OFF: CRLF 필드 제외 (연속 데이터이므로)
                    const sampleStructs = isLineByLineMode 
                        ? [
                            // === 개행 인식 ON용 구조체 (CRLF 필드 포함) ===
                            {
                                name: 'DHF_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'H'
  char bank_cd[2];       // 은행 코드
  char cust_id[7];       // 고객 ID
  char crlf[2];          // 개행문자 (CRLF)
} DHF_H;`
                            },
                            {
                                name: 'DHF_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'D'
  char acno[16];         // 계좌번호
  char amt[20];          // 금액
  char crlf[2];          // 개행문자 (CRLF)
} DHF_D;`
                            },
                            {
                                name: 'DHF_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'T'
  char tot_cnt[10];      // 총 건수
  char tot_amt[20];      // 총 금액
  char crlf[2];          // 개행문자 (CRLF)
} DHF_T;`
                            }
                        ]
                        : [
                            // === 개행 인식 OFF용 구조체 (CRLF 필드 제외) ===
                            {
                                name: 'DHF_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'H'
  char bank_cd[2];       // 은행 코드
  char cust_id[7];       // 고객 ID
} DHF_H;  // 총 10 bytes (개행 없음)`
                            },
                            {
                                name: 'DHF_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'D'
  char acno[16];         // 계좌번호
  char amt[20];          // 금액
} DHF_D;  // 총 37 bytes (개행 없음)`
                            },
                            {
                                name: 'DHF_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'T'
  char tot_cnt[10];      // 총 건수
  char tot_amt[20];      // 총 금액
} DHF_T;  // 총 31 bytes (개행 없음)`
                            }
                        ];

                    // 각 샘플 구조체마다 카드 생성
                    sampleStructs.forEach(function(sample) {
                        const card = createStructCard(structCardIndex);
                        structContainer.appendChild(card);
                        
                        card.querySelector('.struct-name').value = sample.name;
                        card.querySelector('.struct-kubun').value = sample.kubun;
                        card.querySelector('.struct-definition').value = sample.definition;
                        
                        structCardIndex++;
                    });

                    // 5. 테스트 데이터 설정
                    document.getElementById('struct-data').value = testCase.data;
                    
                    // 6. 모달 닫기
                    testModal.classList.remove('show');
                    
                    // 7. 완료 메시지 표시 (모드 정보 포함)
                    const modeInfo = isLineByLineMode 
                        ? '개행문자 인식이 활성화되었습니다.\n각 레코드 끝에 CRLF(2 bytes)가 있습니다.'
                        : '개행문자 인식이 비활성화되었습니다.\n연속 데이터로 파싱됩니다.';
                    
                    alert('✓ 테스트 케이스 로드 완료\n\n' +
                          '테스트: ' + testCase.name + '\n' +
                          '설명: ' + (testCase.description || '') + '\n\n' +
                          modeInfo);
                });
            });

            // ESC 키로 테스트 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && testModal.classList.contains('show')) {
                    testModal.classList.remove('show');
                }
            });

            // 구조체 파싱 실행 버튼 클릭 이벤트
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                // 1. collectStructDefinitions() 호출
                const structDefs = collectStructDefinitions();
                
                // null이면 중단 (에러는 함수 내부에서 표시)
                if (structDefs === null) {
                    return;
                }

                // 2. struct-data 값 가져오기, trim
                const data = document.getElementById('struct-data').value.trim();
                
                // 비어있으면 displayError("데이터를 입력하세요")
                if (data === '') {
                    displayError('데이터를 입력하세요', 'struct-result-container');
                    return;
                }

                // 3. parseStructData(data, structDefs) 호출
                const result = parseStructData(data, structDefs);
                
                // structDefs를 result에 추가
                result.structDefs = structDefs;

                // 4. displayStructResults(result) 호출
                displayStructResults(result);

                // 5. 성공 시 콘솔에 로그
                const count = result.stats.recordCount;
                const percent = result.stats.totalBytes > 0 
                    ? ((result.stats.parsedBytes / result.stats.totalBytes) * 100).toFixed(1)
                    : 0;
                console.log('파싱 완료: 레코드 ' + count + '개, 성공률 ' + percent + '%');
            });

            // 구조체 초기화 버튼 클릭 이벤트
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                // 확인 대화상자
                if (!confirm('모든 입력을 초기화하시겠습니까?')) {
                    return;
                }
                
                // 1. struct-definitions-container innerHTML = ''
                structContainer.innerHTML = '';
                
                // 2. struct-data value = ''
                document.getElementById('struct-data').value = '';
                
                // 3. struct-result-container innerHTML = ''
                document.getElementById('struct-result-container').innerHTML = '';
                
                // 4. structCardIndex = 0
                structCardIndex = 0;
                
                // 5. 첫 번째 빈 카드 자동 추가
                structContainer.appendChild(createStructCard(structCardIndex));
                structCardIndex++;
            });

            // 테스트 실행 버튼 클릭 이벤트 (버튼이 존재할 경우에만)
            const runTestsBtn = document.getElementById('run-tests-btn');
            if (runTestsBtn) {
                runTestsBtn.addEventListener('click', function() {
                    const testResult = runTests();
                    displayTestResults(testResult);
                });
            }

            // 복사 버튼 클릭 이벤트 (이벤트 위임 사용)
            document.getElementById('struct-result-container').addEventListener('click', function(e) {
                // 클릭된 요소가 복사 버튼인지 확인
                if (!e.target.classList.contains('copy-record-btn')) {
                    return;
                }

                const btn = e.target;

                // 1. data-record 속성에서 recordIndex 가져오기
                const recordIndex = btn.getAttribute('data-record');

                // 해당 레코드의 그룹 찾기
                const groupDiv = btn.closest('.struct-result-group');
                if (!groupDiv) {
                    return;
                }

                // 테이블의 tbody에서 모든 행 가져오기
                const tbody = groupDiv.querySelector('tbody');
                if (!tbody) {
                    return;
                }

                const rows = tbody.querySelectorAll('tr');
                
                // 2. TSV 형식으로 변환 (필드명\t크기\t값)
                const tsvLines = [];
                rows.forEach(function(row) {
                    const cells = row.querySelectorAll('td');
                    // 5개 컬럼: 필드명, 크기, 시작, 종료, 값
                    if (cells.length >= 5) {
                        const fieldName = cells[0].textContent;  // 필드명
                        const size = cells[1].textContent;       // 크기
                        const value = cells[4].textContent;      // 값
                        tsvLines.push(fieldName + '\t' + size + '\t' + value);
                    }
                });

                const tsvText = tsvLines.join('\n');

                // 3. 클립보드에 복사
                navigator.clipboard.writeText(tsvText).then(function() {
                    // 4. 복사 성공 시:
                    // - 버튼 텍스트 → "✓ 복사됨"
                    const originalText = btn.textContent;
                    const originalBg = btn.style.backgroundColor;
                    
                    btn.textContent = '✓ 복사됨';
                    // - 배경색 임시 변경
                    btn.style.backgroundColor = '#17a2b8';
                    
                    // - 2초 후 원래대로
                    setTimeout(function() {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = originalBg;
                    }, 2000);
                }).catch(function(err) {
                    console.error('클립보드 복사 실패:', err);
                    alert('복사에 실패했습니다.');
                });
            });

            // =========================================
            // 구조체 카드 접기/펼치기 이벤트
            // - 헤더 클릭 시 본문 토글
            // - 아이콘 변경 (▼ ↔ ▶)
            // =========================================
            structContainer.addEventListener('click', function(e) {
                // 삭제 버튼이나 드래그 핸들 클릭 시 무시
                if (e.target.classList.contains('remove-struct-btn') || 
                    e.target.classList.contains('drag-handle')) {
                    return;
                }

                // 헤더 영역 클릭 확인
                const header = e.target.closest('.struct-card-header');
                if (!header) return;

                const card = header.closest('.struct-card');
                if (!card) return;

                // collapsed 클래스 토글
                card.classList.toggle('collapsed');

                // 접힌 상태에서 구조체명 미리보기 업데이트
                updateStructPreview(card);
            });

            /**
             * 구조체 미리보기 텍스트 업데이트
             * @param {HTMLElement} card - 구조체 카드 요소
             */
            function updateStructPreview(card) {
                const preview = card.querySelector('.struct-preview');
                const nameInput = card.querySelector('.struct-name');
                const kubunInput = card.querySelector('.struct-kubun');

                if (card.classList.contains('collapsed') && preview) {
                    const name = nameInput ? nameInput.value.trim() : '';
                    const kubun = kubunInput ? kubunInput.value.trim() : '';
                    
                    let previewText = '';
                    if (name) previewText += name;
                    if (kubun) previewText += (name ? ' ' : '') + '[' + kubun + ']';
                    
                    preview.textContent = previewText ? '- ' + previewText : '';
                } else if (preview) {
                    preview.textContent = '';
                }
            }

            // 입력값 변경 시 미리보기 업데이트
            structContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('struct-name') || 
                    e.target.classList.contains('struct-kubun')) {
                    const card = e.target.closest('.struct-card');
                    if (card) updateStructPreview(card);
                }
            });

            // =========================================
            // 드래그 앤 드롭 재정렬 기능
            // HTML5 Drag API 사용
            // =========================================
            let draggedCard = null;

            // 드래그 시작
            structContainer.addEventListener('dragstart', function(e) {
                const card = e.target.closest('.struct-card');
                if (!card) return;

                draggedCard = card;
                card.classList.add('dragging');

                // 드래그 이미지 설정 (선택사항)
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', card.getAttribute('data-index'));
            });

            // 드래그 종료
            structContainer.addEventListener('dragend', function(e) {
                const card = e.target.closest('.struct-card');
                if (card) {
                    card.classList.remove('dragging');
                }
                draggedCard = null;

                // 모든 drag-over 클래스 제거
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });

                // 카드 인덱스 재정렬
                renumberStructCards();
            });

            // 드래그 오버
            structContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                const card = e.target.closest('.struct-card');
                if (!card || card === draggedCard) return;

                // drag-over 클래스 추가
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });
                card.classList.add('drag-over');
            });

            // 드롭
            structContainer.addEventListener('drop', function(e) {
                e.preventDefault();

                const targetCard = e.target.closest('.struct-card');
                if (!targetCard || !draggedCard || targetCard === draggedCard) return;

                // 드래그한 카드를 타겟 위치로 이동
                const cards = Array.from(structContainer.querySelectorAll('.struct-card'));
                const draggedIndex = cards.indexOf(draggedCard);
                const targetIndex = cards.indexOf(targetCard);

                if (draggedIndex < targetIndex) {
                    // 아래로 이동
                    targetCard.parentNode.insertBefore(draggedCard, targetCard.nextSibling);
                } else {
                    // 위로 이동
                    targetCard.parentNode.insertBefore(draggedCard, targetCard);
                }

                targetCard.classList.remove('drag-over');
            });

            /**
             * 구조체 카드 번호 재정렬
             */
            function renumberStructCards() {
                const cards = structContainer.querySelectorAll('.struct-card');
                cards.forEach(function(card, index) {
                    const numberSpan = card.querySelector('.struct-number');
                    if (numberSpan) {
                        numberSpan.textContent = '구조체 #' + (index + 1);
                    }
                    card.setAttribute('data-index', index);
                });
            }

            // =========================================
            // 로컬 스토리지 저장/복원 기능
            // - 페이지 떠날 때 자동 저장
            // - 재방문 시 복원 제안
            // =========================================
            const STORAGE_KEY = 'structParserData';

            /**
             * 현재 구조체 정의들을 로컬 스토리지에 저장
             */
            function saveToLocalStorage() {
                const cards = structContainer.querySelectorAll('.struct-card');
                const data = [];

                cards.forEach(function(card) {
                    const name = card.querySelector('.struct-name').value;
                    const kubun = card.querySelector('.struct-kubun').value;
                    const definition = card.querySelector('.struct-definition').value;
                    const collapsed = card.classList.contains('collapsed');

                    // 하나라도 입력된 카드만 저장
                    if (name || kubun || definition) {
                        data.push({
                            name: name,
                            kubun: kubun,
                            definition: definition,
                            collapsed: collapsed
                        });
                    }
                });

                // 데이터가 있을 때만 저장
                if (data.length > 0) {
                    const saveData = {
                        structs: data,
                        structData: document.getElementById('struct-data').value,
                        savedAt: new Date().toISOString()
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
                    console.log('로컬 스토리지에 저장됨:', data.length + '개 구조체');
                }
            }

            /**
             * 로컬 스토리지에서 복원
             */
            function restoreFromLocalStorage() {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (!savedData) return;

                try {
                    const data = JSON.parse(savedData);
                    if (!data.structs || data.structs.length === 0) return;

                    // 저장 시간 표시
                    const savedAt = new Date(data.savedAt);
                    const timeStr = savedAt.toLocaleString('ko-KR');

                    // 복원 알림 표시
                    showRestoreNotification(data, timeStr);
                } catch (e) {
                    console.error('로컬 스토리지 데이터 파싱 실패:', e);
                }
            }

            /**
             * 복원 알림 UI 표시
             */
            function showRestoreNotification(data, timeStr) {
                // 기존 알림 제거
                const existingNotif = document.querySelector('.restore-notification');
                if (existingNotif) existingNotif.remove();

                const notification = document.createElement('div');
                notification.className = 'restore-notification';
                notification.innerHTML = `
                    <span class="restore-notification-text">
                        📁 이전 작업을 복원할 수 있습니다 (${timeStr}, ${data.structs.length}개 구조체)
                    </span>
                    <div class="restore-notification-actions">
                        <button class="restore-btn primary" id="restore-yes">복원</button>
                        <button class="restore-btn secondary" id="restore-no">무시</button>
                    </div>
                `;

                // DOM에 삽입할 위치 찾기
                let inserted = false;
                
                // 1순위: struct-definitions-area 앞에 삽입
                const inputSection = document.getElementById('struct-definitions-area');
                if (inputSection && inputSection.parentNode) {
                    inputSection.parentNode.insertBefore(notification, inputSection);
                    inserted = true;
                }
                
                // 2순위: struct-tab에 추가
                if (!inserted) {
                    const structTab = document.getElementById('struct-tab');
                    if (structTab) {
                        if (structTab.firstChild) {
                            structTab.insertBefore(notification, structTab.firstChild);
                        } else {
                            structTab.appendChild(notification);
                        }
                        inserted = true;
                    }
                }
                
                // 3순위: body에 추가 (최후의 fallback)
                if (!inserted) {
                    document.body.appendChild(notification);
                    inserted = true;
                }

                // 알림 내부의 버튼에 이벤트 연결 (notification 내부에서 찾기)
                const restoreYesBtn = notification.querySelector('#restore-yes');
                const restoreNoBtn = notification.querySelector('#restore-no');
                
                if (restoreYesBtn) {
                    restoreYesBtn.addEventListener('click', function() {
                        doRestore(data);
                        notification.remove();
                    });
                }

                if (restoreNoBtn) {
                    restoreNoBtn.addEventListener('click', function() {
                        notification.remove();
                        localStorage.removeItem(STORAGE_KEY); // 저장된 데이터 삭제
                    });
                }
            }

            /**
             * 실제 복원 수행
             */
            function doRestore(data) {
                // 기존 카드 삭제
                structContainer.innerHTML = '';
                structCardIndex = 0;

                // 저장된 구조체 복원
                data.structs.forEach(function(struct) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);

                    card.querySelector('.struct-name').value = struct.name || '';
                    card.querySelector('.struct-kubun').value = struct.kubun || '';
                    card.querySelector('.struct-definition').value = struct.definition || '';

                    if (struct.collapsed) {
                        card.classList.add('collapsed');
                        updateStructPreview(card);
                    }

                    structCardIndex++;
                });

                // 데이터 복원
                if (data.structData) {
                    document.getElementById('struct-data').value = data.structData;
                }

                console.log('로컬 스토리지에서 복원됨:', data.structs.length + '개 구조체');
            }

            // 페이지 떠날 때 자동 저장
            window.addEventListener('beforeunload', function() {
                saveToLocalStorage();
            });

            // 페이지 로드 시 복원 제안 표시
            // 구조체 탭이 활성화될 때까지 대기
            setTimeout(function() {
                restoreFromLocalStorage();
            }, 100);

            // =========================================
            // 다크모드 토글 기능
            // - localStorage에 테마 설정 저장
            // =========================================
            const THEME_KEY = 'structParserTheme';
            const themeToggle = document.getElementById('theme-toggle');

            /**
             * 테마 초기화
             */
            function initTheme() {
                const savedTheme = localStorage.getItem(THEME_KEY);
                if (savedTheme === 'dark') {
                    document.body.classList.add('dark-mode');
                    themeToggle.textContent = '☀️';
                } else {
                    themeToggle.textContent = '🌙';
                }
            }

            /**
             * 테마 토글
             */
            function toggleTheme() {
                const isDark = document.body.classList.toggle('dark-mode');
                localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
                themeToggle.textContent = isDark ? '☀️' : '🌙';
            }

            // 테마 초기화
            initTheme();

            // 테마 토글 버튼 클릭 이벤트
            themeToggle.addEventListener('click', toggleTheme);

            // =========================================
            // 키보드 단축키
            // - Ctrl+Enter: 파싱 실행
            // - Ctrl+N: 구조체 추가
            // =========================================
            document.addEventListener('keydown', function(e) {
                // Ctrl+Enter: 파싱 실행
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    
                    // 현재 활성화된 탭 확인
                    const xmlTabActive = document.getElementById('xml-tab').classList.contains('active');
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');

                    if (xmlTabActive) {
                        document.getElementById('parse-btn').click();
                    } else if (structTabActive) {
                        document.getElementById('struct-parse-btn').click();
                    }
                }

                // Ctrl+N: 구조체 추가 (struct 탭에서만)
                if (e.ctrlKey && e.key === 'n') {
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');
                    if (structTabActive) {
                        e.preventDefault();
                        document.getElementById('add-struct-btn').click();
                    }
                }
            });

            /**
             * =====================================================
             * 개행문자 인식 (CRLF) 체크박스 변경 이벤트
             * =====================================================
             * 
             * [옵션 전환 동작]
             * - 체크(ON): 라인 기반 파싱 모드
             *   → 각 줄을 독립 레코드로 처리
             *   → CRLF(2 bytes)가 레코드 끝에 자동 추가
             * 
             * - 해제(OFF): 연속 데이터 파싱 모드
             *   → 모든 줄바꿈 제거 후 연속 파싱
             *   → 구분값 기반 레코드 분리
             * 
             * [사용자 확인]
             * - 기존 데이터/결과가 있으면 재파싱 확인
             * - 취소 시 체크 상태 롤백
             */
            document.getElementById('recognize-crlf').addEventListener('change', function(e) {
                const isChecked = e.target.checked;
                const hasData = document.getElementById('struct-data').value.trim().length > 0;
                const hasResults = document.getElementById('struct-result-container').children.length > 0;

                if (hasData || hasResults) {
                    const confirmed = confirm(
                        '옵션을 변경하면 기존 파싱 결과가 영향을 받을 수 있습니다.\n' +
                        '다시 파싱하시겠습니까?'
                    );

                    if (confirmed) {
                        // 결과 초기화
                        document.getElementById('struct-result-container').innerHTML = '';

                        // 알림
                        const msg = isChecked
                            ? '개행문자 인식이 활성화되었습니다. 각 레코드 끝에 CRLF(2 bytes)가 추가됩니다.'
                            : '개행문자 인식이 비활성화되었습니다. 모든 줄바꿈이 제거됩니다.';

                        // 임시 메시지 표시
                        showTemporaryMessage(msg);
                    } else {
                        // 변경 취소
                        e.target.checked = !isChecked;
                    }
                }
            });

            /**
             * 임시 메시지 표시 함수
             * @param {string} message - 표시할 메시지
             */
            function showTemporaryMessage(message) {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'temporary-message';
                msgDiv.textContent = message;
                document.body.appendChild(msgDiv);

                setTimeout(function() {
                    msgDiv.classList.add('fade-out');
                    setTimeout(function() {
                        msgDiv.remove();
                    }, 300);
                }, 3000);
            }

            // =========================================
            // 도움말 모달 이벤트 핸들러
            // =========================================
            const crlfHelpBtn = document.getElementById('crlf-help');
            const crlfHelpModal = document.getElementById('crlf-help-modal');
            const closeHelpBtn = crlfHelpModal.querySelector('.close-help');

            // 도움말 아이콘 클릭 시 모달 표시
            crlfHelpBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                crlfHelpModal.classList.add('show');
            });

            // 닫기 버튼 클릭 시 모달 닫기
            closeHelpBtn.addEventListener('click', function() {
                crlfHelpModal.classList.remove('show');
            });

            // 모달 배경 클릭 시 닫기
            crlfHelpModal.addEventListener('click', function(e) {
                if (e.target === crlfHelpModal) {
                    crlfHelpModal.classList.remove('show');
                }
            });

            // ESC 키로 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && crlfHelpModal.classList.contains('show')) {
                    crlfHelpModal.classList.remove('show');
                }
            });

            // =========================================
            // 전문 생성 폼 이벤트 핸들러
            // =========================================
            
            /**
             * 숫자 필드 여부 확인 헬퍼 함수
             * - cd, code는 자동 판단에서 제외 (사용자 선택에 맡김)
             * @param {string} fieldName - 필드명
             * @returns {boolean} 숫자 필드 여부
             */
            function isNumericField(fieldName) {
                // cd, code는 사용자 판단에 맡기므로 제외
                const numericPatterns = /amt|amount|cnt|count|num|number|price|qty|quantity|seq|no/i;
                return numericPatterns.test(fieldName);
            }
            
            /**
             * cd/code 포함 필드 여부 확인 (사용자 선택 필요 필드)
             * @param {string} fieldName - 필드명
             * @returns {boolean} cd/code 포함 여부
             */
            function isUserChoiceField(fieldName) {
                return /cd|code/i.test(fieldName);
            }
            
            /**
             * 필드 입력 행 생성 함수
             * @param {Object} field - 필드 정의 객체
             * @param {number} index - 필드 인덱스
             * @param {boolean} recognizeCRLF - CRLF 인식 여부
             * @returns {HTMLTableRowElement} 테이블 행 요소
             */
            function createFieldRow(field, index, recognizeCRLF) {
                const tr = document.createElement('tr');
                
                // CRLF 필드 특수 처리
                const isCRLFField = field.name.toLowerCase().match(/crlf|cr_lf|newline|eol/);
                
                if (isCRLFField && recognizeCRLF) {
                    // 자동 설정 필드
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            <span class="field-tag auto-tag">자동</span>
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text" 
                                   class="field-input auto-field generate-field-input"
                                   value="\\r\\n"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   id="gen-field-${index}"
                                   disabled
                                   readonly />
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}">\\r\\n</code>
                        </td>
                    `;
                } else {
                    // 일반 입력 필드
                    const isNumeric = isNumericField(field.name);
                    const isUserChoice = isUserChoiceField(field.name);
                    
                    // 숫자 태그 HTML 생성 (cd/code 필드는 토글 가능)
                    let numericTagHtml = '';
                    if (isNumeric) {
                        numericTagHtml = '<span class="field-tag numeric-tag">숫자</span>';
                    } else if (isUserChoice) {
                        // cd/code 필드: 사용자 선택 토글 추가
                        numericTagHtml = `
                            <label class="type-toggle-label" title="체크하면 숫자 필드로 처리 (좌측 0 패딩)">
                                <input type="checkbox" 
                                       class="type-toggle-checkbox" 
                                       id="type-toggle-${index}"
                                       data-field-index="${index}" />
                                <span class="type-toggle-text">숫자</span>
                            </label>
                        `;
                    }
                    
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            ${numericTagHtml}
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text"
                                   class="field-input generate-field-input"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   data-is-numeric="${isNumeric}"
                                   data-is-user-choice="${isUserChoice}"
                                   id="gen-field-${index}"
                                   maxlength="${field.size}"
                                   placeholder="최대 ${field.size}자"
                                   ${isNumeric ? 'inputmode="numeric"' : ''} />
                            <div class="input-meta">
                                <span class="char-counter">
                                    <span class="current-length" id="char-count-${index}">0</span>/${field.size}
                                </span>
                            </div>
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}"></code>
                        </td>
                    `;
                    
                    // 입력 이벤트 바인딩을 위해 setTimeout 사용 (DOM에 추가된 후 실행)
                    setTimeout(function() {
                        const input = document.getElementById('gen-field-' + index);
                        const charCountEl = document.getElementById('char-count-' + index);
                        const previewEl = document.getElementById('preview-field-' + index);
                        const typeToggle = document.getElementById('type-toggle-' + index);
                        
                        if (input) {
                            input.addEventListener('input', function() {
                                const value = this.value;
                                const size = parseInt(this.dataset.fieldSize);
                                
                                // 글자 수 카운터 업데이트
                                if (charCountEl) {
                                    charCountEl.textContent = value.length;
                                }
                                
                                // 미리보기 업데이트
                                if (previewEl) {
                                    previewEl.classList.remove('filled', 'padded', 'over');
                                    
                                    if (value.length === 0) {
                                        previewEl.textContent = '';
                                    } else if (value.length < size) {
                                        // 패딩 표시 - 숫자 필드는 0, 문자 필드는 공백
                                        const isNumericNow = input.dataset.isNumeric === 'true' || 
                                                           (typeToggle && typeToggle.checked);
                                        const padChar = isNumericNow ? '0' : '░';
                                        const padded = isNumericNow ? 
                                                      padChar.repeat(size - value.length) + value :
                                                      value + padChar.repeat(size - value.length);
                                        previewEl.textContent = padded;
                                        previewEl.classList.add('padded');
                                    } else if (value.length === size) {
                                        previewEl.textContent = value;
                                        previewEl.classList.add('filled');
                                    } else {
                                        // 초과
                                        previewEl.textContent = value + ' (초과!)';
                                        previewEl.classList.add('over');
                                    }
                                }
                            });
                        }
                        
                        // 타입 토글 체크박스 이벤트 (cd/code 필드용)
                        if (typeToggle && input) {
                            typeToggle.addEventListener('change', function() {
                                // inputmode 변경
                                if (this.checked) {
                                    input.setAttribute('inputmode', 'numeric');
                                } else {
                                    input.removeAttribute('inputmode');
                                }
                                // 미리보기 즉시 업데이트
                                input.dispatchEvent(new Event('input'));
                            });
                        }
                    }, 0);
                }
                
                return tr;
            }
            
            /**
             * 폼 이벤트 리스너 연결 함수
             * 현재 선택된 구조체 정보를 클로저로 캡처합니다.
             * @param {Object} structDef - 구조체 정의 객체
             */
            function attachFormEvents(structDef) {
                // 미리보기 버튼
                const previewBtn = document.getElementById('preview-telegram-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', function() {
                        const inputs = document.querySelectorAll('.field-input');
                        let telegram = '';
                        const errors = [];
                        
                        // 각 필드 값 수집 및 패딩
                        inputs.forEach(function(input, index) {
                            const fieldName = input.dataset.field;
                            const fieldSize = parseInt(input.dataset.size);
                            let value = input.value;
                            
                            // CRLF 필드 처리
                            if (input.disabled) {
                                value = '\r\n';
                            }
                            
                            // 필수 필드 검증 (구분값)
                            if (fieldName && fieldName.toLowerCase().match(/kubun|type|구분/) && !value && !input.disabled) {
                                errors.push('"' + fieldName + '" 필드는 필수입니다');
                            }
                            
                            // 패딩 적용
                            const paddedValue = padValue(value, fieldSize, fieldName);
                            telegram += paddedValue;
                        });
                        
                        // 미리보기 박스 표시
                        const previewBox = document.getElementById('telegram-preview-box');
                        
                        if (errors.length > 0) {
                            previewBox.innerHTML = 
                                '<div class="preview-error">' +
                                '  <h5>⚠️ 입력 오류</h5>' +
                                '  <ul>' +
                                errors.map(function(err) { return '<li>' + err + '</li>'; }).join('') +
                                '  </ul>' +
                                '</div>';
                        } else {
                            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                            const escapedTelegram = escapeHtml(telegram);
                            
                            previewBox.innerHTML = 
                                '<div class="preview-success">' +
                                '  <div class="preview-header">' +
                                '    <h5>👁️ 생성된 전문 미리보기</h5>' +
                                '    <button class="copy-preview-btn" data-telegram="' + escapedTelegram + '">' +
                                '      📋 복사' +
                                '    </button>' +
                                '  </div>' +
                                '  <div class="preview-content">' +
                                '    <pre class="telegram-display">' + escapeForDisplay(telegram) + '</pre>' +
                                '  </div>' +
                                '  <div class="preview-info">' +
                                '    <div class="info-item">' +
                                '      <span class="info-label">길이:</span>' +
                                '      <span class="info-value">' + telegram.length + ' bytes</span>' +
                                '    </div>' +
                                '    <div class="info-item">' +
                                '      <span class="info-label">HEX:</span>' +
                                '      <span class="info-value hex-value">' + toHexPreview(telegram) + '</span>' +
                                '    </div>' +
                                (recognizeCRLF ? 
                                '    <div class="info-item">' +
                                '      <span class="info-label">CRLF:</span>' +
                                '      <span class="info-value">포함 (2 bytes)</span>' +
                                '    </div>' : '') +
                                '  </div>' +
                                '</div>';
                        }
                        
                        previewBox.style.display = 'block';
                    });
                }
                
                // 레코드 추가 버튼 - 이제 이벤트 위임 방식으로 document에서 처리
                // (아래 document.addEventListener 참조)
                
                // 초기화 버튼 - 이제 이벤트 위임 방식으로 document에서 처리
                // (아래 document.addEventListener 참조)
                
                // 실시간 입력 처리 (이벤트 위임)
                const formContainer = document.getElementById('generate-form-container');
                if (formContainer) {
                    formContainer.addEventListener('input', function(e) {
                        if (e.target.classList.contains('field-input') && !e.target.disabled) {
                            const input = e.target;
                            const fieldName = input.dataset.field;
                            const fieldSize = parseInt(input.dataset.size);
                            const value = input.value;
                            
                            // 1. 글자 수 카운터 업데이트
                            const row = input.closest('tr');
                            const currentLength = row.querySelector('.current-length');
                            
                            if (currentLength) {
                                currentLength.textContent = value.length;
                                
                                // 색상 변경
                                if (value.length > fieldSize) {
                                    currentLength.style.color = '#dc3545';
                                    input.style.borderColor = '#dc3545';
                                    input.style.backgroundColor = '#fff5f5';
                                } else if (value.length === fieldSize) {
                                    currentLength.style.color = '#28a745';
                                    input.style.borderColor = '#28a745';
                                    input.style.backgroundColor = '#f0fff4';
                                } else {
                                    currentLength.style.color = '#6c757d';
                                    input.style.borderColor = '#ced4da';
                                    input.style.backgroundColor = '#fff';
                                }
                            }
                            
                            // 2. 숫자 필드 검증 (자동 판단 + 사용자 선택 토글 확인)
                            const fieldIndex = input.dataset.index;
                            const typeToggle = document.getElementById('type-toggle-' + fieldIndex);
                            const isAutoNumeric = isNumericField(fieldName);
                            const isUserChoiceNumeric = typeToggle && typeToggle.checked;
                            const shouldValidateNumeric = isAutoNumeric || isUserChoiceNumeric;
                            
                            if (shouldValidateNumeric) {
                                if (value && !/^[0-9]*$/.test(value)) {
                                    input.setCustomValidity('숫자만 입력 가능합니다');
                                    input.style.borderColor = '#ffc107';
                                } else {
                                    input.setCustomValidity('');
                                }
                            } else {
                                input.setCustomValidity('');
                            }
                            
                            // 3. 패딩 미리보기 (숫자: 좌측 0 패딩, 문자: 우측 공백 패딩)
                            let paddedValue;
                            if (value.length >= fieldSize) {
                                paddedValue = value.substring(0, fieldSize);
                            } else if (shouldValidateNumeric) {
                                paddedValue = '0'.repeat(fieldSize - value.length) + value;
                            } else {
                                paddedValue = value + ' '.repeat(fieldSize - value.length);
                            }
                            const previewCell = row.querySelector('.preview-text');
                            if (previewCell) {
                                previewCell.textContent = paddedValue;
                            }
                            
                            // 4. 길이 초과 시 경고 표시 (자동 자르기 대신)
                            // if (value.length > fieldSize) {
                            //     input.value = value.substring(0, fieldSize);
                            // }
                        }
                    });
                }
            }
            
            /**
             * 폼에서 전문 문자열 생성
             * @param {Object} structDef - 구조체 정의 객체
             * @returns {Object} { raw: 실제 전문, display: 표시용 전문 }
             */
            function buildTelegramFromForm(structDef) {
                const inputs = document.querySelectorAll('#form-fields-body .generate-field-input');
                let raw = '';
                let display = '';
                
                inputs.forEach(function(input, idx) {
                    const field = structDef.fields[idx];
                    let value = input.value;
                    
                    // CRLF 필드 처리
                    if (field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                        raw += '\r\n';
                        display += '\\r\\n';
                        return;
                    }
                    
                    // 숫자 필드 여부 판단 (자동 판단 + 사용자 선택 토글)
                    const isNumeric = input.dataset.isNumeric === 'true';
                    const isUserChoice = input.dataset.isUserChoice === 'true';
                    const typeToggle = document.getElementById('type-toggle-' + idx);
                    const useNumericPad = isNumeric || (isUserChoice && typeToggle && typeToggle.checked);
                    
                    // 값 패딩 (숫자: 좌측 0 패딩, 문자: 우측 공백 패딩)
                    if (value.length < field.size) {
                        if (useNumericPad) {
                            value = '0'.repeat(field.size - value.length) + value;
                        } else {
                            value = value + ' '.repeat(field.size - value.length);
                        }
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                    }
                    
                    raw += value;
                    display += value.replace(/ /g, '·');  // 공백을 점으로 표시
                });
                
                return { raw: raw, display: display };
            }
            
            /**
             * 전문 생성 폼 표시 함수
             * @param {Object} structDef - 구조체 정의 객체
             */
            function displayGenerateForm(structDef) {
                // 1. generate-form-container 초기화
                const container = document.getElementById('generate-form-container');
                
                // 2. recognizeCRLF 옵션 확인
                const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                
                // 3. 폼 HTML 생성
                const formHTML = 
                    '<div class="generate-form">' +
                    
                    '  <div class="form-header">' +
                    '    <div class="form-title">' +
                    '      <h4>📝 ' + (structDef.name || '구조체') + ' 입력 폼</h4>' +
                    '      <span class="form-badge">총 ' + structDef.totalSize + ' bytes</span>' +
                    '    </div>' +
                    '    <div class="form-info">' +
                    '      <small>' + structDef.fields.length + '개 필드</small>' +
                    '    </div>' +
                    '  </div>' +
                    
                    '  <table class="input-form-table">' +
                    '    <thead>' +
                    '      <tr>' +
                    '        <th style="width: 25%">필드명</th>' +
                    '        <th style="width: 8%">크기</th>' +
                    '        <th style="width: 42%">입력값</th>' +
                    '        <th style="width: 25%">미리보기</th>' +
                    '      </tr>' +
                    '    </thead>' +
                    '    <tbody id="form-fields-body">' +
                    '    </tbody>' +
                    '  </table>' +
                    
                    '  <div class="form-actions">' +
                    '    <button id="preview-telegram-btn" class="btn-info">' +
                    '      👁️ 미리보기' +
                    '    </button>' +
                    '    <button id="add-to-list-btn" class="btn-success">' +
                    '      ✓ 레코드 추가' +
                    '    </button>' +
                    '    <button id="reset-form-btn" class="btn-secondary">' +
                    '      🔄 초기화' +
                    '    </button>' +
                    '  </div>' +
                    
                    '  <div id="telegram-preview-box" class="preview-box" style="display: none;">' +
                    '  </div>' +
                    
                    '</div>';
                
                // 4. DOM에 추가
                container.innerHTML = formHTML;
                container.style.display = 'block';
                
                // 5. 필드 행 생성
                const tbody = document.getElementById('form-fields-body');
                
                structDef.fields.forEach(function(field, index) {
                    const row = createFieldRow(field, index, recognizeCRLF);
                    tbody.appendChild(row);
                });
                
                // 6. 이벤트 리스너 연결
                attachFormEvents(structDef);
            }
            
            /**
             * XML 규격 기반 전문 생성 폼 표시 함수
             * @param {Array} xmlSpec - parseXMLSpec의 결과 배열 [{id, type, size}, ...]
             */
            function displayXMLGenerateForm(xmlSpec) {
                // 폼 HTML 생성
                const formHTML = 
                    '<div class="generate-form">' +
                    
                    '  <div class="form-header">' +
                    '    <div class="form-title">' +
                    '      <h4>📝 필드 입력 폼</h4>' +
                    '      <span class="form-badge">' + xmlSpec.length + '개 필드</span>' +
                    '    </div>' +
                    '  </div>' +
                    
                    '  <table class="input-form-table">' +
                    '    <thead>' +
                    '      <tr>' +
                    '        <th style="width: 30%">필드명 (ID)</th>' +
                    '        <th style="width: 10%">타입</th>' +
                    '        <th style="width: 8%">크기</th>' +
                    '        <th style="width: 37%">입력값</th>' +
                    '        <th style="width: 15%">미리보기</th>' +
                    '      </tr>' +
                    '    </thead>' +
                    '    <tbody id="xml-form-fields-body">' +
                    '      <!-- 필드 행 -->' +
                    '    </tbody>' +
                    '  </table>' +
                    
                    '  <div class="form-actions">' +
                    '    <button id="xml-preview-telegram-btn" class="btn-info">' +
                    '      👁️ 미리보기' +
                    '    </button>' +
                    '    <button id="xml-add-to-list-btn" class="btn-success">' +
                    '      ✓ 레코드 추가' +
                    '    </button>' +
                    '    <button id="xml-reset-form-btn" class="btn-secondary">' +
                    '      🔄 초기화' +
                    '    </button>' +
                    '  </div>' +
                    
                    '  <div id="xml-telegram-preview-box" class="preview-box" style="display: none;">' +
                    '    <!-- 미리보기 -->' +
                    '  </div>' +
                    
                    '</div>';
                
                // DOM에 추가
                document.getElementById('xml-generate-form-container').innerHTML = formHTML;
                document.getElementById('xml-generate-form-container').style.display = 'block';
                
                // 필드 행 생성
                const tbody = document.getElementById('xml-form-fields-body');
                
                xmlSpec.forEach(function(field, index) {
                    const tr = document.createElement('tr');
                    const isNumeric = field.type === 'N';
                    const isFull = field.type === 'FULL';
                    
                    // FULL 타입은 바이트 기준이므로 maxlength를 넉넉하게 설정
                    // (한글 1자 = 2바이트이므로 size/2 + 여유분)
                    const maxLength = isFull ? Math.ceil(field.size) : field.size;
                    
                    // placeholder 설정
                    let placeholder = '텍스트 입력';
                    if (isNumeric) {
                        placeholder = '숫자 입력';
                    } else if (isFull) {
                        placeholder = '한글/영문 입력 (KSC-5601 ' + field.size + 'bytes)';
                    }
                    
                    // 단위 표시 (FULL: bytes, 기타: chars)
                    const sizeUnit = isFull ? ' bytes' : '';
                    
                    tr.innerHTML = 
                        '<td>' +
                        '  <span class="field-name">' + field.id + '</span>' +
                        '</td>' +
                        '<td class="field-type-cell">' +
                        '  <span class="type-badge type-' + field.type + '">' + field.type + '</span>' +
                        '</td>' +
                        '<td class="field-size">' + field.size + sizeUnit + '</td>' +
                        '<td>' +
                        '  <input type="text"' +
                        '         class="field-input xml-field-input"' +
                        '         data-field="' + field.id + '"' +
                        '         data-type="' + field.type + '"' +
                        '         data-size="' + field.size + '"' +
                        '         data-index="' + index + '"' +
                        (isFull ? '' : '         maxlength="' + maxLength + '"') +
                        '         placeholder="' + placeholder + '"' +
                        (isNumeric ? '         inputmode="numeric"' : '') +
                        '  />' +
                        '  <div class="input-meta">' +
                        '    <span class="char-counter">' +
                        '      <span class="current-length">0</span>/' + field.size + (isFull ? 'B' : '') +
                        '    </span>' +
                        '  </div>' +
                        '</td>' +
                        '<td class="preview-cell">' +
                        '  <code class="preview-text"></code>' +
                        '</td>';
                    
                    tbody.appendChild(tr);
                });
                
                // 이벤트 리스너 연결
                attachXMLFormEvents(xmlSpec);
            }
            
            /**
             * XML 폼 이벤트 연결 함수
             * @param {Array} xmlSpec - XML 규격 배열
             */
            function attachXMLFormEvents(xmlSpec) {
                // 실시간 입력 처리 (이벤트 위임)
                document.getElementById('xml-generate-form-container').addEventListener('input', function(e) {
                    if (e.target.classList.contains('xml-field-input')) {
                        const input = e.target;
                        const fieldType = input.dataset.type;
                        const fieldSize = parseInt(input.dataset.size);
                        const value = input.value;
                        
                        // 글자 수/바이트 수 카운터
                        const row = input.closest('tr');
                        const currentLength = row.querySelector('.current-length');
                        
                        // FULL 타입은 바이트 수, 그 외는 글자 수
                        const displayLength = fieldType === 'FULL' 
                            ? KSC5601.getByteLength(value) 
                            : value.length;
                        
                        currentLength.textContent = displayLength;
                        
                        if (displayLength > fieldSize) {
                            currentLength.style.color = '#dc3545';
                            input.style.borderColor = '#dc3545';
                        } else if (displayLength === fieldSize) {
                            currentLength.style.color = '#28a745';
                            input.style.borderColor = '#28a745';
                        } else {
                            currentLength.style.color = '#6c757d';
                            input.style.borderColor = '#ced4da';
                        }
                        
                        // 타입 검증
                        if (fieldType === 'N' && value && !/^[0-9]*$/.test(value)) {
                            input.style.borderColor = '#ffc107';
                            input.setCustomValidity('숫자만 입력 가능합니다');
                        } else {
                            input.setCustomValidity('');
                        }
                        
                        // 패딩 미리보기
                        const paddedValue = padValueByType(value, fieldSize, fieldType);
                        const previewCell = row.querySelector('.preview-text');
                        
                        // FULL 타입은 HEX로도 표시
                        if (fieldType === 'FULL') {
                            const hexPreview = Array.from(paddedValue.substring(0, 20))
                                .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                                .join(' ');
                            previewCell.textContent = paddedValue.length > 20 
                                ? hexPreview + '...' 
                                : hexPreview;
                            previewCell.title = '원본: ' + value + '\nKSC-5601 인코딩됨 (' + paddedValue.length + 'bytes)';
                        } else {
                            previewCell.textContent = paddedValue;
                            previewCell.title = '';
                        }
                    }
                });
                
                // 미리보기 버튼
                document.getElementById('xml-preview-telegram-btn').addEventListener('click', function() {
                    const inputs = document.querySelectorAll('.xml-field-input');
                    let telegram = '';
                    let hasFull = false;
                    const fieldPreviews = [];
                    
                    inputs.forEach(function(input) {
                        const fieldId = input.dataset.field;
                        const fieldType = input.dataset.type;
                        const fieldSize = parseInt(input.dataset.size);
                        const value = input.value;
                        
                        const paddedValue = padValueByType(value, fieldSize, fieldType);
                        telegram += paddedValue;
                        
                        if (fieldType === 'FULL') {
                            hasFull = true;
                            // FULL 타입: HEX와 원본 텍스트 저장
                            const hexStr = Array.from(paddedValue)
                                .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                                .join(' ');
                            // KSC-5601 디코딩 시도
                            let decoded = '';
                            try {
                                decoded = KSC5601.decode(paddedValue);
                            } catch(e) {
                                decoded = value;
                            }
                            fieldPreviews.push({
                                id: fieldId,
                                type: 'FULL',
                                original: value,
                                decoded: decoded,
                                hex: hexStr,
                                bytes: paddedValue.length
                            });
                        }
                    });
                    
                    const previewBox = document.getElementById('xml-telegram-preview-box');
                    
                    // 전체 HEX 생성 (한 줄에 16바이트씩)
                    const hexBytes = Array.from(telegram)
                        .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase());
                    let fullHex = '';
                    for (let i = 0; i < hexBytes.length; i += 16) {
                        fullHex += hexBytes.slice(i, i + 16).join(' ') + '\n';
                    }
                    fullHex = fullHex.trim();
                    
                    // FULL 타입 필드 상세 정보 HTML
                    let fullFieldsHtml = '';
                    if (hasFull && fieldPreviews.length > 0) {
                        fullFieldsHtml = 
                            '<div class="full-fields-detail" style="margin-top: 15px; padding: 10px; background: #f0e6ff; border-radius: 6px; border: 1px solid #d4b8ff;">' +
                            '  <h6 style="margin: 0 0 10px 0; color: #6f42c1;">📦 FULL 타입 필드 (KSC-5601 2바이트 완성형)</h6>';
                        
                        fieldPreviews.forEach(function(fp) {
                            fullFieldsHtml += 
                                '<div style="margin-bottom: 8px; font-size: 13px; padding: 8px; background: white; border-radius: 4px;">' +
                                '  <strong style="color: #6f42c1;">' + fp.id + '</strong> (' + fp.bytes + ' bytes)<br>' +
                                '  <span style="color: #666;">입력값:</span> ' + escapeHtml(fp.original || '(비어있음)') + '<br>' +
                                '  <span style="color: #666;">디코딩:</span> <span style="color: #28a745;">' + escapeHtml(fp.decoded) + '</span><br>' +
                                '  <span style="color: #666;">HEX:</span> <code style="font-size: 11px; background: #e9ecef; padding: 2px 4px; word-break: break-all;">' + fp.hex + '</code>' +
                                '</div>';
                        });
                        
                        fullFieldsHtml += '</div>';
                    }
                    
                    // 통데이터 표시 (FULL 타입은 디코딩된 텍스트로 치환)
                    let displayTelegram = telegram;
                    if (hasFull) {
                        // FULL 타입 바이트를 디코딩된 텍스트로 치환하여 표시
                        try {
                            displayTelegram = KSC5601.decode(telegram);
                        } catch(e) {
                            displayTelegram = escapeForDisplay(telegram);
                        }
                    }
                    
                    previewBox.innerHTML = 
                        '<div class="preview-success">' +
                        '  <div class="preview-header">' +
                        '    <h5>👁️ 생성된 전문 미리보기</h5>' +
                        '    <button class="copy-preview-btn" data-telegram="' + escapeHtml(telegram) + '">' +
                        '      📋 복사 (바이너리)' +
                        '    </button>' +
                        '  </div>' +
                        '  <div class="preview-content">' +
                        '    <div style="margin-bottom: 5px;"><strong>📄 통데이터 (디코딩):</strong></div>' +
                        '    <pre class="telegram-display" style="margin-bottom: 15px;">' + escapeHtml(displayTelegram) + '</pre>' +
                        '    <div style="margin-bottom: 5px;"><strong>🔢 HEX 표현:</strong></div>' +
                        '    <pre class="telegram-display" style="word-break: break-all; white-space: pre-wrap; font-size: 11px; background: #f8f9fa; color: #495057;">' + fullHex + '</pre>' +
                        fullFieldsHtml +
                        '  </div>' +
                        '  <div class="preview-info">' +
                        '    <div class="info-item">' +
                        '      <span class="info-label">총 길이:</span>' +
                        '      <span class="info-value">' + telegram.length + ' bytes</span>' +
                        '    </div>' +
                        '  </div>' +
                        '</div>';
                    
                    previewBox.style.display = 'block';
                });
                
                // 레코드 추가 버튼
                document.getElementById('xml-add-to-list-btn').addEventListener('click', function() {
                    const inputs = document.querySelectorAll('.xml-field-input');
                    let telegram = '';
                    const fieldData = [];
                    
                    inputs.forEach(function(input) {
                        const fieldId = input.dataset.field;
                        const fieldType = input.dataset.type;
                        const fieldSize = parseInt(input.dataset.size);
                        const value = input.value;
                        const paddedValue = padValueByType(value, fieldSize, fieldType);
                        
                        telegram += paddedValue;
                        
                        fieldData.push({
                            name: fieldId,
                            type: fieldType,
                            size: fieldSize,
                            value: value,
                            padded: paddedValue
                        });
                    });
                    
                    const record = {
                        id: Date.now(),
                        structName: 'XML 전문',
                        telegram: telegram,
                        fieldData: fieldData,
                        timestamp: new Date().toLocaleString('ko-KR'),
                        length: telegram.length
                    };
                    
                    addXMLRecordToList(record);
                    
                    const shouldReset = confirm('레코드가 추가되었습니다.\n입력 폼을 초기화하시겠습니까?');
                    if (shouldReset) {
                        resetXMLForm();
                    }
                });
                
                // 초기화 버튼
                document.getElementById('xml-reset-form-btn').addEventListener('click', function() {
                    if (confirm('입력한 내용을 모두 초기화하시겠습니까?')) {
                        resetXMLForm();
                    }
                });
            }
            
            /**
             * 타입에 따른 패딩 처리 함수
             * @param {string} value - 입력값
             * @param {number} size - 필드 크기
             * @param {string} type - 필드 타입 (N: 숫자, X: 문자)
             * @returns {string} 패딩된 값
             */
            function padValueByType(value, size, type) {
                // FULL 타입: KSC-5601 2바이트 완성형 코드로 변환 후 패딩
                if (type === 'FULL') {
                    return KSC5601.padToByteSize(value, size);
                }
                
                if (value.length > size) {
                    return value.substring(0, size);
                }
                if (value.length < size) {
                    // N 타입: 좌측 0 패딩
                    if (type === 'N') {
                        return value.padStart(size, '0');
                    }
                    // X 타입: 우측 공백 패딩
                    return value.padEnd(size, ' ');
                }
                return value;
            }
            
            /**
             * XML 폼 초기화 함수
             */
            function resetXMLForm() {
                document.querySelectorAll('.xml-field-input').forEach(function(input) {
                    input.value = '';
                    input.style.borderColor = '#ced4da';
                });
                document.querySelectorAll('.current-length').forEach(function(span) {
                    span.textContent = '0';
                    span.style.color = '#6c757d';
                });
                document.querySelectorAll('.preview-text').forEach(function(code) {
                    code.textContent = '';
                });
                document.getElementById('xml-telegram-preview-box').style.display = 'none';
            }
            
            /**
             * XML 레코드를 목록에 추가 (C 구조체 addRecordToList와 동일한 구조)
             * @param {Object} record - 레코드 객체 (id, structName, telegram, fieldData, timestamp, length)
             */
            function addXMLRecordToList(record) {
                const container = document.getElementById('xml-generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (container.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'records-header';
                    header.innerHTML = `
                        <div class="header-left">
                            <h4>📦 생성된 XML 레코드 목록</h4>
                            <span class="xml-record-count-badge">0개</span>
                        </div>
                        <div class="header-right">
                            <button id="export-xml-records-btn" class="export-btn">
                                💾 전체 내보내기
                            </button>
                            <button id="clear-xml-records-btn" class="clear-btn">
                                🗑️ 전체 삭제
                            </button>
                        </div>
                    `;
                    container.appendChild(header);
                    
                    // 목록 컨테이너 추가
                    const listContainer = document.createElement('div');
                    listContainer.id = 'xml-records-list';
                    listContainer.className = 'records-list';
                    container.appendChild(listContainer);
                    
                    // 전체 내보내기 버튼 이벤트
                    document.getElementById('export-xml-records-btn').addEventListener('click', function() {
                        if (!window.xmlGeneratedRecords || window.xmlGeneratedRecords.length === 0) {
                            showTemporaryMessage('내보낼 레코드가 없습니다.');
                            return;
                        }
                        showXMLExportModal();
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-xml-records-btn').addEventListener('click', function() {
                        const count = window.xmlGeneratedRecords?.length || 0;
                        
                        if (count === 0) {
                            alert('삭제할 레코드가 없습니다');
                            return;
                        }
                        
                        if (confirm(`${count}개의 레코드를 모두 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
                            // 애니메이션과 함께 삭제
                            const recordItems = container.querySelectorAll('.xml-record-item');
                            
                            recordItems.forEach((item, index) => {
                                setTimeout(() => {
                                    item.style.opacity = '0';
                                    item.style.transform = 'translateX(-100%)';
                                }, index * 50);
                            });
                            
                            setTimeout(() => {
                                document.getElementById('xml-generated-records-area').innerHTML = '';
                                window.xmlGeneratedRecords = [];
                                showTemporaryMessage('✓ 모든 레코드가 삭제되었습니다');
                            }, recordItems.length * 50 + 300);
                        }
                    });
                }
                
                // 레코드 카드 생성
                const recordCard = document.createElement('div');
                recordCard.className = 'record-item xml-record-item';
                recordCard.dataset.id = record.id;
                
                const recordIndex = container.querySelectorAll('.xml-record-item').length;
                
                recordCard.innerHTML = `
                    <div class="record-item-header">
                        <div class="record-meta">
                            <span class="xml-record-number">#${recordIndex + 1}</span>
                            <span class="record-struct-name">${record.structName || 'XML 레코드'}</span>
                            <span class="record-timestamp">${record.timestamp}</span>
                        </div>
                        <div class="record-actions">
                            <button class="btn-icon xml-copy-record-btn" 
                                    data-id="${record.id}" 
                                    title="복사">
                                📋
                            </button>
                            <button class="btn-icon xml-view-detail-btn" 
                                    data-id="${record.id}"
                                    title="상세보기">
                                👁️
                            </button>
                            <button class="btn-icon xml-delete-record-btn" 
                                    data-id="${record.id}"
                                    title="삭제">
                                🗑️
                            </button>
                        </div>
                    </div>
                    
                    <div class="record-item-body">
                        <div class="telegram-box">
                            <pre class="telegram-text">${escapeForDisplay(record.telegram)}</pre>
                        </div>
                        <div class="record-stats">
                            <span class="stat-item">
                                <span class="stat-label">길이:</span>
                                <span class="stat-value">${record.length} bytes</span>
                            </span>
                        </div>
                    </div>
                    
                    <div class="xml-record-detail" style="display: none;">
                        <table class="detail-table">
                            <thead>
                                <tr>
                                    <th>필드명</th>
                                    <th>크기</th>
                                    <th>입력값</th>
                                    <th>패딩후</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${record.fieldData ? record.fieldData.map(field => `
                                    <tr>
                                        <td>${field.name}</td>
                                        <td>${field.size}</td>
                                        <td>${field.value || '<비어있음>'}</td>
                                        <td><code>${escapeForDisplay(field.padded)}</code></td>
                                    </tr>
                                `).join('') : ''}
                            </tbody>
                        </table>
                    </div>
                `;
                
                // 목록에 추가 (최신이 위로)
                const listContainer = container.querySelector('#xml-records-list');
                if (listContainer) {
                    if (listContainer.firstChild) {
                        listContainer.insertBefore(recordCard, listContainer.firstChild);
                    } else {
                        listContainer.appendChild(recordCard);
                    }
                }
                
                // 카운트 업데이트
                updateXMLRecordCount();
                
                // 전역 저장소에 추가
                if (!window.xmlGeneratedRecords) {
                    window.xmlGeneratedRecords = [];
                }
                window.xmlGeneratedRecords.unshift(record);
            }
            
            /**
             * XML 기반 전문 생성 함수
             * @param {Array} xmlSpec - XML 규격 배열
             * @returns {Object} {raw: 원본 문자열, display: 표시용 문자열}
             */
            function generateXMLTelegram(xmlSpec) {
                const inputs = document.querySelectorAll('#xml-form-fields-body .xml-field-input');
                let raw = '';
                let display = '';
                
                inputs.forEach(function(input, idx) {
                    const field = xmlSpec[idx];
                    let value = input.value;
                    
                    // 타입에 따른 패딩 처리
                    if (field.type === 'FULL') {
                        // FULL 타입: KSC-5601 인코딩 후 바이트 단위 패딩
                        value = KSC5601.padToByteSize(value, field.size);
                        raw += value;
                        // display용: HEX 표현으로 변환
                        display += '[KSC:' + value.length + 'B]';
                    } else if (value.length < field.size) {
                        if (field.type === 'N') {
                            // 숫자 타입: 왼쪽 0 패딩
                            value = '0'.repeat(field.size - value.length) + value;
                        } else {
                            // 문자 타입: 오른쪽 공백 패딩
                            value = value + ' '.repeat(field.size - value.length);
                        }
                        raw += value;
                        display += value.replace(/ /g, '·');  // 공백을 점으로 표시
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                        raw += value;
                        display += value.replace(/ /g, '·');
                    } else {
                        raw += value;
                        display += value.replace(/ /g, '·');
                    }
                });
                
                return { raw: raw, display: display };
            }
            
            /**
             * XML 생성 폼 초기화 함수
             */
            function resetXMLGenerateForm() {
                const inputs = document.querySelectorAll('#xml-form-fields-body .xml-field-input');
                inputs.forEach(function(input) {
                    input.value = '';
                    
                    const row = input.closest('tr');
                    
                    // 카운터 초기화
                    const charCountEl = row.querySelector('.current-length');
                    if (charCountEl) {
                        charCountEl.textContent = '0';
                    }
                    
                    // 미리보기 초기화
                    const previewEl = row.querySelector('.preview-text');
                    if (previewEl) {
                        previewEl.textContent = '';
                        previewEl.classList.remove('filled', 'padded', 'over');
                    }
                });
                
                // 미리보기 박스 숨기기
                document.getElementById('xml-telegram-preview-box').style.display = 'none';
            }
            
            /**
             * XML 생성된 레코드를 목록에 추가
             * @param {string} record - 생성된 레코드
             */
            function addXMLGeneratedRecord(record) {
                const area = document.getElementById('xml-generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (area.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'generated-records-header';
                    header.innerHTML = 
                        '<h5>📦 생성된 레코드</h5>' +
                        '<div class="header-actions">' +
                        '  <button id="xml-copy-all-records" class="btn-secondary btn-sm">전체 복사</button>' +
                        '  <button id="xml-clear-all-records" class="btn-danger btn-sm">전체 삭제</button>' +
                        '</div>';
                    area.appendChild(header);
                    
                    // 전체 복사 이벤트
                    document.getElementById('xml-copy-all-records').addEventListener('click', function() {
                        const records = area.querySelectorAll('.record-text');
                        let allRecords = '';
                        records.forEach(function(r) {
                            allRecords += r.textContent + '\n';
                        });
                        navigator.clipboard.writeText(allRecords.trim()).then(function() {
                            showTemporaryMessage('전체 레코드가 복사되었습니다.');
                        });
                    });
                    
                    // 전체 삭제 이벤트
                    document.getElementById('xml-clear-all-records').addEventListener('click', function() {
                        if (confirm('모든 생성된 레코드를 삭제하시겠습니까?')) {
                            area.innerHTML = '';
                            showTemporaryMessage('모든 레코드가 삭제되었습니다.');
                        }
                    });
                }
                
                // 레코드 아이템 생성
                const recordItem = document.createElement('div');
                recordItem.className = 'record-item';
                
                const recordIndex = area.querySelectorAll('.record-item').length + 1;
                
                recordItem.innerHTML = 
                    '<div class="record-header">' +
                    '  <span class="record-number">#' + recordIndex + '</span>' +
                    '  <span class="record-size">' + record.length + ' bytes</span>' +
                    '</div>' +
                    '<code class="record-text">' + escapeHtml(record) + '</code>' +
                    '<div class="record-actions">' +
                    '  <button class="xml-copy-record-btn btn-secondary btn-xs">복사</button>' +
                    '  <button class="xml-delete-record-btn btn-danger btn-xs">삭제</button>' +
                    '</div>';
                
                area.appendChild(recordItem);
                
                // 복사 버튼 이벤트
                recordItem.querySelector('.xml-copy-record-btn').addEventListener('click', function() {
                    navigator.clipboard.writeText(record).then(function() {
                        showTemporaryMessage('레코드가 복사되었습니다.');
                    });
                });
                
                // 삭제 버튼 이벤트
                recordItem.querySelector('.xml-delete-record-btn').addEventListener('click', function() {
                    recordItem.remove();
                    showTemporaryMessage('레코드가 삭제되었습니다.');
                    
                    // 모든 레코드가 삭제되면 헤더도 삭제
                    if (area.querySelectorAll('.record-item').length === 0) {
                        area.innerHTML = '';
                    }
                });
            }
            
            /**
             * 레코드 생성 함수
             * @param {Object} struct - 구조체 정의
             */
            function generateRecord(struct) {
                const inputs = document.querySelectorAll('#form-fields-body .generate-field-input');
                let record = '';
                let hasError = false;
                
                inputs.forEach(function(input, idx) {
                    const field = struct.fields[idx];
                    let value = input.value;
                    
                    // CRLF 필드 처리
                    if (field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                        record += '\r\n';
                        return;
                    }
                    
                    // 값 패딩 (오른쪽 공백 채우기)
                    if (value.length < field.size) {
                        value = value + ' '.repeat(field.size - value.length);
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                    }
                    
                    record += value;
                });
                
                if (!hasError) {
                    // 생성된 레코드 표시
                    addGeneratedRecord(record, struct.name);
                    showTemporaryMessage('레코드가 생성되었습니다. (' + record.length + ' bytes)');
                }
            }
            
            /**
             * 생성된 레코드를 목록에 추가
             * @param {string} record - 생성된 레코드
             * @param {string} structName - 구조체 이름
             */
            function addGeneratedRecord(record, structName) {
                const area = document.getElementById('generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (area.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'generated-records-header';
                    header.innerHTML = '<h5>📋 생성된 레코드 목록</h5>' +
                        '<button id="copy-all-records" class="secondary-btn">전체 복사</button>' +
                        '<button id="clear-all-records" class="danger-btn">전체 삭제</button>';
                    area.appendChild(header);
                    
                    // 전체 복사 버튼 이벤트
                    document.getElementById('copy-all-records').addEventListener('click', function() {
                        const records = area.querySelectorAll('.generated-record-content');
                        let allRecords = '';
                        records.forEach(function(r) {
                            allRecords += r.textContent + '\n';
                        });
                        navigator.clipboard.writeText(allRecords.trim()).then(function() {
                            showTemporaryMessage('전체 레코드가 복사되었습니다.');
                        });
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-all-records').addEventListener('click', function() {
                        if (confirm('모든 생성된 레코드를 삭제하시겠습니까?')) {
                            area.innerHTML = '';
                            showTemporaryMessage('모든 레코드가 삭제되었습니다.');
                        }
                    });
                }
                
                // 레코드 아이템 생성
                const item = document.createElement('div');
                item.className = 'generated-record-item';
                
                const info = document.createElement('span');
                info.className = 'record-info';
                info.textContent = structName + ' (' + record.length + ' bytes)';
                
                const content = document.createElement('code');
                content.className = 'generated-record-content';
                content.textContent = record.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.textContent = '복사';
                copyBtn.addEventListener('click', function() {
                    navigator.clipboard.writeText(record).then(function() {
                        showTemporaryMessage('레코드가 복사되었습니다.');
                    });
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-record-btn';
                deleteBtn.textContent = '삭제';
                deleteBtn.addEventListener('click', function() {
                    item.remove();
                    // 레코드가 모두 삭제되면 헤더도 삭제
                    if (area.querySelectorAll('.generated-record-item').length === 0) {
                        area.innerHTML = '';
                    }
                });
                
                item.appendChild(info);
                item.appendChild(content);
                item.appendChild(copyBtn);
                item.appendChild(deleteBtn);
                area.appendChild(item);
            }
            
            /**
             * 레코드를 목록에 추가
             * @param {Object} record - 레코드 객체 (id, structName, telegram, fieldData, timestamp, length)
             */
            function addRecordToList(record) {
                const container = document.getElementById('generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (container.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'records-header';
                    header.innerHTML = `
                        <div class="header-left">
                            <h4>📦 생성된 레코드 목록</h4>
                            <span class="record-count-badge">0개</span>
                        </div>
                        <div class="header-right">
                            <button id="export-all-records-btn" class="export-btn">
                                💾 전체 내보내기
                            </button>
                            <button id="clear-all-records-btn" class="clear-btn">
                                🗑️ 전체 삭제
                            </button>
                        </div>
                    `;
                    container.appendChild(header);
                    
                    // 목록 컨테이너 추가
                    const listContainer = document.createElement('div');
                    listContainer.id = 'records-list';
                    listContainer.className = 'records-list';
                    container.appendChild(listContainer);
                    
                    // 전체 내보내기 버튼 이벤트
                    document.getElementById('export-all-records-btn').addEventListener('click', function() {
                        if (!window.generatedRecords || window.generatedRecords.length === 0) {
                            showTemporaryMessage('내보낼 레코드가 없습니다.');
                            return;
                        }
                        showExportModal();
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-all-records-btn').addEventListener('click', function() {
                        const count = window.generatedRecords?.length || 0;
                        
                        if (count === 0) {
                            alert('삭제할 레코드가 없습니다');
                            return;
                        }
                        
                        if (confirm(`${count}개의 레코드를 모두 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
                            // 애니메이션과 함께 삭제
                            const recordItems = document.querySelectorAll('.record-item');
                            
                            recordItems.forEach((item, index) => {
                                setTimeout(() => {
                                    item.style.opacity = '0';
                                    item.style.transform = 'translateX(-100%)';
                                }, index * 50);
                            });
                            
                            setTimeout(() => {
                                document.getElementById('generated-records-area').innerHTML = '';
                                window.generatedRecords = [];
                                showTemporaryMessage('✓ 모든 레코드가 삭제되었습니다');
                            }, recordItems.length * 50 + 300);
                        }
                    });
                }
                
                // 레코드 카드 생성
                const recordCard = document.createElement('div');
                recordCard.className = 'record-item';
                recordCard.dataset.id = record.id;
                
                const recordIndex = container.querySelectorAll('.record-item').length;
                
                recordCard.innerHTML = `
                    <div class="record-item-header">
                        <div class="record-meta">
                            <span class="record-number">#${recordIndex + 1}</span>
                            <span class="record-struct-name">${record.structName}</span>
                            <span class="record-timestamp">${record.timestamp}</span>
                        </div>
                        <div class="record-actions">
                            <button class="btn-icon copy-record-btn" 
                                    data-id="${record.id}" 
                                    title="복사">
                                📋
                            </button>
                            <button class="btn-icon view-detail-btn" 
                                    data-id="${record.id}"
                                    title="상세보기">
                                👁️
                            </button>
                            <button class="btn-icon delete-record-btn" 
                                    data-id="${record.id}"
                                    title="삭제">
                                🗑️
                            </button>
                        </div>
                    </div>
                    
                    <div class="record-item-body">
                        <div class="telegram-box">
                            <pre class="telegram-text">${escapeForDisplay(record.telegram)}</pre>
                        </div>
                        <div class="record-stats">
                            <span class="stat-item">
                                <span class="stat-label">길이:</span>
                                <span class="stat-value">${record.length} bytes</span>
                            </span>
                        </div>
                    </div>
                    
                    <div class="record-detail" style="display: none;">
                        <table class="detail-table">
                            <thead>
                                <tr>
                                    <th>필드명</th>
                                    <th>크기</th>
                                    <th>입력값</th>
                                    <th>패딩후</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${record.fieldData.map(field => `
                                    <tr>
                                        <td>${field.name}</td>
                                        <td>${field.size}</td>
                                        <td>${field.value || '<비어있음>'}</td>
                                        <td><code>${escapeForDisplay(field.padded)}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                
                // 목록에 추가 (최신이 위로)
                const listContainer = container.querySelector('#records-list');
                if (listContainer) {
                    if (listContainer.firstChild) {
                        listContainer.insertBefore(recordCard, listContainer.firstChild);
                    } else {
                        listContainer.appendChild(recordCard);
                    }
                }
                
                // 카운트 업데이트
                updateRecordCount();
                
                // 전역 저장소에 추가
                if (!window.generatedRecords) {
                    window.generatedRecords = [];
                }
                window.generatedRecords.unshift(record);
            }
            
            // =========================================
            // 레코드 카드 이벤트 (이벤트 위임)
            // =========================================
            document.addEventListener('click', function(e) {
              
              // 복사 버튼
              if (e.target.classList.contains('copy-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                const record = window.generatedRecords.find(r => r.id === recordId)
                
                if (record) {
                  navigator.clipboard.writeText(record.telegram).then(() => {
                    const originalText = e.target.textContent
                    e.target.textContent = '✓'
                    e.target.style.backgroundColor = 'rgba(40,167,69,0.3)'
                    
                    setTimeout(() => {
                      e.target.textContent = originalText
                      e.target.style.backgroundColor = ''
                    }, 2000)
                  }).catch(err => {
                    alert('복사 실패: ' + err.message)
                  })
                }
              }
              
              // 상세보기 토글
              if (e.target.classList.contains('view-detail-btn')) {
                const recordId = e.target.dataset.id
                const recordCard = document.querySelector(`.record-item[data-id="${recordId}"]`)
                const detailDiv = recordCard.querySelector('.record-detail')
                
                if (detailDiv.style.display === 'none') {
                  detailDiv.style.display = 'block'
                  e.target.textContent = '🔼'
                  e.target.title = '상세닫기'
                } else {
                  detailDiv.style.display = 'none'
                  e.target.textContent = '👁️'
                  e.target.title = '상세보기'
                }
              }
              
              // 삭제 버튼
              if (e.target.classList.contains('delete-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                
                if (confirm('이 레코드를 삭제하시겠습니까?')) {
                  // DOM에서 제거
                  const recordCard = document.querySelector(`.record-item[data-id="${recordId}"]`)
                  recordCard.style.opacity = '0'
                  recordCard.style.transform = 'translateX(-100%)'
                  
                  setTimeout(() => {
                    recordCard.remove()
                    
                    // 배열에서 제거
                    const index = window.generatedRecords.findIndex(r => r.id === recordId)
                    if (index > -1) {
                      window.generatedRecords.splice(index, 1)
                    }
                    
                    // 카운트 업데이트
                    updateRecordCount()
                    
                    // 번호 재정렬
                    reindexRecords()
                    
                    // 목록이 비었으면 헤더도 제거
                    if (window.generatedRecords.length === 0) {
                      document.getElementById('generated-records-area').innerHTML = ''
                    }
                  }, 300)
                }
              }
              
              // =========================================
              // XML 레코드 카드 이벤트 (이벤트 위임)
              // =========================================
              
              // XML 복사 버튼
              if (e.target.classList.contains('xml-copy-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                const record = window.xmlGeneratedRecords?.find(r => r.id === recordId)
                
                if (record) {
                  navigator.clipboard.writeText(record.telegram).then(() => {
                    const originalText = e.target.textContent
                    e.target.textContent = '✓'
                    e.target.style.backgroundColor = 'rgba(40,167,69,0.3)'
                    
                    setTimeout(() => {
                      e.target.textContent = originalText
                      e.target.style.backgroundColor = ''
                    }, 2000)
                  }).catch(err => {
                    alert('복사 실패: ' + err.message)
                  })
                }
              }
              
              // XML 상세보기 토글
              if (e.target.classList.contains('xml-view-detail-btn')) {
                const recordId = e.target.dataset.id
                const recordCard = document.querySelector(`.xml-record-item[data-id="${recordId}"]`)
                const detailDiv = recordCard.querySelector('.xml-record-detail')
                
                if (detailDiv.style.display === 'none') {
                  detailDiv.style.display = 'block'
                  e.target.textContent = '🔼'
                  e.target.title = '상세닫기'
                } else {
                  detailDiv.style.display = 'none'
                  e.target.textContent = '👁️'
                  e.target.title = '상세보기'
                }
              }
              
              // XML 삭제 버튼
              if (e.target.classList.contains('xml-delete-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                
                if (confirm('이 레코드를 삭제하시겠습니까?')) {
                  // DOM에서 제거
                  const recordCard = document.querySelector(`.xml-record-item[data-id="${recordId}"]`)
                  recordCard.style.opacity = '0'
                  recordCard.style.transform = 'translateX(-100%)'
                  
                  setTimeout(() => {
                    recordCard.remove()
                    
                    // 배열에서 제거
                    const index = window.xmlGeneratedRecords?.findIndex(r => r.id === recordId)
                    if (index > -1) {
                      window.xmlGeneratedRecords.splice(index, 1)
                    }
                    
                    // 카운트 업데이트
                    updateXMLRecordCount()
                    
                    // 번호 재정렬
                    reindexXMLRecords()
                    
                    // 목록이 비었으면 헤더도 제거
                    if (!window.xmlGeneratedRecords || window.xmlGeneratedRecords.length === 0) {
                      document.getElementById('xml-generated-records-area').innerHTML = ''
                    }
                  }, 300)
                }
              }
            })
            
            function updateRecordCount() {
              const badge = document.querySelector('.record-count-badge')
              if (badge) {
                const count = document.querySelectorAll('.record-item').length
                badge.textContent = `${count}개`
              }
            }

            function reindexRecords() {
              document.querySelectorAll('.record-item').forEach((card, index) => {
                const numberSpan = card.querySelector('.record-number')
                numberSpan.textContent = `#${index + 1}`
              })
            }
            
            // =========================================
            // XML 레코드 목록 관련 함수들
            // =========================================
            
            /**
             * XML 레코드 카운트 업데이트
             */
            function updateXMLRecordCount() {
              const badge = document.querySelector('.xml-record-count-badge')
              if (badge) {
                const count = document.querySelectorAll('.xml-record-item').length
                badge.textContent = `${count}개`
              }
            }
            
            /**
             * XML 레코드 번호 재정렬
             */
            function reindexXMLRecords() {
              document.querySelectorAll('.xml-record-item').forEach((card, index) => {
                const numberSpan = card.querySelector('.xml-record-number')
                if (numberSpan) {
                  numberSpan.textContent = `#${index + 1}`
                }
              })
            }
            
            // =========================================
            // 전체 내보내기 모달 관련 함수들
            // =========================================
            
            /**
             * 전체 내보내기 모달 표시
             */
            function showExportModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-container">
                        <div class="modal-header">
                            <h3>💾 전체 내보내기</h3>
                            <button class="modal-close-btn">✕</button>
                        </div>
                        
                        <div class="modal-body">
                            <p class="modal-description">
                                총 <strong>${window.generatedRecords.length}개</strong>의 레코드를 내보냅니다
                            </p>
                            
                            <div class="export-format-select">
                                <label>내보내기 형식</label>
                                <div class="format-options">
                                    <label class="format-option selected">
                                        <input type="radio" name="export-format" value="continuous" checked>
                                        <span class="option-text">
                                            <strong>연속 데이터</strong>
                                            <small>모든 레코드를 줄바꿈 없이 연결</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="export-format" value="lines">
                                        <span class="option-text">
                                            <strong>줄바꿈 구분</strong>
                                            <small>각 레코드를 줄바꿈으로 구분</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="export-format" value="hex">
                                        <span class="option-text">
                                            <strong>HEX 형식</strong>
                                            <small>16진수로 변환하여 표시</small>
                                        </span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="export-preview">
                                <label>미리보기</label>
                                <textarea id="export-preview-area" readonly rows="12"></textarea>
                                <div class="preview-stats">
                                    <span id="export-total-bytes">0 bytes</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-footer">
                            <button id="download-export-btn" class="btn-primary">
                                ⬇️ 파일 다운로드
                            </button>
                            <button id="copy-export-btn" class="btn-secondary">
                                📋 클립보드 복사
                            </button>
                            <button class="modal-close-btn btn-cancel">
                                취소
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 포맷 옵션 선택 스타일 처리
                modal.querySelectorAll('.format-option').forEach(option => {
                    option.addEventListener('click', function() {
                        modal.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        this.querySelector('input[type="radio"]').checked = true;
                        updateExportPreview();
                    });
                });
                
                // 포맷 변경 시 미리보기 업데이트
                modal.querySelectorAll('input[name="export-format"]').forEach(radio => {
                    radio.addEventListener('change', updateExportPreview);
                });
                
                // 초기 미리보기
                updateExportPreview();
                
                // 닫기 버튼들
                modal.querySelectorAll('.modal-close-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.remove();
                    });
                });
                
                // 오버레이 클릭으로 닫기
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // 다운로드
                modal.querySelector('#download-export-btn').addEventListener('click', () => {
                    const format = modal.querySelector('input[name="export-format"]:checked').value;
                    const data = generateExportData(format);
                    const filename = `telegrams_${new Date().getTime()}.txt`;
                    downloadFile(data, filename);
                });
                
                // 복사
                modal.querySelector('#copy-export-btn').addEventListener('click', () => {
                    const textarea = modal.querySelector('#export-preview-area');
                    textarea.select();
                    document.execCommand('copy');
                    
                    const btn = modal.querySelector('#copy-export-btn');
                    const originalText = btn.textContent;
                    btn.textContent = '✓ 복사됨';
                    btn.style.backgroundColor = '#1e7e34';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                });
            }
            
            /**
             * 내보내기 미리보기 업데이트
             */
            function updateExportPreview() {
                const format = document.querySelector('input[name="export-format"]:checked').value;
                const data = generateExportData(format);
                
                document.getElementById('export-preview-area').value = data;
                document.getElementById('export-total-bytes').textContent = `${data.length} bytes`;
            }
            
            /**
             * 내보내기 데이터 생성
             */
            function generateExportData(format) {
                const records = window.generatedRecords.slice().reverse(); // 원래 순서로
                const telegrams = records.map(r => r.telegram);
                
                switch(format) {
                    case 'continuous':
                        return telegrams.join('');
                        
                    case 'lines':
                        return telegrams.join('\n');
                        
                    case 'hex':
                        return telegrams.map((t, i) => {
                            const hex = toHexString(t);
                            return `레코드 #${i+1}:\n${hex}`;
                        }).join('\n\n');
                        
                    default:
                        return telegrams.join('');
                }
            }
            
            /**
             * 문자열을 HEX 문자열로 변환
             */
            function toHexString(str) {
                return Array.from(str)
                    .map((c, i) => {
                        const hex = c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                        return (i > 0 && i % 16 === 0) ? '\n' + hex : hex;
                    })
                    .join(' ');
            }
            
            /**
             * 파일 다운로드
             */
            function downloadFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // =========================================
            // XML 전체 내보내기 모달 관련 함수들
            // =========================================
            
            /**
             * XML 전체 내보내기 모달 표시
             */
            function showXMLExportModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-container">
                        <div class="modal-header">
                            <h3>💾 XML 레코드 전체 내보내기</h3>
                            <button class="modal-close-btn">✕</button>
                        </div>
                        
                        <div class="modal-body">
                            <p class="modal-description">
                                총 <strong>${window.xmlGeneratedRecords.length}개</strong>의 XML 레코드를 내보냅니다
                            </p>
                            
                            <div class="export-format-select">
                                <label>내보내기 형식</label>
                                <div class="format-options">
                                    <label class="format-option selected">
                                        <input type="radio" name="xml-export-format" value="continuous" checked>
                                        <span class="option-text">
                                            <strong>연속 데이터</strong>
                                            <small>모든 레코드를 줄바꿈 없이 연결</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="xml-export-format" value="lines">
                                        <span class="option-text">
                                            <strong>줄바꿈 구분</strong>
                                            <small>각 레코드를 줄바꿈으로 구분</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="xml-export-format" value="hex">
                                        <span class="option-text">
                                            <strong>HEX 형식</strong>
                                            <small>16진수로 변환하여 표시</small>
                                        </span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="export-preview">
                                <label>미리보기</label>
                                <textarea id="xml-export-preview-area" readonly rows="12"></textarea>
                                <div class="preview-stats">
                                    <span id="xml-export-total-bytes">0 bytes</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-footer">
                            <button id="xml-download-export-btn" class="btn-primary">
                                ⬇️ 파일 다운로드
                            </button>
                            <button id="xml-copy-export-btn" class="btn-secondary">
                                📋 클립보드 복사
                            </button>
                            <button class="modal-close-btn btn-cancel">
                                취소
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 포맷 옵션 선택 스타일 처리
                modal.querySelectorAll('.format-option').forEach(option => {
                    option.addEventListener('click', function() {
                        modal.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        this.querySelector('input[type="radio"]').checked = true;
                        updateXMLExportPreview();
                    });
                });
                
                // 포맷 변경 시 미리보기 업데이트
                modal.querySelectorAll('input[name="xml-export-format"]').forEach(radio => {
                    radio.addEventListener('change', updateXMLExportPreview);
                });
                
                // 초기 미리보기
                updateXMLExportPreview();
                
                // 닫기 버튼들
                modal.querySelectorAll('.modal-close-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.remove();
                    });
                });
                
                // 오버레이 클릭으로 닫기
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // 다운로드
                modal.querySelector('#xml-download-export-btn').addEventListener('click', () => {
                    const format = modal.querySelector('input[name="xml-export-format"]:checked').value;
                    const data = generateXMLExportData(format);
                    const filename = `xml_telegrams_${new Date().getTime()}.txt`;
                    downloadFile(data, filename);
                });
                
                // 복사
                modal.querySelector('#xml-copy-export-btn').addEventListener('click', () => {
                    const textarea = modal.querySelector('#xml-export-preview-area');
                    textarea.select();
                    document.execCommand('copy');
                    
                    const btn = modal.querySelector('#xml-copy-export-btn');
                    const originalText = btn.textContent;
                    btn.textContent = '✓ 복사됨';
                    btn.style.backgroundColor = '#1e7e34';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                });
            }
            
            /**
             * XML 내보내기 미리보기 업데이트
             */
            function updateXMLExportPreview() {
                const format = document.querySelector('input[name="xml-export-format"]:checked').value;
                const data = generateXMLExportData(format);
                
                document.getElementById('xml-export-preview-area').value = data;
                document.getElementById('xml-export-total-bytes').textContent = `${data.length} bytes`;
            }
            
            /**
             * XML 내보내기 데이터 생성
             */
            function generateXMLExportData(format) {
                const records = window.xmlGeneratedRecords.slice().reverse(); // 원래 순서로
                const telegrams = records.map(r => r.telegram);
                
                switch(format) {
                    case 'continuous':
                        return telegrams.join('');
                    case 'lines':
                        return telegrams.join('\n');
                    case 'hex':
                        return telegrams.map(t => {
                            return Array.from(t).map(c => {
                                return c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                            }).join(' ');
                        }).join('\n');
                    default:
                        return telegrams.join('');
                }
            }
            
            /**
             * 생성 폼 초기화
             */
            function resetGenerateForm() {
                // 비활성화되지 않은 입력 필드만 초기화
                document.querySelectorAll('.field-input:not(:disabled)').forEach(function(input) {
                    input.value = '';
                    input.style.borderColor = '#ced4da';
                    input.style.backgroundColor = '#fff';
                });
                
                // 카운터 초기화
                document.querySelectorAll('.current-length').forEach(function(span) {
                    span.textContent = '0';
                    span.style.color = '#6c757d';
                });
                
                // 미리보기 초기화
                document.querySelectorAll('.preview-text').forEach(function(code) {
                    const row = code.closest('tr');
                    if (row && !row.querySelector('.auto-field')) {
                        code.textContent = '';
                    }
                });
                
                // 미리보기 박스 숨김
                const previewBox = document.getElementById('telegram-preview-box');
                if (previewBox) {
                    previewBox.style.display = 'none';
                }
                
                // 첫 입력 필드로 포커스
                const firstInput = document.querySelector('.field-input:not(:disabled)');
                if (firstInput) firstInput.focus();
            }
            
            /**
             * 레코드 수 반환
             */
            function getRecordCount() {
                return document.querySelectorAll('.record-item').length;
            }
            
            // add-to-list-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'add-to-list-btn') {
                    // 1. 폼 검증
                    const inputs = document.querySelectorAll('.field-input');
                    let telegram = '';
                    const fieldData = [];
                    let hasError = false;
                    
                    inputs.forEach(function(input) {
                        const fieldName = input.dataset.field;
                        const fieldSize = parseInt(input.dataset.size);
                        let value = input.disabled ? '\r\n' : input.value;
                        
                        // 필수 필드 체크
                        if (fieldName && fieldName.toLowerCase().match(/kubun|type/) && !value && !input.disabled) {
                            hasError = true;
                            input.style.borderColor = '#dc3545';
                            input.focus();
                            return;
                        }
                        
                        const paddedValue = padValue(value, fieldSize, fieldName);
                        telegram += paddedValue;
                        
                        fieldData.push({
                            name: fieldName,
                            size: fieldSize,
                            value: value,
                            padded: paddedValue
                        });
                    });
                    
                    if (hasError) {
                        alert('필수 필드를 입력하세요');
                        return;
                    }
                    
                    // 2. 레코드 객체 생성
                    const select = document.getElementById('generate-struct-select');
                    const structName = select.options[select.selectedIndex].text.split('(')[0].trim();
                    
                    const record = {
                        id: Date.now(),
                        structName: structName,
                        telegram: telegram,
                        fieldData: fieldData,
                        timestamp: new Date().toLocaleString('ko-KR'),
                        length: telegram.length
                    };
                    
                    // 3. 목록에 추가
                    addRecordToList(record);
                    
                    // 4. 폼 초기화 옵션
                    const shouldReset = confirm(
                        '레코드가 추가되었습니다.\n\n' +
                        '입력 폼을 초기화하시겠습니까?\n' +
                        '(아니오를 선택하면 같은 값으로 계속 추가할 수 있습니다)'
                    );
                    
                    if (shouldReset) {
                        resetGenerateForm();
                    }
                    
                    // 5. 성공 메시지
                    showTemporaryMessage('✓ 레코드 #' + getRecordCount() + '가 추가되었습니다');
                    
                    // 6. 레코드 영역으로 스크롤
                    document.getElementById('generated-records-area').scrollIntoView({ 
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            });
            
            // reset-form-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'reset-form-btn') {
                    if (confirm('입력한 내용을 모두 초기화하시겠습니까?')) {
                        resetGenerateForm();
                    }
                }
            });
            
            // load-generate-form-btn 클릭 이벤트
            document.getElementById('load-generate-form-btn').addEventListener('click', function() {
                // 1. 구조체 정의 수집
                const structDefs = collectStructDefinitions();
                
                if (!structDefs || structDefs.length === 0) {
                    alert('구조체를 먼저 정의하세요.');
                    return;
                }
                
                // 2. select 옵션 채우기
                const select = document.getElementById('generate-struct-select');
                select.innerHTML = '<option value="">구조체를 선택하세요</option>';
                
                structDefs.forEach(function(struct, index) {
                    const option = document.createElement('option');
                    option.value = index;
                    
                    // 구조체 정보 표시
                    const structInfo = (struct.name || ('구조체' + (index + 1))) + ' (' + struct.totalSize + ' bytes';
                    const fieldInfo = ', ' + struct.fields.length + '개 필드)';
                    option.textContent = structInfo + fieldInfo;
                    
                    select.appendChild(option);
                });
                
                // 3. select 활성화
                select.disabled = false;
                
                // 4. 구조체 선택 이벤트 (기존 이벤트 제거 후 추가)
                const newSelect = select.cloneNode(true);
                select.parentNode.replaceChild(newSelect, select);
                
                newSelect.addEventListener('change', function() {
                    const selectedIndex = parseInt(this.value);
                    
                    if (isNaN(selectedIndex)) {
                        document.getElementById('generate-form-container').style.display = 'none';
                        return;
                    }
                    
                    const selectedStruct = structDefs[selectedIndex];
                    displayGenerateForm(selectedStruct);
                });
                
                // 버튼 비활성화 (한 번만 로드)
                this.disabled = true;
                this.textContent = '✓ 로드 완료';
                
                showTemporaryMessage('구조체 목록을 불러왔습니다. 생성할 구조체를 선택하세요.');
            });
            
            // load-xml-form-btn 클릭 이벤트 (XML 규격 기반 폼 로드)
            document.getElementById('load-xml-form-btn').addEventListener('click', function() {
                const xmlText = document.getElementById('xml-generate-spec').value.trim();
                
                if (!xmlText) {
                    alert('XML 규격을 먼저 입력하세요');
                    return;
                }
                
                // XML 파싱
                const xmlSpec = parseXMLSpec(xmlText);
                
                if (!xmlSpec || xmlSpec.length === 0) {
                    alert('XML 파싱에 실패했습니다. 형식을 확인하세요');
                    return;
                }
                
                // 폼 표시
                displayXMLGenerateForm(xmlSpec);
                
                // 버튼 비활성화
                this.disabled = true;
                this.textContent = '✓ 로드 완료';
                
                showTemporaryMessage('✓ ' + xmlSpec.length + '개 필드가 로드되었습니다');
            });
            
            // XML 규격 textarea 변경 시 로드 버튼 초기화
            document.getElementById('xml-generate-spec').addEventListener('input', function() {
                const loadBtn = document.getElementById('load-xml-form-btn');
                if (loadBtn && loadBtn.disabled) {
                    loadBtn.disabled = false;
                    loadBtn.textContent = '폼 불러오기';
                    
                    // 폼 컨테이너 숨기기
                    document.getElementById('xml-generate-form-container').style.display = 'none';
                }
            });
            
            // 구조체 카드 추가/삭제 시 폼 로드 버튼 초기화
            // MutationObserver 사용 (DOMNodeInserted는 deprecated)
            const structObserver = new MutationObserver(function(mutations) {
                const loadBtn = document.getElementById('load-generate-form-btn');
                if (loadBtn && loadBtn.disabled) {
                    loadBtn.disabled = false;
                    loadBtn.textContent = '폼 불러오기';
                }
            });
            
            const structDefsContainer = document.getElementById('struct-definitions-container');
            if (structDefsContainer) {
                structObserver.observe(structDefsContainer, { childList: true, subtree: true });
            }
            
            // 초기 로드 버튼 활성화 확인
            setTimeout(function() {
                const loadBtn = document.getElementById('load-generate-form-btn');
                const cards = document.querySelectorAll('.struct-card');
                if (loadBtn && cards.length > 0) {
                    loadBtn.disabled = false;
                }
            }, 100);
        });
    </script>
</body>
</html>
