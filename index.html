<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>통전문 파서</title>
    <style>
        /**
         * =====================================================
         * 통전문 파서 스타일시트
         * =====================================================
         * 주요 기능:
         * 1. XML 파싱 탭 - XML 규격 기반 통전문 파싱
         * 2. C 구조체 파싱 탭 - C 구조체 기반 파싱
         * 
         * UX 기능:
         * - 구조체 카드 접기/펼치기 (▼ ↔ ▶)
         * - 드래그 앤 드롭 카드 재정렬
         * - 로컬 스토리지 자동 저장/복원
         * - 다크모드 지원
         * - 키보드 단축키 (Ctrl+Enter, Ctrl+N)
         * =====================================================
         */

        /* =====================================================
         * 기본 레이아웃 스타일
         * ===================================================== */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        /* 입력 영역 */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* =====================================================
         * 결과 표시 영역
         * ===================================================== */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* 테이블 스타일 */
        #result-table, .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td,
        .result-table th, .result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th, .result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even),
        .result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover,
        .result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7),
        .result-table td:last-child {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* 반응형 테이블 래퍼 */
        .table-wrapper {
            overflow-x: auto;
        }

        /* 버튼 그룹 */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #struct-test-btn {
            background: #17a2b8;
            margin-right: 10px;
        }

        #struct-test-btn:hover {
            background: #138496;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* 에러 메시지 스타일 */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* 파싱 에러 스타일 */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* =====================================================
         * 탭 네비게이션 스타일
         * ===================================================== */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 구조체 결과 그룹 스타일 */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* 구조체 요약 정보 스타일 */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* 복사 버튼 스타일 */
        .copy-result-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .copy-result-btn:hover {
            background: #1e7e34;
        }

        /* =====================================================
         * 도움말 섹션 (접기/펼치기)
         * ===================================================== */
        .help-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .help-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-toggle:hover {
            background: #dee2e6;
        }

        .help-toggle-icon {
            transition: transform 0.3s ease;
        }

        .help-toggle.expanded .help-toggle-icon {
            transform: rotate(180deg);
        }

        .help-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .help-content.expanded {
            padding: 16px;
            max-height: 500px;
        }

        .help-content h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .help-content p {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        .help-content ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }

        .help-content li {
            margin: 5px 0;
            color: #666;
            font-size: 13px;
        }

        .help-content code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .help-content pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin: 10px 0;
        }

        /* 테스트 버튼 스타일 */
        #run-tests-btn {
            background: #6f42c1;
            margin-left: auto;
        }

        #run-tests-btn:hover {
            background: #5a32a3;
        }

        /* 테스트 결과 스타일 */
        .test-results {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .test-results.success {
            background: #d4edda;
            border: 1px solid #28a745;
        }

        .test-results.failure {
            background: #f8d7da;
            border: 1px solid #dc3545;
        }

        .test-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-pass {
            color: #28a745;
        }

        .test-fail {
            color: #dc3545;
        }

        /* 섹션 헤더 스타일 */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        .header-options {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .option-checkbox {
            background: #e7f3ff;
            padding: 8px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-checkbox:hover {
            background: #cce5ff;
        }

        .option-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .option-description {
            background: #f8f9fa;
            padding: 10px 15px;
            border-left: 4px solid #6c757d;
            margin-bottom: 15px;
            color: #495057;
        }

        .option-description small {
            font-size: 13px;
            line-height: 1.6;
        }

        /* =====================================================
         * 서브 탭 네비게이션 (파싱/생성 모드)
         * ===================================================== */
        .sub-tab-nav {
            display: flex;
            gap: 10px;
            margin-top: 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
        }

        .sub-tab-btn {
            padding: 12px 24px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s;
        }

        .sub-tab-btn:hover {
            background: #e9ecef;
        }

        .sub-tab-btn.active {
            background: white;
            border-bottom: 3px solid white;
            font-weight: bold;
            color: #007bff;
            position: relative;
            bottom: -2px;
        }

        .sub-mode-content {
            display: none;
            padding: 20px 0;
        }

        .sub-mode-content.active {
            display: block;
        }

        /* =====================================================
         * 전문 생성 모드 스타일
         * ===================================================== */
        .generate-intro {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .generate-intro h4 {
            margin: 0 0 8px 0;
            font-size: 20px;
        }

        .generate-intro p {
            margin: 0;
            opacity: 0.95;
            font-size: 14px;
        }

        .struct-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 25px;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }

        .struct-selector label {
            font-weight: bold;
            min-width: 140px;
            color: #495057;
        }

        .form-select {
            flex: 1;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .form-select:focus {
            border-color: #007bff;
            outline: none;
        }

        .primary-btn {
            padding: 10px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .primary-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .primary-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .secondary-btn {
            padding: 10px 24px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .secondary-btn:hover {
            background: #5a6268;
        }

        .danger-btn {
            padding: 10px 24px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .danger-btn:hover {
            background: #c82333;
        }

        /* =====================================================
         * 전문 생성 폼 스타일
         * ===================================================== */
        .generate-form-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .generate-form-header h5 {
            margin: 0;
            font-size: 16px;
        }

        .generate-form-header .struct-info {
            font-size: 13px;
            opacity: 0.9;
        }

        .generate-fields-form {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .generate-field-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .generate-field-row:last-child {
            margin-bottom: 0;
        }

        .generate-field-row label {
            min-width: 180px;
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }

        .generate-field-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        .generate-field-input:focus {
            border-color: #17a2b8;
            outline: none;
        }

        .generate-field-input:disabled {
            background: #e9ecef;
            color: #6c757d;
        }

        .field-counter {
            min-width: 60px;
            text-align: right;
            font-size: 12px;
            color: #6c757d;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .field-counter.over {
            color: #dc3545;
            font-weight: bold;
        }

        .generate-form-actions {
            display: flex;
            gap: 12px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }

        /* 생성된 레코드 목록 스타일 */
        #generated-records-area {
            margin-top: 25px;
        }

        .generated-records-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: #28a745;
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .generated-records-header h5 {
            margin: 0;
            flex: 1;
        }

        .generated-records-header button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .generated-record-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
        }

        .generated-record-item:last-child {
            border-radius: 0 0 8px 8px;
        }

        .record-info {
            min-width: 150px;
            font-weight: 500;
            color: #495057;
            font-size: 13px;
        }

        .generated-record-content {
            flex: 1;
            padding: 8px 12px;
            background: #f1f3f4;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            word-break: break-all;
            color: #212529;
        }

        .copy-record-btn {
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .copy-record-btn:hover {
            background: #0056b3;
        }

        .delete-record-btn {
            padding: 6px 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-record-btn:hover {
            background: #c82333;
        }

        /* 레코드 아이템 개선 스타일 */
        .record-item {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
        }

        .record-item .record-info {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .record-number {
            display: inline-block;
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .record-struct-name {
            font-weight: 600;
            color: #212529;
        }

        .record-length {
            color: #6c757d;
            font-size: 12px;
        }

        .record-timestamp {
            color: #adb5bd;
            font-size: 11px;
        }

        .record-telegram {
            flex: 1;
            min-width: 200px;
        }

        .record-btn-group {
            display: flex;
            gap: 6px;
        }

        .toggle-details-btn {
            padding: 6px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .toggle-details-btn:hover {
            background: #5a6268;
        }

        .record-field-details {
            width: 100%;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #dee2e6;
        }

        .field-details-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .field-details-table th,
        .field-details-table td {
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            text-align: left;
        }

        .field-details-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .field-details-table td code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }

        /* =====================================================
         * 생성된 레코드 목록 (새 디자인)
         * ===================================================== */
        .records-header {
            background: #f8f9fa;
            padding: 20px;
            border: 2px solid #dee2e6;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-left h4 {
            margin: 0;
            color: #495057;
        }

        .record-count-badge {
            background: #007bff;
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .header-right {
            display: flex;
            gap: 10px;
        }

        .export-btn,
        .clear-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .export-btn {
            background: #28a745;
            color: white;
        }

        .export-btn:hover {
            background: #218838;
        }

        .clear-btn {
            background: #dc3545;
            color: white;
        }

        .clear-btn:hover {
            background: #c82333;
        }

        .records-list {
            background: #fff;
            border: 2px solid #dee2e6;
            border-top: none;
            padding: 15px;
            max-height: 600px;
            overflow-y: auto;
        }

        #generated-records-area .record-item {
            display: block;
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: all 0.2s;
            padding: 0;
        }

        #generated-records-area .record-item:hover {
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15);
            transform: translateY(-2px);
        }

        .record-item-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        .record-meta {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #generated-records-area .record-item .record-number {
            background: rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 15px;
            color: white;
        }

        #generated-records-area .record-item .record-struct-name {
            font-weight: bold;
            font-size: 16px;
            color: white;
        }

        #generated-records-area .record-item .record-timestamp {
            opacity: 0.9;
            font-size: 13px;
            color: white;
        }

        .record-actions {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .record-item-body {
            padding: 20px;
        }

        .telegram-box {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }

        .telegram-text {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #495057;
            overflow-x: auto;
            white-space: pre;
        }

        .record-stats {
            margin-top: 12px;
            display: flex;
            gap: 20px;
        }

        .stat-item {
            font-size: 14px;
        }

        .stat-label {
            color: #6c757d;
            margin-left: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #495057;
        }

        .record-detail {
            padding: 20px;
            background: #f0f8ff;
            border-top: 2px solid #007bff;
        }

        .detail-table {
            width: 100%;
            border-collapse: collapse;
        }

        .detail-table th,
        .detail-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .detail-table th {
            background: #e7f3ff;
            font-weight: bold;
        }

        .detail-table code {
            background: #fff;
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            font-family: monospace;
        }

        /* =====================================================
         * 전문 생성 폼 (새 디자인)
         * ===================================================== */
        .generate-form {
            background: white;
            border: 2px solid #007bff;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .form-header {
            background: #e7f3ff;
            padding: 20px;
            border-bottom: 2px solid #007bff;
        }

        .form-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .form-title h4 {
            margin: 0;
            color: #004085;
        }

        .form-badge {
            background: #007bff;
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
        }

        .form-info {
            margin-top: 8px;
            color: #004085;
            opacity: 0.8;
        }

        .input-form-table {
            width: 100%;
            border-collapse: collapse;
        }

        .input-form-table th {
            background: #f8f9fa;
            padding: 14px;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #dee2e6;
        }

        .input-form-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }

        .input-form-table .field-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            box-sizing: border-box;
        }

        .input-form-table .field-input:focus {
            border-color: #007bff;
            outline: none;
        }

        .input-form-table .field-input:disabled {
            background: #e9ecef;
            color: #6c757d;
        }

        .input-form-table .field-preview {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: #6c757d;
            word-break: break-all;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .input-form-table .field-preview.filled {
            color: #28a745;
            font-weight: 500;
        }

        .input-form-table .field-preview.padded {
            color: #007bff;
        }

        .input-form-table .field-preview.over {
            color: #dc3545;
            font-weight: bold;
        }

        /* =====================================================
         * 필드 행 스타일 (createFieldRow)
         * ===================================================== */
        .field-name {
            font-weight: bold;
            color: #495057;
        }

        .field-tag {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
            font-weight: bold;
        }

        .auto-tag {
            background: #6c757d;
            color: white;
        }

        .numeric-tag {
            background: #ffc107;
            color: #000;
        }

        .field-size {
            color: #6c757d;
            text-align: center;
        }

        .input-form-table .field-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            transition: border 0.2s;
            box-sizing: border-box;
        }

        .input-form-table .field-input:focus {
            border-color: #007bff;
            outline: none;
            background: #f0f8ff;
        }

        .input-form-table .field-input.auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        .input-meta {
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
        }

        .char-counter {
            font-size: 12px;
            color: #6c757d;
        }

        .current-length {
            font-weight: bold;
        }

        .preview-cell {
            background: #f8f9fa;
        }

        .preview-text {
            display: block;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #495057;
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            overflow-x: auto;
            white-space: pre;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            padding: 20px;
            background: #f8f9fa;
        }

        .form-actions .btn-info {
            background: #17a2b8;
            flex: 1;
        }

        .form-actions .btn-info:hover {
            background: #138496;
        }

        .form-actions .btn-success {
            background: #28a745;
            flex: 1;
        }

        .form-actions .btn-success:hover {
            background: #218838;
        }

        .form-actions .btn-secondary {
            background: #6c757d;
            flex: 1;
        }

        .form-actions .btn-secondary:hover {
            background: #5a6268;
        }

        .form-actions button {
            padding: 12px;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .form-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .preview-box {
            margin-top: 20px;
            border-top: 3px solid #17a2b8;
        }

        .preview-box h5 {
            margin: 0 0 15px 0;
            color: #495057;
        }

        .preview-box .telegram-preview-content {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            word-break: break-all;
            white-space: pre-wrap;
        }

        .preview-box .preview-info {
            margin-top: 10px;
            font-size: 13px;
            color: #6c757d;
        }

        .preview-success {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 8px;
            overflow: hidden;
        }

        .preview-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 20px;
        }

        .preview-error h5 {
            margin: 0 0 12px 0;
            color: #721c24;
        }

        .preview-error ul {
            margin: 0;
            padding-left: 20px;
            color: #721c24;
        }

        .preview-header {
            background: #17a2b8;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h5 {
            margin: 0;
            color: white;
        }

        .copy-preview-btn {
            background: white;
            color: #17a2b8;
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-preview-btn:hover {
            background: #f8f9fa;
            transform: translateY(-1px);
        }

        .preview-content {
            padding: 20px;
        }

        .telegram-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #0c5460;
            white-space: pre;
            margin: 0;
            overflow-x: auto;
        }

        .preview-info {
            background: #bee5eb;
            padding: 15px 20px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .preview-info .info-item {
            display: flex;
            gap: 8px;
        }

        .preview-info .info-label {
            font-weight: bold;
            color: #0c5460;
        }

        .preview-info .info-value {
            color: #0c5460;
        }

        .preview-info .hex-value {
            font-family: monospace;
            font-size: 13px;
        }

        /* =====================================================
         * 구조체 정의 영역
         * ===================================================== */
        #add-struct-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #add-struct-btn:hover {
            background: #138496;
        }

        /* 구조체 정의 컨테이너 스타일 */
        #struct-definitions-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* 구조체 카드 스타일 */
        .struct-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        /* 드래그 앤 드롭 스타일 */
        .struct-card[draggable="true"] {
            cursor: grab;
        }

        .struct-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .struct-card.drag-over {
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        .struct-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .struct-card-header:hover {
            background: rgba(0, 0, 0, 0.02);
            margin: -5px -5px 10px -5px;
            padding: 5px 5px 15px 5px;
            border-radius: 5px 5px 0 0;
        }

        .struct-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapse-icon {
            font-size: 12px;
            color: #6c757d;
            transition: transform 0.3s ease;
            width: 16px;
            text-align: center;
        }

        .struct-card.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .struct-number {
            font-weight: bold;
            color: #495057;
            font-size: 16px;
        }

        /* 접힌 상태의 구조체명 미리보기 */
        .struct-preview {
            font-size: 14px;
            color: #6c757d;
            margin-left: 10px;
            font-style: italic;
        }

        .struct-card-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drag-handle {
            cursor: grab;
            color: #adb5bd;
            font-size: 18px;
            padding: 4px 8px;
        }

        .drag-handle:hover {
            color: #6c757d;
        }

        .remove-struct-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .remove-struct-btn:hover {
            background: #c82333;
        }

        /* 카드 본문 접기/펼치기 */
        .struct-card-body {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 1;
        }

        .struct-card.collapsed .struct-card-body {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .struct-card-body .input-row {
            margin-bottom: 12px;
        }

        .struct-card-body .input-row label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .struct-card-body .input-row input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .struct-card-body .input-row small {
            color: #6c757d;
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }

        .struct-card-body .input-row textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* 로컬 스토리지 복원 알림 스타일 */
        .restore-notification {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .restore-notification-text {
            color: #1565c0;
            font-size: 14px;
        }

        .restore-notification-actions {
            display: flex;
            gap: 10px;
        }

        .restore-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .restore-btn.primary {
            background: #1976d2;
            color: white;
        }

        .restore-btn.primary:hover {
            background: #1565c0;
        }

        .restore-btn.secondary {
            background: #e0e0e0;
            color: #424242;
        }

        .restore-btn.secondary:hover {
            background: #bdbdbd;
        }

        /* 단축키 힌트 스타일 */
        .shortcut-hint {
            font-size: 11px;
            color: #6c757d;
            margin-left: 5px;
        }

        /* 다크모드 토글 버튼 */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: #e0e0e0;
        }

        /* 파싱 설정 정보 스타일 */
        .parse-settings-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .parse-settings-info h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 15px;
        }

        .setting-item {
            display: flex;
            margin-bottom: 8px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-weight: bold;
            width: 150px;
        }

        .setting-value {
            padding: 4px 10px;
            border-radius: 4px;
        }

        .setting-value.enabled {
            background: #d4edda;
            color: #155724;
        }

        .setting-value.disabled {
            background: #f8d7da;
            color: #721c24;
        }

        .setting-value.mode-line-by-line {
            background: #d1ecf1;
            color: #0c5460;
        }

        .setting-value.mode-continuous {
            background: #d4edda;
            color: #155724;
        }

        /* 파싱 통계 스타일 */
        .parse-stats {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .parse-stats h3 {
            margin: 0 0 12px 0;
            color: #1565c0;
            font-size: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stats-grid > div {
            background: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }

        /* 에러 레코드 카드 스타일 */
        .error-record-card {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .error-record-card .error-header {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            font-weight: bold;
            align-items: center;
        }

        .error-record-card .error-icon {
            font-size: 24px;
        }

        .error-record-card .error-title {
            color: #856404;
            font-size: 16px;
        }

        .error-record-card .error-body .error-message {
            color: #856404;
            margin: 0 0 10px 0;
        }

        .error-record-card .error-data {
            background: #fff;
            padding: 10px;
            border: 1px solid #ffc107;
            font-family: monospace;
            overflow-x: auto;
            border-radius: 4px;
            margin: 0 0 10px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .error-record-card .error-info {
            color: #856404;
            font-size: 12px;
        }

        /* 레코드 헤더 스타일 */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        /* 구분값 배지 스타일 */
        .kubun-badge {
            background: #6610f2;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }

        /* 길이 검증 뱃지 스타일 */
        .length-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
        }

        .length-badge.success {
            background: #d4edda;
            color: #155724;
        }

        .length-badge.warning {
            background: #fff3cd;
            color: #856404;
        }

        .length-badge.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* 레코드 복사 버튼 스타일 */
        .copy-record-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .copy-record-btn:hover {
            background: #1e7e34;
        }

        /* 자동 설정 필드 스타일 (CRLF 등) */
        .auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        /* CRLF 필드 값 표시 스타일 */
        .crlf-value {
            background: #e3f2fd !important;
            font-family: 'Courier New', monospace;
            color: #1565c0;
            font-weight: bold;
        }

        /* 신규 레코드 폼 필드 입력 스타일 */
        .new-field-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .new-field-input:focus {
            border-color: #80bdff;
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        /* 미리보기 셀 스타일 */
        .preview-cell {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            color: #495057;
        }

        /* 모바일 대응 */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .record-header {
                flex-wrap: wrap;
                gap: 8px;
            }

            .theme-toggle {
                top: 10px;
                right: 10px;
                width: 35px;
                height: 35px;
            }
        }

        /* =====================================================
         * 다크모드 스타일
         * ===================================================== */
        body.dark-mode {
            background-color: #1a1a2e;
            color: #e0e0e0;
        }

        body.dark-mode h1 {
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn.active {
            background: #1a1a2e;
            border-bottom-color: #1a1a2e;
            color: #64b5f6;
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"] {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode textarea::placeholder,
        body.dark-mode input::placeholder {
            color: #888;
        }

        body.dark-mode .struct-card {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .struct-number {
            color: #e0e0e0;
        }

        body.dark-mode .struct-preview {
            color: #aaa;
        }

        body.dark-mode .struct-card-body .input-row label {
            color: #e0e0e0;
        }

        body.dark-mode .struct-card-body .input-row small {
            color: #aaa;
        }

        body.dark-mode .help-section {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .help-toggle {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .help-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .help-content {
            color: #ccc;
        }

        body.dark-mode .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-content p,
        body.dark-mode .help-content li {
            color: #bbb;
        }

        body.dark-mode .help-content code {
            background: #3d3d5c;
            color: #64b5f6;
        }

        body.dark-mode .help-content pre {
            background: #1a1a2e;
        }

        body.dark-mode #result-table,
        body.dark-mode .result-table {
            border-color: #3d3d5c;
        }

        body.dark-mode #result-table th,
        body.dark-mode .result-table th {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table td,
        body.dark-mode .result-table td {
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table tr:nth-child(even),
        body.dark-mode .result-table tr:nth-child(even) {
            background: #252540;
        }

        body.dark-mode #result-table tr:hover,
        body.dark-mode .result-table tr:hover {
            background: #35355c;
        }

        body.dark-mode #result-table td:nth-child(7),
        body.dark-mode .result-table td:last-child {
            background: #2d2d44;
        }

        body.dark-mode .empty-value {
            background: #4a3030;
        }

        body.dark-mode .struct-result-group {
            border-color: #3d3d5c;
            background: #252540;
        }

        body.dark-mode .struct-result-group h3 {
            color: #e0e0e0;
        }

        body.dark-mode .record-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .record-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .length-badge.success {
            background: #1e4a2b;
            color: #90ee90;
        }

        body.dark-mode .length-badge.warning {
            background: #4a3d1e;
            color: #ffd700;
        }

        body.dark-mode .length-badge.error {
            background: #4a1e1e;
            color: #ff9090;
        }

        body.dark-mode .parse-settings-info {
            background: #2d2d3d;
            border-color: #4a4a5a;
        }

        body.dark-mode .parse-settings-info h4 {
            color: #b0b0c0;
        }

        body.dark-mode .setting-label {
            color: #e0e0e0;
        }

        body.dark-mode .setting-value.enabled {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .setting-value.disabled {
            background: #4a2020;
            color: #f5c6cb;
        }

        body.dark-mode .setting-value.mode-line-by-line {
            background: #1a3a4a;
            color: #8ecae6;
        }

        body.dark-mode .setting-value.mode-continuous {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .parse-stats {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .parse-stats h3 {
            color: #64b5f6;
        }

        body.dark-mode .stats-grid > div {
            background: #1a1a2e;
            color: #e0e0e0;
        }

        /* 다크모드 에러 레코드 카드 스타일 */
        body.dark-mode .error-record-card {
            background: #3d3520;
            border-color: #a68307;
        }

        body.dark-mode .error-record-card .error-title {
            color: #ffc107;
        }

        body.dark-mode .error-record-card .error-body .error-message {
            color: #ffd54f;
        }

        body.dark-mode .error-record-card .error-data {
            background: #2a2a3e;
            border-color: #a68307;
            color: #e0e0e0;
        }

        body.dark-mode .error-record-card .error-info {
            color: #ffd54f;
        }

        body.dark-mode .error-message {
            background: #4a2020;
            border-color: #8b3030;
            color: #ff8a80;
        }

        body.dark-mode .restore-notification {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .restore-notification-text {
            color: #64b5f6;
        }

        body.dark-mode .restore-btn.secondary {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .restore-btn.secondary:hover {
            background: #4d4d6c;
        }

        body.dark-mode .theme-toggle {
            background: #3d3d5c;
            border-color: #4d4d6c;
            color: #e0e0e0;
        }

        body.dark-mode .theme-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .test-results.success {
            background: #1e3a29;
            border-color: #2e8b57;
        }

        body.dark-mode .test-results.failure {
            background: #3a1e1e;
            border-color: #8b2e2e;
        }

        body.dark-mode .test-item {
            border-bottom-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .section-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox {
            background: #1e3a5f;
            border-color: #4a90d9;
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox:hover {
            background: #2a4a6f;
        }

        body.dark-mode .option-description {
            background: #2d2d2d;
            border-left-color: #6c757d;
            color: #b0b0b0;
        }

        /* 다크모드 - 서브 탭 네비게이션 */
        body.dark-mode .sub-tab-nav {
            border-bottom-color: #444;
        }

        body.dark-mode .sub-tab-btn {
            background: #2d2d2d;
            border-color: #444;
            color: #b0b0b0;
        }

        body.dark-mode .sub-tab-btn:hover {
            background: #3d3d3d;
        }

        body.dark-mode .sub-tab-btn.active {
            background: #1e1e1e;
            border-bottom-color: #1e1e1e;
            color: #64b5f6;
        }

        body.dark-mode .drag-handle {
            color: #6c757d;
        }

        body.dark-mode .drag-handle:hover {
            color: #adb5bd;
        }

        body.dark-mode .struct-card.drag-over {
            border-color: #64b5f6;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        /* 다크모드 - 자동 설정 필드 스타일 */
        body.dark-mode .auto-field {
            background: #3d3d5c;
            color: #adb5bd;
        }

        body.dark-mode .new-field-input {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .new-field-input:focus {
            border-color: #64b5f6;
            box-shadow: 0 0 0 0.2rem rgba(100, 181, 246, 0.25);
        }

        body.dark-mode .preview-cell {
            background: #2d2d44;
            color: #adb5bd;
        }

        /* =====================================================
         * 임시 메시지 스타일
         * ===================================================== */
        .temporary-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #17a2b8;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 9999;
            animation: slideIn 0.3s;
        }

        .temporary-message.fade-out {
            opacity: 0;
            transition: opacity 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
            }
            to {
                transform: translateX(0);
            }
        }

        /* =====================================================
         * 도움말 아이콘 및 모달 스타일
         * ===================================================== */
        .help-icon {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 14px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
        }

        .help-icon:hover {
            background: #138496;
        }

        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 10000;
        }

        .help-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal .help-content {
            background: white;
            width: 600px;
            max-width: 90%;
            max-height: 80vh;
            padding: 30px;
            border-radius: 8px;
            overflow-y: auto;
            position: relative;
        }

        .help-modal .help-content h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        }

        .help-modal .help-content h4 {
            margin-top: 15px;
            margin-bottom: 10px;
            color: #444;
        }

        .help-modal .close-help {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal .close-help:hover {
            background: #5a6268;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .help-section li {
            margin-bottom: 5px;
            line-height: 1.5;
        }

        .help-section code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .help-example {
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            white-space: pre-wrap;
            margin-top: 10px;
            overflow-x: auto;
        }

        .help-tip {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin-top: 20px;
            border-radius: 0 4px 4px 0;
        }

        .help-tip strong {
            color: #856404;
        }

        /* 다크모드 - 도움말 모달 */
        body.dark-mode .help-modal .help-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .help-modal .help-content h3,
        body.dark-mode .help-modal .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-section code {
            background: #3d3d3d;
            color: #e0e0e0;
        }

        body.dark-mode .help-example {
            background: #1e1e1e;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .help-tip {
            background: #3d3520;
            border-left-color: #ffc107;
            color: #e0e0e0;
        }

        /* 테스트 케이스 모달 */
        .test-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 10000;
        }

        .test-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-modal .test-content {
            background: white;
            width: 400px;
            max-width: 90%;
            padding: 25px;
            border-radius: 8px;
            position: relative;
        }

        .test-modal .test-content h4 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
        }

        .test-modal .close-test {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .test-modal .close-test:hover {
            background: #5a6268;
        }

        .test-modal .test-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .test-modal .test-buttons button {
            padding: 12px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s;
        }

        .test-modal .test-buttons button[data-case="normal"] {
            background: #28a745;
            color: white;
        }

        .test-modal .test-buttons button[data-case="normal"]:hover {
            background: #1e7e34;
        }

        .test-modal .test-buttons button[data-case="short"] {
            background: #ffc107;
            color: #212529;
        }

        .test-modal .test-buttons button[data-case="short"]:hover {
            background: #e0a800;
        }

        .test-modal .test-buttons button[data-case="long"] {
            background: #fd7e14;
            color: white;
        }

        .test-modal .test-buttons button[data-case="long"]:hover {
            background: #e96b02;
        }

        .test-modal .test-buttons button[data-case="mismatch"] {
            background: #dc3545;
            color: white;
        }

        .test-modal .test-buttons button[data-case="mismatch"]:hover {
            background: #c82333;
        }

        .test-modal .test-buttons button[data-case="mixed"] {
            background: #6f42c1;
            color: white;
        }

        .test-modal .test-buttons button[data-case="mixed"]:hover {
            background: #5a32a3;
        }

        /* 연속 데이터 테스트 케이스 버튼 스타일 */
        .test-modal .test-buttons button[data-case="continuous"] {
            background: #17a2b8;
            color: white;
        }

        .test-modal .test-buttons button[data-case="continuous"]:hover {
            background: #138496;
        }

        .test-modal .test-buttons button[data-case="continuous_multi"] {
            background: #20c997;
            color: white;
        }

        .test-modal .test-buttons button[data-case="continuous_multi"]:hover {
            background: #1aa179;
        }

        /* 테스트 그룹 스타일 */
        .test-modal .test-group {
            margin-bottom: 20px;
        }

        .test-modal .test-group h5 {
            margin: 0 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            color: #495057;
            font-size: 14px;
        }

        .test-modal .test-group:last-child {
            margin-bottom: 0;
        }

        /* 다크모드 - 테스트 모달 */
        body.dark-mode .test-modal .test-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .test-modal .test-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-tip strong {
            color: #ffc107;
        }

        /* =====================================================
         * 전체 내보내기 모달 스타일
         * ===================================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s;
        }

        .modal-container {
            background: white;
            width: 700px;
            max-height: 90vh;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
        }

        .modal-close-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .modal-close-btn:hover {
            opacity: 0.8;
        }

        .modal-body {
            padding: 25px;
            max-height: calc(90vh - 160px);
            overflow-y: auto;
        }

        .modal-description {
            color: #495057;
            margin-bottom: 20px;
        }

        .export-format-select > label {
            display: block;
            font-weight: bold;
            margin-bottom: 12px;
        }

        .format-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .format-option {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-option:hover {
            background: #e9ecef;
        }

        .format-option.selected {
            background: #e7f3ff;
            border-color: #007bff;
        }

        .format-option input[type="radio"] {
            width: 20px;
            height: 20px;
        }

        .option-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .option-text strong {
            color: #495057;
        }

        .option-text small {
            color: #6c757d;
        }

        .export-preview > label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #export-preview-area {
            width: 100%;
            font-family: monospace;
            font-size: 13px;
            padding: 15px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            background: #f8f9fa;
            box-sizing: border-box;
            resize: vertical;
        }

        .preview-stats {
            margin-top: 10px;
            color: #6c757d;
            text-align: right;
        }

        .modal-footer {
            background: #f8f9fa;
            padding: 20px 25px;
            display: flex;
            gap: 12px;
            border-top: 1px solid #dee2e6;
        }

        .modal-footer button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .modal-footer .btn-primary {
            background: #007bff;
            color: white;
        }

        .modal-footer .btn-primary:hover {
            background: #0056b3;
        }

        .modal-footer .btn-secondary {
            background: #28a745;
            color: white;
        }

        .modal-footer .btn-secondary:hover {
            background: #1e7e34;
        }

        .modal-footer .btn-cancel {
            background: #6c757d;
            color: white;
            flex: 0.5;
        }

        .modal-footer .btn-cancel:hover {
            background: #545b62;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* 다크모드 - 내보내기 모달 */
        body.dark-mode .modal-container {
            background: #2d2d2d;
        }

        body.dark-mode .modal-body {
            color: #e0e0e0;
        }

        body.dark-mode .modal-description {
            color: #b0b0b0;
        }

        body.dark-mode .format-option {
            background: #3d3d3d;
            border-color: #4d4d4d;
        }

        body.dark-mode .format-option:hover {
            background: #4d4d4d;
        }

        body.dark-mode .format-option.selected {
            background: #1a365d;
            border-color: #4a90d9;
        }

        body.dark-mode .option-text strong {
            color: #e0e0e0;
        }

        body.dark-mode .option-text small {
            color: #a0a0a0;
        }

        body.dark-mode #export-preview-area {
            background: #3d3d3d;
            border-color: #4d4d4d;
            color: #e0e0e0;
        }

        body.dark-mode .modal-footer {
            background: #252525;
            border-top-color: #4d4d4d;
        }

        body.dark-mode .preview-stats {
            color: #a0a0a0;
        }
    </style>
</head>
<body>
    <!-- 다크모드 토글 버튼 -->
    <button class="theme-toggle" id="theme-toggle" title="다크모드 전환">🌙</button>
    
    <h1>통전문 파서</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML 파싱</button>
        <button class="tab-btn" data-tab="struct">C 구조체 파싱</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        <div id="input-section">
            <label for="xml-input">XML 규격</label>
            <textarea id="xml-input" rows="10" placeholder="XML 규격 입력"></textarea>
            
            <label for="telegram-input">통전문</label>
            <textarea id="telegram-input" rows="5" placeholder="통전문 입력"></textarea>
        </div>
        
        <div class="button-group">
            <button id="sample-btn">샘플 로드</button>
            <button id="parse-btn">파싱 실행</button>
            <button id="clear-btn">초기화</button>
        </div>
        
        <div id="result-container"></div>
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <!-- 도움말 섹션 -->
        <div class="help-section">
            <button class="help-toggle" type="button">
                <span>📖 사용 방법 안내</span>
                <span class="help-toggle-icon">▼</span>
            </button>
            <div class="help-content">
                <h4>C 구조체 파싱 사용법</h4>
                <p>고정 길이 데이터를 C 구조체 정의에 따라 파싱합니다.</p>
                
                <h4>1. 구조체 정의 형식</h4>
                <p><code>typedef struct { ... } 구조체명;</code> 형식으로 입력합니다.</p>
                <pre>typedef struct {
    char record_kubun[1];  // 레코드 구분
    char bank_cd[2];       // 은행 코드
    char cust_id[7];       // 고객 ID
} DHF_H;</pre>
                
                <h4>2. 데이터 입력 규칙</h4>
                <ul>
                    <li>각 줄이 하나의 데이터 레코드입니다</li>
                    <li>여러 구조체가 있을 경우, 첫 글자로 구조체를 자동 매칭합니다</li>
                    <li>예: <code>H</code>로 시작 → <code>DHF_H</code> (H로 끝나는 구조체)</li>
                    <li>예: <code>D</code>로 시작 → <code>DHF_D</code> (D로 끝나는 구조체)</li>
                </ul>
                
                <h4>3. 지원 기능</h4>
                <ul>
                    <li>여러 구조체 동시 정의 가능</li>
                    <li>주석 지원: <code>//</code> 한줄 주석, <code>/* */</code> 블록 주석</li>
                    <li>파싱 결과를 TSV 형식으로 클립보드에 복사 가능</li>
                </ul>
                
                <h4>4. 주의사항</h4>
                <ul>
                    <li>데이터 길이가 구조체 총 크기와 다르면 경고가 표시됩니다</li>
                    <li>char 배열만 정확히 지원됩니다 (int, short 등은 char로 처리)</li>
                </ul>
            </div>
        </div>

        <!-- 공통: 구조체 정의 영역 -->
        <div id="struct-definitions-area">
            <div class="section-header">
                <h3>
                    C 구조체 정의
                    <button class="help-icon" id="crlf-help">❓</button>
                </h3>
                <div class="header-options">
                    <label class="option-checkbox">
                        <input type="checkbox" id="recognize-crlf">
                        개행문자 인식 (CRLF)
                    </label>
                    <label class="option-checkbox">
                        <input type="checkbox" id="debug-mode">
                        🔍 디버그 모드
                    </label>
                    <button id="add-struct-btn">+ 구조체 추가 <span class="shortcut-hint">(Ctrl+N)</span></button>
                </div>
            </div>
            <div class="option-description">
                <small>
                    ℹ️ 체크 시: 각 레코드 끝에 CRLF(2 bytes) 존재로 간주<br>
                    📝 체크 해제: 줄바꿈 제거 후 연속 데이터로 처리
                </small>
            </div>
            
            <div id="struct-definitions-container">
                <!-- 구조체 입력 카드들이 여기 동적 추가됨 -->
            </div>
        </div>

        <!-- 서브 탭 네비게이션 -->
        <div class="sub-tab-nav">
            <button class="sub-tab-btn active" data-mode="parse">
                📖 파싱 모드
            </button>
            <button class="sub-tab-btn" data-mode="generate">
                ✏️ 생성 모드
            </button>
        </div>

        <!-- 파싱 모드 컨텐츠 -->
        <div id="parse-mode-content" class="sub-mode-content active">
            <label for="struct-data">통 데이터</label>
            <textarea id="struct-data" rows="10" placeholder="파싱할 데이터 입력 (줄바꿈 유무 무관)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">샘플 로드</button>
                <button id="struct-test-btn">테스트 케이스</button>
                <button id="struct-parse-btn">파싱 실행 <span class="shortcut-hint">(Ctrl+Enter)</span></button>
                <button id="struct-clear-btn">전체 초기화</button>
            </div>
        </div>

        <!-- 생성 모드 컨텐츠 -->
        <div id="generate-mode-content" class="sub-mode-content">
          
          <div class="generate-intro">
            <h4>✏️ 전문 생성</h4>
            <p>정의된 구조체를 선택하고 각 필드에 값을 입력하여 통전문을 생성합니다.</p>
          </div>
          
          <div class="struct-selector">
            <label for="generate-struct-select">생성할 구조체 선택</label>
            <select id="generate-struct-select" class="form-select">
              <option value="">구조체를 먼저 정의하세요</option>
            </select>
            <button id="load-generate-form-btn" class="primary-btn" disabled>
              폼 불러오기
            </button>
          </div>
          
          <div id="generate-form-container" style="display: none;">
            <!-- 입력 폼이 여기 동적 생성됨 -->
          </div>
          
          <div id="generated-records-area">
            <!-- 생성된 레코드 목록 -->
          </div>
          
        </div>

        <div id="struct-result-container"></div>

        <!-- 개행문자 인식 도움말 모달 -->
        <div class="help-modal" id="crlf-help-modal">
            <div class="help-content">
                <button class="close-help">✕</button>
                <h3>💡 개행문자 인식 옵션 설명</h3>
                
                <div class="help-section">
                    <h4>✓ 체크 시 (권장)</h4>
                    <ul>
                        <li>C 구조체에 <code>crlf[2]</code> 필드가 있는 경우 사용</li>
                        <li>각 레코드 끝에 자동으로 <code>\r\n</code> (2 bytes) 추가</li>
                        <li>textarea에 줄바꿈으로 레코드 구분</li>
                    </ul>
                    
                    <pre class="help-example">예시:
H881234567
D123456789012345600000000000000001000
       ↓
H881234567\r\n  (12 bytes)
D123456789012345600000000000000001000\r\n  (39 bytes)</pre>
                </div>
                
                <div class="help-section">
                    <h4>✗ 체크 해제 시</h4>
                    <ul>
                        <li>구조체에 CRLF 필드가 없는 경우</li>
                        <li>모든 줄바꿈 제거 후 연속 데이터로 처리</li>
                        <li>구분값으로 레코드 자동 인식</li>
                    </ul>
                </div>
                
                <div class="help-tip">
                    <strong>💡 팁:</strong> 일반적인 전문 파일은 개행문자를 포함합니다.
                    확실하지 않다면 체크 상태로 두세요.
                </div>
            </div>
        </div>

        <!-- 테스트 케이스 선택 모달 -->
        <div class="test-modal" id="test-case-modal">
            <div class="test-content">
                <button class="close-test">✕</button>
                <h4>🧪 테스트 케이스 선택</h4>
                
                <!-- 개행 인식 ON 테스트 (라인 단위 파싱) -->
                <div class="test-group">
                    <h5>📄 개행 인식 ON (라인 단위)</h5>
                    <div class="test-buttons">
                        <button data-case="normal">✅ 정상 데이터</button>
                        <button data-case="short">⚠️ 길이 부족</button>
                        <button data-case="long">📏 길이 초과</button>
                        <button data-case="mismatch">❌ 매칭 실패</button>
                        <button data-case="mixed">🔀 혼합</button>
                    </div>
                </div>
                
                <!-- 개행 인식 OFF 테스트 (연속 데이터 파싱) -->
                <div class="test-group">
                    <h5>🔗 개행 인식 OFF (연속 데이터)</h5>
                    <div class="test-buttons">
                        <button data-case="continuous">📦 연속 데이터</button>
                        <button data-case="continuous_multi">🔄 연속 다중 레코드</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * =====================================================
         * 전역 변수
         * =====================================================
         */
        let structCardIndex = 0;

        /**
         * =====================================================
         * 정규식 캐싱 - 성능 최적화를 위해 정규식을 미리 컴파일
         * =====================================================
         */
        const REGEX_CACHE = {
            // 한줄 주석 제거: // 부터 줄 끝까지 매칭
            singleLineComment: /\/\/.*$/gm,
            
            // 블록 주석 제거: /* 부터 */ 까지 (비탐욕적 매칭)
            blockComment: /\/\*[\s\S]*?\*\//g,
            
            // typedef struct 블록 추출:
            // - typedef\s+struct: "typedef struct" 키워드
            // - (\w+)?: 선택적 구조체 이름 (캡처 그룹 1)
            // - \s*\{([^}]+)\}: 중괄호와 내용 (캡처 그룹 2)
            // - \s*(\w+)\s*;: typedef 별칭 이름 (캡처 그룹 3)
            structPattern: /typedef\s+struct\s+(\w+)?\s*\{([^}]+)\}\s*(\w+)\s*;/g,
            
            // 필드 추출:
            // - (unsigned\s+)?: 선택적 unsigned 키워드 (캡처 그룹 1)
            // - (\w+): 기본 타입 (char, int 등) (캡처 그룹 2)
            // - \s+(\w+): 필드명 (캡처 그룹 3)
            // - \s*\[\s*(\d+)\s*\]: 배열 크기 (캡처 그룹 4)
            fieldPattern: /(unsigned\s+)?(\w+)\s+(\w+)\s*\[\s*(\d+)\s*\]/g,
            
            // 구조체명에서 숫자 추출: 문자열 끝의 연속된 숫자
            trailingNumber: /(\d+)$/
        };

        /**
         * 정규식 패턴을 복제하여 반환
         * 정규식은 상태를 가지므로(lastIndex), 사용 전 복제 필요
         * @param {string} name - REGEX_CACHE의 키 이름
         * @returns {RegExp} 복제된 정규식 객체
         */
        function getRegex(name) {
            const original = REGEX_CACHE[name];
            return new RegExp(original.source, original.flags);
        }

        /**
         * =====================================================
         * 구조체 카드 생성 함수
         * 구조체 입력을 위한 카드 DOM 요소 생성
         * - 접기/펼치기 기능 지원
         * - 드래그 앤 드롭 재정렬 지원
         * =====================================================
         * @param {number} index - 구조체 인덱스 번호
         * @returns {HTMLElement} div.struct-card DOM 요소
         */
        function createStructCard(index) {
            // 1. div 생성, class="struct-card", data-index="${index}"
            const div = document.createElement('div');
            div.className = 'struct-card';
            div.setAttribute('data-index', index);
            div.setAttribute('draggable', 'true'); // 드래그 앤 드롭 활성화

            // 2. 내부 HTML 설정 (접기/펼치기 아이콘 및 드래그 핸들 포함)
            div.innerHTML = `
                <div class="struct-card-header">
                    <div class="struct-header-left">
                        <span class="collapse-icon">▼</span>
                        <span class="struct-number">구조체 #${index + 1}</span>
                        <span class="struct-preview"></span>
                    </div>
                    <div class="struct-card-header-actions">
                        <span class="drag-handle" title="드래그하여 순서 변경">⋮⋮</span>
                        <button class="remove-struct-btn" data-index="${index}">✕ 삭제</button>
                    </div>
                </div>
                
                <div class="struct-card-body">
                    <div class="input-row">
                        <label>구조체명 (선택)</label>
                        <input type="text" class="struct-name" placeholder="예: DHF_H, HeaderRecord" />
                    </div>
                    
                    <div class="input-row">
                        <label>구분값 (선택)</label>
                        <input type="text" class="struct-kubun" maxlength="5" placeholder="예: H, 01, HEADER" />
                        <small>여러 구조체 사용 시 필수. 데이터 첫 글자로 구조체 식별</small>
                    </div>
                    
                    <div class="input-row">
                        <label>구조체 정의</label>
                        <textarea class="struct-definition" rows="8" placeholder="typedef struct { ... } 구조체명;"></textarea>
                    </div>
                </div>
            `;

            // 3. 요소 반환
            return div;
        }

        /**
         * =====================================================
         * XML 규격 파싱 함수
         * XML 문자열을 파싱하여 col 요소 배열로 변환
         * =====================================================
         * @param {string} xmlString - XML 규격 문자열
         * @returns {Array|null} col 요소 배열 또는 null (에러 시)
         */
        function parseXMLSpec(xmlString) {
            // 입력값 유효성 검사
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: 입력값이 문자열이 아닙니다.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: 빈 문자열이 입력되었습니다.');
                return null;
            }

            // DOMParser를 사용해 XML 문서로 변환
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML 파싱 오류:', e.message);
                return null;
            }

            // parsererror 체크
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML 파싱 오류:', parseError.textContent);
                return null;
            }

            // 모든 col 요소 선택
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col 요소를 찾을 수 없습니다.');
                return [];
            }

            // 유효한 col 요소들을 담을 배열
            const result = [];

            // 각 col 요소 처리
            colElements.forEach((col, index) => {
                // 속성 추출
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // 필수 속성 검증
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소에 필수 속성이 누락되었습니다: ${missingAttrs.join(', ')}`
                    );
                    return; // 해당 요소 건너뛰기
                }

                // size를 정수로 변환
                const size = parseInt(sizeAttr, 10);

                // size가 유효한 정수인지 검증
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소의 size 속성이 유효한 숫자가 아닙니다: "${sizeAttr}"`
                    );
                    return; // 해당 요소 건너뛰기
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}번째 col 요소의 size 속성이 음수입니다: ${size}`
                    );
                    return; // 해당 요소 건너뛰기
                }

                // 유효한 col 정보를 결과 배열에 추가
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        /**
         * =====================================================
         * 통전문 파싱 함수
         * 통전문 문자열을 XML 규격에 맞게 분리
         * =====================================================
         * @param {string} telegramString - 통전문 문자열
         * @param {Array} xmlSpec - parseXMLSpec의 결과 배열
         * @returns {Array} 파싱된 결과 배열
         */
        function parseTelegram(telegramString, xmlSpec) {
            // 현재 위치 초기화
            let currentPos = 0;

            // 빈 결과 배열 생성
            const result = [];

            // xmlSpec 배열 순회
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // 시작/종료 위치 계산
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substring으로 값 추출 (인덱스 범위 초과해도 오류 없이 처리됨)
                const value = telegramString.substring(startPos, endPos);

                // 결과 배열에 추가
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // 현재 위치 이동
                currentPos += spec.size;
            }

            // 통전문 전체 길이와 예상 길이 비교
            if (telegramString.length !== currentPos) {
                console.warn(
                    `parseTelegram: 통전문 길이(${telegramString.length})와 예상 길이(${currentPos})가 일치하지 않습니다.`
                );
            }

            return result;
        }

        /**
         * =====================================================
         * 값 패딩 함수
         * 값을 지정된 크기에 맞게 패딩 (공백으로 채움)
         * =====================================================
         * @param {string} value - 패딩할 값
         * @param {number} size - 목표 크기
         * @param {string} fieldName - 필드명 (로깅용)
         * @returns {string} 패딩된 값
         */
        function padValue(value, size, fieldName) {
            // 값이 없으면 빈 문자열로 설정
            if (value === null || value === undefined) {
                value = '';
            }
            
            // 문자열로 변환
            value = String(value);
            
            // 값이 크기보다 크면 자르기
            if (value.length > size) {
                console.warn('padValue: 필드 "' + fieldName + '"의 값이 크기(' + size + ')를 초과합니다. 값을 자릅니다.');
                return value.substring(0, size);
            }
            
            // 값이 크기보다 작으면 패딩
            if (value.length < size) {
                // 숫자 필드: 좌측 0 패딩
                if (isNumericField(fieldName)) {
                    return value.padStart(size, '0');
                }
                // 문자 필드: 우측 공백 패딩
                return value.padEnd(size, ' ');
            }
            
            // 정확히 일치
            return value;
        }

        /**
         * =====================================================
         * 통전문 생성 함수 (29단계)
         * 필드 배열을 받아서 통전문 문자열 생성
         * CRLF 필드는 개행 인식 옵션에 따라 자동 처리
         * =====================================================
         * @param {Array} fields - 필드 배열 [{name, value, size}, ...]
         * @returns {string} 생성된 통전문 문자열
         */
        function generateTelegram(fields) {
            // 개행문자 인식 옵션 확인
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // 결과 통전문 문자열
            let telegram = '';
            
            // 각 필드 처리
            for (let i = 0; i < fields.length; i++) {
                const field = fields[i];
                
                // CRLF 필드 여부 확인
                if (field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                    // CRLF 필드 자동 처리
                    if (recognizeCRLF) {
                        telegram += '\r\n';  // 무조건 CRLF
                    } else {
                        // 개행 인식 비활성화 시에도 필드는 채워야 함
                        telegram += '  ';    // 공백 2개
                        console.warn('CRLF 필드를 공백으로 채웁니다 (개행 인식 비활성화됨)');
                    }
                } else {
                    // 일반 필드 처리
                    telegram += padValue(field.value, field.size, field.name);
                }
            }
            
            return telegram;
        }

        /**
         * =====================================================
         * C 구조체 정의 파싱 함수
         * 구조체 정의 문자열을 파싱하여 구조체 배열로 변환
         * =====================================================
         * @param {string} structText - C 구조체 정의 문자열
         * @returns {Array|null} 구조체 배열 또는 null (에러 시)
         */
        function parseStructDefinitions(structText) {
            // 입력값 유효성 검사
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 주석 제거 처리 - 캐시된 정규식 사용
            let cleanedText = structText.replace(getRegex('singleLineComment'), '');
            cleanedText = cleanedText.replace(getRegex('blockComment'), '');

            // 2. typedef struct 블록 추출 - 캐시된 정규식 사용
            const structPattern = getRegex('structPattern');
            
            // 타입별 크기 정의 (바이트)
            const typeSizes = {
                'char': 1,
                'unsigned char': 1,
                'short': 2,
                'unsigned short': 2,
                'int': 4,
                'unsigned int': 4,
                'long': 4,
                'unsigned long': 4
            };
            
            // 결과 배열
            const result = [];
            
            // typedef struct 블록들 추출
            let structMatch;
            while ((structMatch = structPattern.exec(cleanedText)) !== null) {
                const fieldsContent = structMatch[2]; // 중괄호 안의 내용
                const structName = structMatch[3];    // typedef 구조체명 (마지막 이름)
                
                // 필드 배열
                const fields = [];
                
                // 필드들 추출 - 새로운 정규식 인스턴스 사용
                const fieldPattern = getRegex('fieldPattern');
                let fieldMatch;
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    const unsignedPrefix = fieldMatch[1] ? fieldMatch[1].trim() : '';
                    const baseType = fieldMatch[2];
                    const fieldName = fieldMatch[3];
                    const arraySize = parseInt(fieldMatch[4], 10);
                    
                    // 전체 타입명 구성
                    const fullType = unsignedPrefix ? unsignedPrefix + ' ' + baseType : baseType;
                    
                    // 타입별 크기 계산
                    let typeSize = typeSizes[fullType] || typeSizes[baseType] || 1;
                    
                    // char 외의 타입은 경고 출력 (하지만 char 기준으로 처리)
                    if (baseType !== 'char') {
                        console.warn('parseStructDefinitions: "' + structName + '"의 필드 "' + fieldName + '"의 타입 "' + fullType + '"은 char로 처리됩니다. 크기 계산이 정확하지 않을 수 있습니다.');
                        // char 기준으로 처리 (배열 크기만 사용)
                        typeSize = 1;
                    }
                    
                    fields.push({
                        name: fieldName,
                        type: fullType,
                        size: arraySize * typeSize
                    });
                }
                
                // 빈 구조체 검증 - fields가 0개인 구조체는 제외
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: 구조체 "' + structName + '"에 유효한 필드가 없어 제외됩니다.');
                    continue;
                }
                
                // 구조체 객체 추가
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // 구조체가 하나도 없으면 null 반환
            if (result.length === 0) {
                console.error('parseStructDefinitions: 파싱된 구조체가 없습니다.');
                return null;
            }
            
            // 파싱된 구조체 개수 출력
            console.log('parseStructDefinitions: ' + result.length + '개의 구조체가 파싱되었습니다.');
            
            return result;
        }

        /**
         * =====================================================
         * 단일 C 구조체 정의 파싱 함수
         * 하나의 구조체 정의 문자열을 파싱하여 필드 배열로 변환
         * char 타입만 지원 (unsigned char도 char로 처리)
         * =====================================================
         * @param {string} structText - 단일 C 구조체 정의 문자열
         * @returns {Object|null} { fields: [...], totalSize: number } 또는 null (에러 시)
         */
        function parseStructDefinition(structText) {
            // 입력값 유효성 검사
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinition: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 주석 제거
            // // 주석 제거
            let cleanedText = structText.replace(/\/\/.*$/gm, '');
            // /* */ 주석 제거
            cleanedText = cleanedText.replace(/\/\*[\s\S]*?\*\//g, '');

            // 2. 필드 추출 정규식
            // char 또는 unsigned char 타입의 배열 필드 매칭
            // unsigned char도 char로 처리
            const fieldPattern = /char\s+(\w+)\s*\[\s*(\d+)\s*\]/g;

            // 3. matchAll로 모든 매칭 결과 순회
            const matches = cleanedText.matchAll(fieldPattern);
            const fields = [];

            for (const match of matches) {
                const fieldName = match[1];
                const size = parseInt(match[2], 10);

                // 필드 정보를 fields 배열에 추가
                fields.push({
                    name: fieldName,
                    size: size
                });
            }

            // 4. fields가 비어있으면 null 반환
            if (fields.length === 0) {
                console.error('parseStructDefinition: 유효한 필드가 없습니다.');
                return null;
            }

            // 5. 총 크기 계산
            const totalSize = fields.reduce((sum, f) => sum + f.size, 0);

            // 6. 결과 반환
            return { fields, totalSize };
        }

        /**
         * =====================================================
         * 구조체 정의 수집 함수
         * 모든 구조체 카드에서 정의를 수집하여 배열로 반환
         * =====================================================
         * @returns {Array|null} 구조체 정보 배열 또는 null (에러 시)
         */
        function collectStructDefinitions() {
            // 1. 모든 .struct-card 요소 선택
            const cards = document.querySelectorAll('.struct-card');

            // 2. 빈 배열 structDefs = []
            const structDefs = [];

            // 3. 각 카드마다 처리
            for (let index = 0; index < cards.length; index++) {
                const card = cards[index];

                // a. .struct-name 값 가져오기 (trim)
                const structNameInput = card.querySelector('.struct-name');
                const structName = structNameInput ? structNameInput.value.trim() : '';

                // b. .struct-kubun 값 가져오기 (trim)
                const kubunInput = card.querySelector('.struct-kubun');
                const kubunValue = kubunInput ? kubunInput.value.trim() : '';

                // c. .struct-definition 값 가져오기 (trim)
                const definitionInput = card.querySelector('.struct-definition');
                const definitionText = definitionInput ? definitionInput.value.trim() : '';

                // d. 구조체 정의가 비어있으면 해당 카드 건너뛰기
                if (definitionText === '') {
                    continue;
                }

                // e. parseStructDefinition(정의 텍스트) 호출
                const parsed = parseStructDefinition(definitionText);

                // f. 파싱 성공 시 structDefs에 추가
                if (parsed !== null) {
                    // CRLF 필드 존재 확인
                    const hasCRLFField = parsed.fields.some(function(f) {
                        return f.name.toLowerCase().match(/crlf|cr_lf|newline/);
                    });
                    
                    // 옵션과 일치 여부 확인
                    const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                    const currentName = structName || ('구조체' + (index + 1));
                    
                    if (recognizeCRLF && !hasCRLFField) {
                        console.warn('구조체 "' + currentName + '": 개행 인식 활성화되었으나 crlf 필드 없음');
                    }
                    
                    if (!recognizeCRLF && hasCRLFField) {
                        console.warn('구조체 "' + currentName + '": crlf 필드가 있으나 개행 인식 비활성화됨');
                    }
                    
                    structDefs.push({
                        name: currentName,
                        kubun: kubunValue || null,
                        fields: parsed.fields,
                        totalSize: parsed.totalSize,
                        hasCRLFField: hasCRLFField
                    });
                } else {
                    // g. 파싱 실패 시 에러 표시 후 null 반환
                    displayError('구조체 #' + (index + 1) + ' 파싱 실패', 'struct-result-container');
                    return null;
                }
            }

            // 4. structDefs가 비어있으면 에러 표시 후 null 반환
            if (structDefs.length === 0) {
                displayError('유효한 구조체가 없습니다', 'struct-result-container');
                return null;
            }

            // 5. 입력 검증 강화
            for (let i = 0; i < structDefs.length; i++) {
                const def = structDefs[i];
                
                // 구조체명에 특수문자 있으면 경고 (영문, 숫자, 언더스코어만 허용)
                if (def.name && !/^[a-zA-Z0-9_가-힣]+$/.test(def.name)) {
                    console.warn('collectStructDefinitions: 구조체 "' + def.name + '"의 이름에 특수문자가 포함되어 있습니다. 예상치 못한 동작이 발생할 수 있습니다.');
                }
                
                // 구분값이 너무 길면 (10자 이상) 경고
                if (def.kubun && def.kubun.length >= 10) {
                    console.warn('collectStructDefinitions: 구조체 "' + def.name + '"의 구분값이 ' + def.kubun.length + '자로 너무 깁니다. 10자 미만을 권장합니다.');
                }
            }

            // 6. 구분값 검증
            if (structDefs.length >= 2) {
                // 구조체가 2개 이상인데 kubun이 null인 것이 있으면 경고
                const hasNullKubun = structDefs.some(function(def) {
                    return def.kubun === null;
                });
                
                if (hasNullKubun) {
                    console.warn('collectStructDefinitions: 여러 구조체 중 구분값이 없는 것이 있습니다. 데이터 매칭이 정확하지 않을 수 있습니다.');
                }

                // 중복된 kubun 값이 있으면 에러
                const kubunValues = structDefs
                    .filter(function(def) { return def.kubun !== null; })
                    .map(function(def) { return def.kubun; });
                
                const duplicates = kubunValues.filter(function(value, idx, arr) {
                    return arr.indexOf(value) !== idx;
                });

                if (duplicates.length > 0) {
                    displayError('중복된 구분값이 있습니다: ' + duplicates.join(', '), 'struct-result-container');
                    return null;
                }

                // 구분값 길이 일관성 검사 (모두 같은 길이 권장)
                const kubunLengths = kubunValues.map(function(k) { return k.length; });
                const uniqueLengths = kubunLengths.filter(function(len, idx, arr) {
                    return arr.indexOf(len) === idx;
                });
                
                if (uniqueLengths.length > 1) {
                    console.warn('collectStructDefinitions: 구분값 길이가 일관되지 않습니다. 길이: ' + uniqueLengths.join(', ') + '. 모두 같은 길이로 통일하는 것을 권장합니다.');
                }
            }

            // 7. structDefs 반환
            console.log('collectStructDefinitions: ' + structDefs.length + '개의 구조체가 수집되었습니다.');
            return structDefs;
        }

        /**
         * =====================================================
         * kubun 기반 구조체 찾기 함수
         * 데이터의 첫 부분을 kubun 값과 비교하여 구조체 탐색
         * =====================================================
         * @param {string} data - 현재 위치부터의 데이터
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object|null} 매칭된 구조체 또는 null
         */
        function findStructByKubun(data, structDefs) {
            // 입력값 유효성 검사
            if (!data || !Array.isArray(structDefs) || structDefs.length === 0) {
                return null;
            }

            // 1. kubun이 null이 아닌 구조체들을 순회하며 매칭 시도
            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];
                const kubun = structDef.kubun;

                // kubun이 null이면 건너뛰기
                if (kubun === null || kubun === undefined) {
                    continue;
                }

                // kubun 길이만큼 data에서 추출하여 비교
                const kubunLength = kubun.length;
                const dataKubun = data.substring(0, kubunLength);

                // 매칭되면 해당 구조체 반환
                if (dataKubun === kubun) {
                    return structDef;
                }
            }

            // 2. 모두 실패 시 kubun이 null인 구조체 반환 (fallback)
            for (let i = 0; i < structDefs.length; i++) {
                if (structDefs[i].kubun === null || structDefs[i].kubun === undefined) {
                    return structDefs[i];
                }
            }

            // 3. fallback도 없으면 null 반환
            return null;
        }

        /**
         * =====================================================
         * 매칭 구조체 찾기 함수
         * 데이터 라인의 첫 글자로 매칭되는 구조체 탐색
         * =====================================================
         * @param {string} line - 데이터 라인
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object|null} 매칭된 구조체 또는 null
         */
        function findMatchingStruct(line, structDefs) {
            // 입력값 유효성 검사
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: 유효하지 않은 입력입니다.');
                return null;
            }

            // 1. 구조체가 1개만 있으면 그것 반환
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. 여러 개일 경우 매칭 로직
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // 필드가 없으면 건너뛰기
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // 첫 번째 필드의 size만큼 line에서 추출
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // 구조체명에서 구분 패턴 추출
                // 예: DHF_H → 'H', DHF_D → 'D', ST_HEADER_1 → '1'
                const structName = structDef.name;
                
                // 구조체명 마지막 부분 추출 (언더스코어 뒤 또는 마지막 문자/숫자)
                let structIdentifier = '';
                
                // 언더스코어로 분리하여 마지막 부분 추출
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // 마지막 부분이 단일 문자 또는 숫자인 경우
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // 마지막 부분에서 숫자 추출 시도 - 캐시된 정규식 사용
                    const numMatch = lastPart.match(getRegex('trailingNumber'));
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // 마지막 문자 사용
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // 구조체명 마지막 문자/숫자와 line 첫 문자 비교
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // 첫 필드 값과 구조체 식별자 비교
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. 매칭 실패 시 null 반환, 콘솔에 경고
            console.warn('findMatchingStruct: 라인 "' + line.substring(0, 20) + '..."에 매칭되는 구조체를 찾을 수 없습니다.');
            return null;
        }

        /**
         * =====================================================
         * 구조체 데이터 파싱 함수 (메인 진입점)
         * =====================================================
         * 
         * [기능 설명]
         * 개행문자 인식 옵션(recognize-crlf)에 따라 파싱 모드를 결정합니다.
         * 
         * [파싱 모드]
         * 1. 라인 기반 파싱 (개행 인식 ON)
         *    - 각 줄을 독립적인 레코드로 처리
         *    - 줄 끝에 CRLF(2 bytes) 자동 추가
         *    - 길이 부족 시 다음 라인 침범 안 함
         * 
         * 2. 연속 데이터 파싱 (개행 인식 OFF)
         *    - 모든 줄바꿈 제거 후 연속 데이터로 처리
         *    - 구분값(kubun) 기반으로 레코드 분리
         *    - CRLF 필드 없는 구조체 사용
         * 
         * @param {string} dataText - 파싱할 통 데이터 텍스트
         * @param {Array} structDefs - 구조체 정의 배열 [{name, kubun, fields, totalSize}, ...]
         * @returns {Object} 파싱 결과
         *   - records: 파싱된 레코드 배열
         *   - stats: 통계 정보 {totalBytes, parsedBytes, recordCount, errorBytes, mode}
         */
        function parseStructData(dataText, structDefs) {
            // 입력값 유효성 검사
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: 데이터 텍스트가 유효하지 않습니다.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: 구조체 정의가 유효하지 않습니다.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            // 1. 옵션 읽기
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // 2. 데이터 전처리 및 파싱 분기
            if (recognizeCRLF) {
                // === 라인 기반 파싱 ===
                return parseLineByLine(dataText, structDefs);
            } else {
                // === 연속 데이터 파싱 ===
                return parseContinuous(dataText, structDefs);
            }
        }

        /**
         * =====================================================
         * 라인 기반 파싱 함수 (개행 인식 ON 모드)
         * =====================================================
         * 
         * [처리 흐름]
         * 1. 이스케이프 처리 (\\r\\n → \r\n)
         * 2. 줄 단위 분리 (CRLF/LF 기준)
         * 3. 각 라인별 구조체 매칭 (구분값 기반)
         * 4. 필드별 데이터 추출
         * 5. 길이 검증 (부족/초과 시 경고)
         * 
         * [특징]
         * - 각 라인은 독립적으로 처리 (다음 라인 침범 안 함)
         * - 라인 끝에 CRLF(2 bytes) 자동 추가됨
         * - 매칭 실패 시 에러 레코드로 기록
         * - 길이 부족 시 경고만 표시하고 파싱은 진행
         * 
         * [에러 처리]
         * - 구조체 매칭 실패: 에러 레코드 생성, 다음 라인으로 진행
         * - 길이 부족/초과: 콘솔 경고, 가능한 만큼 파싱
         * 
         * @param {string} dataText - 통 데이터 텍스트 (줄바꿈 포함)
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {Object} { records: [...], stats: {...} } 형식의 파싱 결과
         */
        function parseLineByLine(dataText, structDefs) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            
            // 1. 이스케이프 처리
            let processedText = dataText
                .replace(/\\r\\n/g, '\r\n')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r');

            // 2. 줄 단위로 분리
            const lines = processedText.split(/\r?\n/)
                .map(line => line.trimEnd())  // 우측 공백만 제거
                .filter(line => line.length > 0);  // 빈 줄 제거

            console.log(`라인 기반 파싱: 총 ${lines.length}개 라인`);
            
            // 디버그 모드: 초기 정보 로깅
            if (isDebugMode) {
                console.group('🔍 파싱 디버그 - Line By Line 모드');
                console.log('📋 모드:', 'line-by-line');
                console.log('📊 전체 라인 수:', lines.length);
                console.log('📐 정의된 구조체:', structDefs.map(s => `${s.name}(구분값:${s.kubun})`).join(', '));
                console.log('---');
                
                lines.forEach((line, i) => {
                    console.log(`📝 라인 ${i+1}:`, {
                        length: line.length,
                        kubun: line[0] || '(없음)',
                        preview: line.substring(0, 30) + (line.length > 30 ? '...' : ''),
                        hex: Array.from(line.substring(0, 10)).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ')
                    });
                });
                console.log('---');
            }

            // 3. 변수 초기화
            const records = [];
            let recordIndex = 0;
            let totalBytes = 0;
            let parsedBytes = 0;
            let errorLines = 0;

            // 4. 각 라인 순회
            lines.forEach((line, lineIndex) => {
                totalBytes += line.length + 2;  // +2 for CRLF

                // 구조체 매칭
                const matched = findStructByKubun(line, structDefs);

                if (!matched) {
                    console.warn(`라인 ${lineIndex + 1}: 매칭 실패 - "${line.substring(0, 20)}..."`);
                    errorLines++;
                    
                    // 디버그: 매칭 실패 상세 정보
                    if (isDebugMode) {
                        console.warn(`  ❌ 구분값 '${line[0]}'에 해당하는 구조체 없음`);
                        console.warn(`  📋 등록된 구분값들:`, structDefs.map(s => s.kubun));
                    }

                    // 에러 레코드 추가
                    records.push({
                        error: true,
                        lineNumber: lineIndex + 1,
                        lineData: line,
                        message: '매칭되는 구조체 없음'
                    });
                    return;  // 다음 라인으로
                }

                // 디버그: 매칭된 구조체 정보
                if (isDebugMode) {
                    console.group(`✅ 라인 ${lineIndex + 1} → ${matched.name}`);
                    console.log('📌 구분값:', matched.kubun);
                    console.log('📏 필드 수:', matched.fields.length);
                }

                // 길이 검증
                const expectedSize = matched.totalSize;
                const actualSize = line.length + 2;  // CRLF 포함

                // 디버그: 길이 비교
                if (isDebugMode) {
                    const lengthStatus = actualSize === expectedSize ? '✅ 일치' : 
                                        actualSize < expectedSize ? '⚠️ 부족' : '⚠️ 초과';
                    console.log(`📐 길이 비교: 예상=${expectedSize}, 실제=${actualSize} ${lengthStatus}`);
                }

                if (actualSize < expectedSize) {
                    console.warn(
                        `라인 ${lineIndex + 1}: 길이 부족 ` +
                        `(예상: ${expectedSize}, 실제: ${actualSize})`
                    );
                } else if (actualSize > expectedSize) {
                    console.warn(
                        `라인 ${lineIndex + 1}: 길이 초과 ` +
                        `(예상: ${expectedSize}, 실제: ${actualSize})`
                    );
                }

                // 라인 데이터에 CRLF 추가
                const lineWithCRLF = line + '\r\n';

                // 필드별 파싱
                let fieldOffset = 0;
                
                // 디버그: 필드 파싱 시작
                if (isDebugMode) {
                    console.log('📋 필드별 추출:');
                }
                
                matched.fields.forEach(field => {
                    const startPos = fieldOffset;
                    const endPos = startPos + field.size;
                    const value = lineWithCRLF.substring(startPos, endPos);
                    
                    // 디버그: 각 필드 값 로깅
                    if (isDebugMode) {
                        const hexValue = Array.from(value).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
                        const displayValue = value.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                        console.log(`  📍 ${field.name}[${field.size}]: "${displayValue}" | HEX: ${hexValue}`);
                    }

                    records.push({
                        recordIndex,
                        lineNumber: lineIndex + 1,
                        structName: matched.name,
                        kubun: matched.kubun,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value,
                        startPos,
                        endPos
                    });

                    fieldOffset += field.size;
                });
                
                // 디버그: 그룹 종료
                if (isDebugMode) {
                    console.groupEnd();
                }

                parsedBytes += Math.min(actualSize, expectedSize);
                recordIndex++;
            });

            // 5. 통계 계산
            const stats = {
                totalBytes,
                parsedBytes,
                recordCount: recordIndex,
                errorLines,
                mode: 'line-by-line'
            };
            
            // 디버그: 최종 통계 로깅
            if (isDebugMode) {
                console.log('---');
                console.log('📊 파싱 완료 통계:', {
                    모드: stats.mode,
                    전체바이트: stats.totalBytes,
                    파싱바이트: stats.parsedBytes,
                    레코드수: stats.recordCount,
                    에러라인: stats.errorLines
                });
                console.groupEnd();
            }

            // 6. 반환
            return { records, stats };
        }

        /**
         * =====================================================
         * 연속 데이터 파싱 함수 (개행 인식 OFF 모드)
         * =====================================================
         * 
         * [처리 흐름]
         * 1. 전처리: 모든 줄바꿈 제거 (\r, \n)
         * 2. 현재 위치에서 구조체 매칭 (구분값 기반)
         * 3. 매칭 성공: 필드별 데이터 추출, 구조체 크기만큼 이동
         * 4. 매칭 실패: 1바이트 스킵, 에러 바이트 카운트 증가
         * 5. 데이터 끝까지 반복
         * 
         * [특징]
         * - 줄바꿈이 완전히 무시됨
         * - 구조체에 CRLF 필드가 없어야 함
         * - 구분값으로 레코드 시작점 탐지
         * - 연속된 여러 레코드 자동 분리
         * 
         * [에러 처리]
         * - 구조체 매칭 실패: 1바이트 스킵 후 재시도
         * - 에러 바이트 수 통계에 누적
         * - 과도한 에러 로그 방지 (최대 10개까지만 출력)
         * 
         * [사용 예시]
         * - CRLF 없는 구조체: "H881234567D1234567890123456..." 형태
         * - 구분값 H, D, T 등으로 레코드 분리
         * 
         * @param {string} dataText - 통 데이터 텍스트 (줄바꿈 포함 가능)
         * @param {Array} structDefs - 구조체 정의 배열 (CRLF 필드 없음)
         * @returns {Object} { records: [...], stats: {...} } 형식의 파싱 결과
         */
        function parseContinuous(dataText, structDefs) {
            const isDebugMode = document.getElementById('debug-mode')?.checked;
            
            // 1. 전처리: 모든 개행 제거
            const processedData = dataText.replace(/[\r\n]/g, '');
            console.log(`연속 파싱: 총 ${processedData.length} bytes`);
            
            // 디버그 모드: 초기 정보 로깅
            if (isDebugMode) {
                console.group('🔍 파싱 디버그 - Continuous 모드');
                console.log('📋 모드:', 'continuous');
                console.log('📊 전체 데이터 길이:', processedData.length, 'bytes');
                console.log('📐 정의된 구조체:', structDefs.map(s => `${s.name}(구분값:${s.kubun}, 크기:${s.totalSize})`).join(', '));
                console.log('📝 데이터 미리보기:', processedData.substring(0, 50) + (processedData.length > 50 ? '...' : ''));
                console.log('📝 HEX 미리보기:', Array.from(processedData.substring(0, 20)).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' '));
                console.log('---');
            }

            // 2. 변수 초기화
            const records = [];
            let currentPos = 0;
            let recordIndex = 0;
            let errorBytes = 0;

            // 3. 메인 루프
            while (currentPos < processedData.length) {
                const remainingData = processedData.substring(currentPos);

                // 구조체 매칭
                const matched = findStructByKubun(remainingData, structDefs);

                if (!matched) {
                    // 디버그: 매칭 실패 정보
                    if (isDebugMode && errorBytes < 10) { // 너무 많은 로그 방지
                        console.warn(`  ❌ 위치 ${currentPos}: 구분값 '${remainingData[0]}'에 매칭 실패, 1바이트 스킵`);
                    }
                    errorBytes++;
                    currentPos++;
                    continue;
                }
                
                // 디버그: 매칭된 구조체 정보
                if (isDebugMode) {
                    console.group(`✅ 레코드 ${recordIndex + 1} (위치: ${currentPos}) → ${matched.name}`);
                    console.log('📌 구분값:', matched.kubun);
                    console.log('📏 구조체 크기:', matched.totalSize, 'bytes');
                    
                    // 길이 비교
                    const remainingLength = processedData.length - currentPos;
                    const lengthStatus = remainingLength >= matched.totalSize ? '✅ 충분' : '⚠️ 부족';
                    console.log(`📐 길이 비교: 필요=${matched.totalSize}, 남은 데이터=${remainingLength} ${lengthStatus}`);
                    console.log('📋 필드별 추출:');
                }

                // 필드 파싱
                let fieldOffset = 0;
                matched.fields.forEach(field => {
                    const startPos = currentPos + fieldOffset;
                    const endPos = startPos + field.size;
                    const value = processedData.substring(startPos, endPos);
                    
                    // 디버그: 각 필드 값 로깅
                    if (isDebugMode) {
                        const hexValue = Array.from(value).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
                        const displayValue = value.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                        console.log(`  📍 ${field.name}[${field.size}]: "${displayValue}" | HEX: ${hexValue}`);
                    }

                    records.push({
                        recordIndex,
                        structName: matched.name,
                        kubun: matched.kubun,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value,
                        startPos,
                        endPos
                    });

                    fieldOffset += field.size;
                });
                
                // 디버그: 그룹 종료
                if (isDebugMode) {
                    console.groupEnd();
                }

                currentPos += matched.totalSize;
                recordIndex++;
            }

            // 4. 통계
            const stats = {
                totalBytes: processedData.length,
                parsedBytes: processedData.length - errorBytes,
                recordCount: recordIndex,
                errorBytes,
                mode: 'continuous'
            };
            
            // 디버그: 최종 통계 로깅
            if (isDebugMode) {
                console.log('---');
                console.log('📊 파싱 완료 통계:', {
                    모드: stats.mode,
                    전체바이트: stats.totalBytes,
                    파싱바이트: stats.parsedBytes,
                    레코드수: stats.recordCount,
                    에러바이트: stats.errorBytes
                });
                if (errorBytes > 0) {
                    console.warn(`⚠️ ${errorBytes}바이트가 매칭되지 않았습니다.`);
                }
                console.groupEnd();
            }

            // 5. 반환
            return { records, stats };
        }

        /**
         * =====================================================
         * 에러 메시지 표시 함수
         * 지정된 컨테이너에 에러 메시지 표시
         * =====================================================
         * @param {string} message - 에러 메시지
         * @param {string} targetContainer - 타겟 컨테이너 ID (기본: struct-result-container)
         */
        function displayError(message, targetContainer) {
            // 1. targetContainer 가져오기 (기본값: struct-result-container)
            const containerId = targetContainer || 'struct-result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTML을 에러 메시지로 설정
            container.innerHTML = `<div class="error-message">⚠️ ${message}</div>`;
        }

        /**
         * =====================================================
         * XML 파싱 결과 표시 함수
         * DocumentFragment를 사용하여 DOM 조작 최적화
         * =====================================================
         * @param {Array} parsedData - parseTelegram의 결과 배열
         */
        function displayResults(parsedData) {
            // 1. result-container 요소 가져오기
            const container = document.getElementById('result-container');

            // 2. innerHTML 초기화
            container.innerHTML = '';

            // DocumentFragment 생성 - DOM 조작 최적화
            const fragment = document.createDocumentFragment();

            // 3. table 요소 생성
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead 생성 후 tr 추가, th 7개
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['순번', '필드명', '타입', '크기', '시작', '종료', '값'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody 생성
            const tbody = document.createElement('tbody');

            // 6. parsedData 배열 순회
            parsedData.forEach(function(item, index) {
                // tr 생성
                const tr = document.createElement('tr');

                // td 7개 생성
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    item.value
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    td.textContent = value;

                    // value가 공백만 있으면 class="empty-value" 추가 (마지막 td, 즉 value 컬럼)
                    if (tdIndex === 6 && typeof value === 'string' && value.trim() === '') {
                        td.classList.add('empty-value');
                    }

                    tr.appendChild(td);
                });

                // tbody에 tr 추가
                tbody.appendChild(tr);
            });

            // 7. table에 thead, tbody 추가
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. 반응형을 위한 wrapper div 생성
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. fragment에 추가 후 한 번에 DOM 업데이트
            fragment.appendChild(wrapper);
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * calculateRecordLength(record, mode)
         * =====================================================
         * 레코드의 실제 길이를 계산
         * @param {Object} record - 레코드 객체 (fields 배열 포함)
         * @param {string} mode - 파싱 모드 ('line-by-line' 또는 'continuous')
         * @returns {number} 레코드의 실제 바이트 길이
         */
        function calculateRecordLength(record, mode) {
            if (!record || !record.fields || !Array.isArray(record.fields)) {
                return 0;
            }
            
            // 모든 필드 크기 합계
            let totalSize = record.fields.reduce(function(sum, field) {
                return sum + (field.fieldSize || 0);
            }, 0);
            
            return totalSize;
        }

        /**
         * =====================================================
         * getExpectedLength(structName, structDefs)
         * =====================================================
         * 구조체 정의에서 예상 길이를 가져옴
         * @param {string} structName - 구조체 이름
         * @param {Array} structDefs - 구조체 정의 배열
         * @returns {number} 예상 바이트 길이
         */
        function getExpectedLength(structName, structDefs) {
            if (!structName || !Array.isArray(structDefs)) {
                return 0;
            }
            
            const struct = structDefs.find(function(s) {
                return s.name === structName;
            });
            
            return struct ? struct.totalSize : 0;
        }

        /**
         * =====================================================
         * escapeHtml(text)
         * =====================================================
         * HTML 특수문자를 이스케이프 처리 (XSS 방지)
         * 
         * @param {string} text - 이스케이프할 텍스트
         * @returns {string} 이스케이프된 텍스트
         */
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * =====================================================
         * escapeForDisplay(str)
         * =====================================================
         * 문자열의 특수문자를 표시용 이스케이프 시퀀스로 변환
         * 
         * @param {string} str - 변환할 문자열
         * @returns {string} 이스케이프된 문자열
         */
        function escapeForDisplay(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/\r/g, '\\r')
                .replace(/\n/g, '\\n')
                .replace(/\t/g, '\\t');
        }

        /**
         * =====================================================
         * toHexPreview(str)
         * =====================================================
         * 문자열의 앞부분을 HEX로 변환하여 미리보기 생성
         * 
         * @param {string} str - 변환할 문자열
         * @returns {string} HEX 미리보기 문자열 (최대 16바이트)
         */
        function toHexPreview(str) {
            if (typeof str !== 'string') return '';
            const hex = Array.from(str.substring(0, 16))
                .map(function(c) {
                    return c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                })
                .join(' ');
            
            return hex + (str.length > 16 ? ' ...' : '');
        }

        /**
         * =====================================================
         * formatFieldValue(value, isCRLFField)
         * =====================================================
         * 필드 값을 표시용으로 포맷팅
         * - CRLF 필드: 특수문자를 이스케이프 시퀀스로 표시 (\r\n)
         * - 일반 필드: 공백 여부만 확인
         * 
         * @param {string} value - 필드 값
         * @param {boolean} isCRLFField - CRLF 필드 여부
         * @returns {string} 포맷팅된 값
         */
        function formatFieldValue(value, isCRLFField) {
            if (typeof value !== 'string') {
                return value;
            }
            
            // CRLF 필드인 경우 특수문자를 이스케이프 표시
            if (isCRLFField) {
                // \r\n → "\\r\\n" 형태로 표시
                return value
                    .replace(/\r/g, '\\r')
                    .replace(/\n/g, '\\n');
            }
            
            // 일반 필드: 그대로 반환
            return value;
        }

        /**
         * =====================================================
         * createLengthBadge(record, structDefs, mode)
         * =====================================================
         * 길이 검증 뱃지 HTML을 생성
         * @param {Object} record - 레코드 객체
         * @param {Array} structDefs - 구조체 정의 배열
         * @param {string} mode - 파싱 모드
         * @returns {string} 뱃지 HTML 문자열
         */
        function createLengthBadge(record, structDefs, mode) {
            const actualLength = calculateRecordLength(record, mode);
            const expectedLength = getExpectedLength(record.structName, structDefs);
            
            if (expectedLength === 0) {
                return '<span class="length-badge warning">? 길이 정보 없음</span>';
            }
            
            if (actualLength === expectedLength) {
                return '<span class="length-badge success">\u2713 ' + actualLength + 'B</span>';
            } else if (actualLength < expectedLength) {
                return '<span class="length-badge warning">\u26a0\ufe0f ' + actualLength + 'B / ' + expectedLength + 'B (부족)</span>';
            } else {
                return '<span class="length-badge error">\u26a0\ufe0f ' + actualLength + 'B / ' + expectedLength + 'B (초과)</span>';
            }
        }

        /**
         * =====================================================
         * 구조체 파싱 결과 표시 함수
         * DocumentFragment를 사용하여 DOM 조작 최적화
         * =====================================================
         * @param {Object} parseResult - { records, stats, structDefs } 형식의 파싱 결과
         *   - records: 레코드 배열 (각 레코드: { recordIndex, structName, kubun, fields })
         *   - stats: 통계 정보 { totalBytes, parsedBytes, recordCount, errorBytes }
         *   - structDefs: 구조체 정의 배열
         */
        function displayStructResults(parseResult) {
            // 1. struct-result-container 초기화
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // 입력값 유효성 검사
            if (!parseResult || !parseResult.records) {
                container.innerHTML = '<div class="error-message">⚠️ 파싱 결과가 없습니다.</div>';
                return;
            }

            const { records, stats, structDefs } = parseResult;

            // 파싱 설정 정보 가져오기
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // DocumentFragment 생성 - DOM 조작 최적화
            const fragment = document.createDocumentFragment();

            // 파싱 설정 정보 표시
            const settingsDiv = document.createElement('div');
            settingsDiv.className = 'parse-settings-info';
            settingsDiv.innerHTML = `
                <h4>⚙️ 파싱 설정</h4>
                <div class="setting-item">
                    <span class="setting-label">파싱 모드:</span>
                    <span class="setting-value mode-${stats.mode}">
                        ${stats.mode === 'line-by-line' ? '📄 라인 단위' : '🔗 연속 데이터'}
                    </span>
                </div>
                <div class="setting-item">
                    <span class="setting-label">개행문자 인식:</span>
                    <span class="setting-value ${recognizeCRLF ? 'enabled' : 'disabled'}">
                        ${recognizeCRLF ? '✓ 활성' : '✗ 비활성'}
                    </span>
                </div>
                ${stats.mode === 'line-by-line' ? `
                <div class="setting-item">
                    <span class="setting-label">처리 라인:</span>
                    <span class="setting-value">${stats.recordCount}개 라인</span>
                </div>
                ` : ''}
            `;
            fragment.appendChild(settingsDiv);

            // 2. 통계 정보 표시
            if (stats) {
                const percent = stats.totalBytes > 0 
                    ? ((stats.parsedBytes / stats.totalBytes) * 100).toFixed(1) 
                    : 0;

                const statsDiv = document.createElement('div');
                statsDiv.className = 'parse-stats';

                statsDiv.innerHTML = `
                    <h3>📊 파싱 통계</h3>
                    <div class="stats-grid">
                        <div>전체: ${stats.totalBytes} bytes</div>
                        <div>파싱: ${stats.parsedBytes} bytes (${percent}%)</div>
                        <div>레코드: ${stats.recordCount}개</div>
                        <div>오류: ${stats.errorBytes} bytes</div>
                    </div>
                `;

                fragment.appendChild(statsDiv);
            }

            // 레코드가 없으면 메시지 표시
            if (records.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'error-message';
                noDataDiv.textContent = '⚠️ 파싱된 레코드가 없습니다.';
                fragment.appendChild(noDataDiv);
                container.appendChild(fragment);
                return;
            }

            /**
             * 3. 레코드별 그룹화 (recordIndex 기준)
             * 
             * [최적화된 그룹화 로직]
             * - 한 번의 순회로 레코드와 필드를 동시에 그룹화
             * - 에러 레코드는 즉시 DOM에 추가
             * - 정상 레코드는 Map에 필드 배열과 함께 저장
             */
            const recordMap = new Map();
            const errorCards = [];  // 에러 카드 별도 수집
            
            records.forEach(function(record) {
                // 에러 레코드 처리
                if (record.error) {
                    errorCards.push(record);
                    return;
                }
                
                // 정상 레코드: recordIndex로 그룹화, 필드 배열 수집
                const idx = record.recordIndex;
                if (!recordMap.has(idx)) {
                    // 레코드 초기화 (필드 배열 포함)
                    recordMap.set(idx, {
                        recordIndex: record.recordIndex,
                        lineNumber: record.lineNumber,
                        structName: record.structName,
                        kubun: record.kubun,
                        fields: []  // 필드 배열 초기화
                    });
                }
                
                // 필드 추가
                recordMap.get(idx).fields.push({
                    fieldName: record.fieldName,
                    fieldSize: record.fieldSize,
                    value: record.value,
                    startPos: record.startPos,
                    endPos: record.endPos
                });
            });
            
            // 에러 카드 먼저 표시 (순서 보장)
            errorCards.forEach(function(errorRecord) {
                const errorCard = document.createElement('div');
                errorCard.className = 'error-record-card';
                errorCard.innerHTML = `
                    <div class="error-header">
                        <span class="error-icon">⚠️</span>
                        <span class="error-title">라인 ${errorRecord.lineNumber} 파싱 실패</span>
                    </div>
                    <div class="error-body">
                        <p class="error-message">${errorRecord.message}</p>
                        <pre class="error-data">${escapeHtml(errorRecord.lineData)}</pre>
                        <div class="error-info">
                            <small>데이터 길이: ${errorRecord.lineData.length} bytes</small>
                        </div>
                    </div>
                `;
                fragment.appendChild(errorCard);
            });

            // 4. 각 레코드마다 테이블 생성
            recordMap.forEach(function(record, recordIndex) {
                // 그룹 컨테이너 생성
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';

                // 레코드 헤더 생성
                const headerDiv = document.createElement('div');
                headerDiv.className = 'record-header';

                // 제목: "레코드 #N - 구조체명"
                const title = document.createElement('h3');
                title.textContent = '레코드 #' + (recordIndex + 1) + ' - ' + record.structName;
                headerDiv.appendChild(title);

                // 구분값 배지
                const kubunBadge = document.createElement('span');
                kubunBadge.className = 'kubun-badge';
                kubunBadge.textContent = '구분: ' + (record.kubun || 'N/A');
                headerDiv.appendChild(kubunBadge);

                // 길이 검증 뱃지 추가
                const lengthBadgeHtml = createLengthBadge(record, structDefs, stats.mode);
                const lengthBadgeContainer = document.createElement('span');
                lengthBadgeContainer.innerHTML = lengthBadgeHtml;
                headerDiv.appendChild(lengthBadgeContainer.firstChild);

                // 복사 버튼
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.setAttribute('data-record', recordIndex);
                copyBtn.textContent = '📋 복사';
                headerDiv.appendChild(copyBtn);

                groupDiv.appendChild(headerDiv);

                // 테이블 생성
                const table = document.createElement('table');
                table.className = 'result-table';

                // thead 생성
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['필드명', '크기', '시작', '종료', '값'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody 생성
                const tbody = document.createElement('tbody');

                // 해당 레코드의 모든 필드를 행으로 추가
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field) {
                        const tr = document.createElement('tr');

                        /**
                         * 필드 값 표시 처리
                         * - CRLF 필드: 특수문자를 이스케이프하여 "\r\n" 형태로 표시
                         * - 일반 필드: 그대로 표시
                         */
                        const isCRLFField = field.fieldName && 
                            field.fieldName.toLowerCase().match(/crlf|cr_lf|newline/);
                        
                        // 값 포맷팅: 특수문자 이스케이프 (가시성 향상)
                        const formattedValue = formatFieldValue(field.value, isCRLFField);

                        const values = [
                            field.fieldName,   // 필드명
                            field.fieldSize,   // 크기
                            field.startPos,    // 시작
                            field.endPos,      // 종료
                            formattedValue     // 값 (포맷팅 적용)
                        ];

                        values.forEach(function(value, tdIndex) {
                            const td = document.createElement('td');
                            td.textContent = value;

                            // CRLF 필드에 특별 스타일 적용 (마지막 컬럼)
                            if (tdIndex === 4 && isCRLFField) {
                                td.classList.add('crlf-value');
                            }
                            
                            // value가 공백만 있으면 class="empty-value" 추가 (마지막 컬럼)
                            if (tdIndex === 4 && typeof value === 'string' && value.trim() === '') {
                                td.classList.add('empty-value');
                            }

                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                    });
                }

                table.appendChild(thead);
                table.appendChild(tbody);

                // 반응형 wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // fragment에 그룹 추가
                fragment.appendChild(groupDiv);
            });

            // 한 번에 DOM 업데이트
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * 신규 레코드 입력 폼 표시 함수 (33단계)
         * 구조체 필드 배열을 받아 입력 폼을 생성
         * CRLF 필드는 개행 인식 옵션에 따라 자동 처리
         * =====================================================
         * @param {Array} fields - 필드 배열 [{name, size}, ...]
         * @param {HTMLElement} container - 폼을 표시할 컨테이너 요소
         * @returns {HTMLElement} 생성된 테이블 요소
         */
        function showNewRecordForm(fields, container) {
            // 입력값 유효성 검사
            if (!Array.isArray(fields) || fields.length === 0) {
                console.error('showNewRecordForm: 유효하지 않은 필드 배열입니다.');
                return null;
            }
            
            if (!container || !(container instanceof HTMLElement)) {
                console.error('showNewRecordForm: 유효하지 않은 컨테이너입니다.');
                return null;
            }
            
            // 개행문자 인식 옵션 확인
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // 테이블 생성
            const table = document.createElement('table');
            table.className = 'result-table new-record-form';
            
            // thead 생성
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['필드명', '크기', '입력값', '미리보기'];
            
            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // tbody 생성
            const tbody = document.createElement('tbody');
            
            // 각 필드에 대해 행 생성
            fields.forEach(function(field) {
                const tr = document.createElement('tr');
                
                // CRLF 필드 여부 확인
                const isCRLFField = field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/);
                
                // 필드명 셀
                const tdName = document.createElement('td');
                tdName.textContent = field.name;
                tr.appendChild(tdName);
                
                // 크기 셀
                const tdSize = document.createElement('td');
                tdSize.textContent = field.size;
                tr.appendChild(tdSize);
                
                // 입력값 셀
                const tdInput = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                
                if (isCRLFField && recognizeCRLF) {
                    // CRLF 필드이고 개행 인식 활성화: 자동 설정
                    input.value = '\\r\\n';
                    input.disabled = true;
                    input.className = 'auto-field';
                    input.title = '자동 설정됨';
                } else {
                    // 일반 필드 또는 개행 인식 비활성화된 CRLF 필드: 수동 입력 가능
                    input.className = 'new-field-input';
                    input.setAttribute('data-field', field.name);
                    input.setAttribute('data-size', field.size);
                    input.maxLength = field.size;
                    
                    if (isCRLFField) {
                        input.placeholder = '예: CR+LF 또는 공백';
                    } else {
                        input.placeholder = field.name + ' 값 입력';
                    }
                    
                    // 입력값 변경 시 미리보기 업데이트
                    input.addEventListener('input', function() {
                        const previewCell = tr.querySelector('.preview-cell');
                        if (previewCell) {
                            previewCell.textContent = input.value || '';
                        }
                    });
                }
                
                tdInput.appendChild(input);
                tr.appendChild(tdInput);
                
                // 미리보기 셀
                const tdPreview = document.createElement('td');
                tdPreview.className = 'preview-cell';
                
                if (isCRLFField && recognizeCRLF) {
                    tdPreview.textContent = '\\r\\n';
                } else {
                    tdPreview.textContent = '';
                }
                
                tr.appendChild(tdPreview);
                tbody.appendChild(tr);
            });
            
            table.appendChild(tbody);
            
            // 컨테이너 비우고 테이블 추가
            container.innerHTML = '';
            container.appendChild(table);
            
            console.log('showNewRecordForm: ' + fields.length + '개 필드의 입력 폼이 생성되었습니다.');
            
            return table;
        }

        /**
         * =====================================================
         * 테스트 케이스 실행 함수
         * 다양한 입력 상황에 대한 자동화된 테스트
         * =====================================================
         * @returns {Object} 테스트 결과 객체 { passed, failed, results }
         */
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            /**
             * 개별 테스트 실행 헬퍼
             */
            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        passed++;
                        results.push({ name: name, passed: true });
                    } else {
                        failed++;
                        results.push({ name: name, passed: false, reason: result || '실패' });
                    }
                } catch (e) {
                    failed++;
                    results.push({ name: name, passed: false, reason: e.message });
                }
            }

            // =========================================
            // 테스트 케이스 1: 구조체 1개만 있는 경우
            // =========================================
            test('구조체 1개만 있는 경우', function() {
                const structDef = `typedef struct {
                    char field1[5];
                    char field2[10];
                } SingleStruct;`;
                
                const data = 'HELLO1234567890';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                
                const result = parseStructData(data, defs);
                if (result.records.length !== 1) return '레코드 파싱 실패';
                if (result.records[0].fields.length !== 2) return '필드 파싱 실패';
                if (result.records[0].fields[0].value !== 'HELLO') return '첫 번째 필드 값 불일치';
                if (result.records[0].fields[1].value !== '1234567890') return '두 번째 필드 값 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 2: 구조체 5개 이상인 경우
            // =========================================
            test('구조체 5개 이상인 경우', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Type_A;
                    typedef struct { char type[1]; char data[4]; } Type_B;
                    typedef struct { char type[1]; char data[4]; } Type_C;
                    typedef struct { char type[1]; char data[4]; } Type_D;
                    typedef struct { char type[1]; char data[4]; } Type_E;
                `;
                
                const data = 'AAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 5) return '구조체 개수 불일치: ' + (defs ? defs.length : 0);
                
                const result = parseStructData(data, defs);
                // 5줄 = 5개 레코드
                if (result.records.length !== 5) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                return true;
            });

            // =========================================
            // 테스트 케이스 3: 데이터 라인 100개 이상
            // =========================================
            test('데이터 라인 100개 이상', function() {
                const structDef = `typedef struct { char id[4]; char val[6]; } DataLine;`;
                
                // 100개 라인 생성
                let dataLines = [];
                for (let i = 0; i < 100; i++) {
                    const id = ('0000' + i).slice(-4);
                    dataLines.push(id + 'VALUE1');
                }
                const data = dataLines.join('\n');
                
                const defs = parseStructDefinitions(structDef);
                if (!defs) return '구조체 파싱 실패';
                
                const result = parseStructData(data, defs);
                // 100줄 = 100개 레코드
                if (result.records.length !== 100) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                // 첫 번째와 마지막 레코드 검증
                if (result.records[0].fields[0].value !== '0000') return '첫 레코드 첫 필드 불일치';
                if (result.records[99].fields[0].value !== '0099') return '마지막 레코드 첫 필드 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 4: 길이가 안 맞는 데이터
            // =========================================
            test('길이가 안 맞는 데이터 (짧음)', function() {
                const structDef = `typedef struct { char field1[10]; char field2[10]; } TestStruct;`;
                const data = 'SHORTDATA'; // 9자 (예상: 20자)
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // 파싱은 성공해야 함 (부족한 부분은 빈 문자열)
                if (result.records.length !== 1) return '레코드 파싱 실패';
                if (result.records[0].fields.length !== 2) return '필드 파싱 실패';
                if (result.records[0].fields[0].value !== 'SHORTDATA') return '첫 번째 필드 값 불일치';
                if (result.records[0].fields[1].value !== '') return '두 번째 필드가 빈 문자열이어야 함';
                
                return true;
            });

            test('길이가 안 맞는 데이터 (김)', function() {
                const structDef = `typedef struct { char field1[5]; } ShortStruct;`;
                const data = 'EXTRALONG_DATA_HERE'; // 예상보다 긴 데이터
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // 정의된 필드까지만 파싱
                if (result.records.length !== 1) return '레코드 파싱 개수 불일치';
                if (result.records[0].fields[0].value !== 'EXTRA') return '값 불일치: ' + result.records[0].fields[0].value;
                
                return true;
            });

            // =========================================
            // 테스트 케이스 5: 잘못된 구조체 문법
            // =========================================
            test('잘못된 구조체 문법 - typedef 누락', function() {
                const structDef = `struct { char field[5]; } BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // null을 반환해야 함
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('잘못된 구조체 문법 - 중괄호 누락', function() {
                const structDef = `typedef struct char field[5]; BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('잘못된 구조체 문법 - 세미콜론 누락', function() {
                const structDef = `typedef struct { char field[5]; } BadStruct`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return '잘못된 문법인데 파싱됨';
                
                return true;
            });

            test('빈 구조체 (필드 없음)', function() {
                const structDef = `typedef struct { } EmptyStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // 빈 구조체는 제외되므로 null 반환
                if (defs !== null) return '빈 구조체인데 파싱됨';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 6: 빈 입력
            // =========================================
            test('빈 입력 - 구조체 정의', function() {
                const defs = parseStructDefinitions('');
                if (defs !== null) return '빈 입력인데 파싱됨';
                return true;
            });

            test('빈 입력 - 데이터', function() {
                const structDef = `typedef struct { char field[5]; } TestStruct;`;
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData('', defs);
                
                if (result.records.length !== 0) return '빈 데이터인데 결과 있음';
                return true;
            });

            test('공백만 있는 입력', function() {
                const defs = parseStructDefinitions('   \n\t\n   ');
                if (defs !== null) return '공백만 있는데 파싱됨';
                return true;
            });

            // =========================================
            // 테스트 케이스 7: 주석 처리
            // =========================================
            test('한줄 주석 처리', function() {
                const structDef = `typedef struct {
                    // 이것은 주석입니다
                    char field1[5]; // 필드 설명
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                if (defs[0].fields.length !== 2) return '필드 개수 불일치';
                
                return true;
            });

            test('블록 주석 처리', function() {
                const structDef = `typedef struct {
                    /* 블록 주석
                       여러 줄 */
                    char field1[5];
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return '구조체 파싱 실패';
                if (defs[0].fields.length !== 2) return '필드 개수 불일치';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 8: 구조체 매칭 로직
            // =========================================
            test('구조체 매칭 - 첫 글자 기준', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Record_H;
                    typedef struct { char type[1]; char data[9]; } Record_D;
                `;
                
                const data = 'H1234\nD123456789';
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // H 라인: 1레코드, D 라인: 1레코드 = 2개 레코드
                if (result.records.length !== 2) return '레코드 파싱 개수 불일치: ' + result.records.length;
                
                // 첫 라인은 Record_H
                if (result.records[0].structName !== 'Record_H') return '첫 라인 구조체 매칭 실패';
                // 두 번째 라인은 Record_D
                if (result.records[1].structName !== 'Record_D') return '두 번째 라인 구조체 매칭 실패';
                
                return true;
            });

            // =========================================
            // 테스트 케이스 9: XML 파싱
            // =========================================
            test('XML 파싱 - 정상', function() {
                const xml = `<packet>
                    <col id="field1" type="X" size="5" />
                    <col id="field2" type="N" size="10" />
                </packet>`;
                
                const spec = parseXMLSpec(xml);
                if (!spec || spec.length !== 2) return 'XML 파싱 실패';
                if (spec[0].id !== 'field1') return '첫 번째 필드 ID 불일치';
                if (spec[1].size !== 10) return '두 번째 필드 크기 불일치';
                
                return true;
            });

            test('XML 파싱 - 빈 입력', function() {
                const spec = parseXMLSpec('');
                if (spec !== null) return '빈 입력인데 파싱됨';
                return true;
            });

            test('XML 파싱 - 잘못된 형식', function() {
                const spec = parseXMLSpec('<invalid><unclosed>');
                if (spec !== null) return '잘못된 XML인데 파싱됨';
                return true;
            });

            // =========================================
            // 테스트 케이스 10: 통전문 파싱
            // =========================================
            test('통전문 파싱 - 정상', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="3" />
                    <col id="name" type="X" size="5" />
                </packet>`;
                const telegram = 'ABCHELLO';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return '필드 개수 불일치';
                if (parsed[0].value !== 'ABC') return '첫 번째 값 불일치';
                if (parsed[1].value !== 'HELLO') return '두 번째 값 불일치';
                
                return true;
            });

            return { passed: passed, failed: failed, results: results };
        }

        /**
         * =====================================================
         * 테스트 결과 표시 함수
         * 테스트 결과를 UI에 표시
         * =====================================================
         * @param {Object} testResult - runTests()의 반환값
         */
        function displayTestResults(testResult) {
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            const div = document.createElement('div');
            div.className = 'test-results ' + (testResult.failed === 0 ? 'success' : 'failure');

            const title = document.createElement('h3');
            title.textContent = '테스트 결과: ' + testResult.passed + '개 통과, ' + testResult.failed + '개 실패';
            div.appendChild(title);

            testResult.results.forEach(function(result) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                if (result.passed) {
                    item.innerHTML = '<span class="test-pass">✓</span> ' + result.name;
                } else {
                    item.innerHTML = '<span class="test-fail">✗</span> ' + result.name + 
                                   ' <small>(' + result.reason + ')</small>';
                }
                
                div.appendChild(item);
            });

            container.appendChild(div);
        }

        // =========================================
        // DOMContentLoaded 이벤트 - 이벤트 리스너 등록
        // =========================================
        document.addEventListener('DOMContentLoaded', function() {
            // =========================================
            // 서브 탭 (파싱/생성 모드) 전환 이벤트
            // =========================================
            document.querySelectorAll('.sub-tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    
                    // 모든 버튼 비활성화
                    document.querySelectorAll('.sub-tab-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    
                    // 클릭된 버튼 활성화
                    this.classList.add('active');
                    
                    // 모든 컨텐츠 숨김
                    document.querySelectorAll('.sub-mode-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 선택된 모드 컨텐츠 표시
                    const selectedContent = document.getElementById(`${mode}-mode-content`);
                    selectedContent.classList.add('active');
                    
                    // 결과 영역 초기화
                    document.getElementById('struct-result-container').innerHTML = '';
                    
                    console.log(`모드 전환: ${mode}`);
                });
            });

            // =========================================
            // 구조체 카드 초기화 - 첫 번째 카드 자동 추가
            // =========================================
            const structContainer = document.getElementById('struct-definitions-container');
            structContainer.appendChild(createStructCard(0));
            structCardIndex = 1;

            // =========================================
            // 구조체 추가 버튼 클릭 이벤트
            // =========================================
            document.getElementById('add-struct-btn').addEventListener('click', function() {
                const newCard = createStructCard(structCardIndex);
                structContainer.appendChild(newCard);
                structCardIndex++;
            });

            // =========================================
            // 구조체 삭제 버튼 이벤트 위임
            // =========================================
            structContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-struct-btn')) {
                    // 클릭된 버튼의 부모 .struct-card 찾기
                    const card = e.target.closest('.struct-card');
                    if (!card) return;

                    // 확인 대화상자
                    if (confirm('이 구조체를 삭제하시겠습니까?')) {
                        // 해당 카드 제거
                        card.remove();

                        // 남은 카드가 0개면 structCardIndex를 0으로 리셋
                        const remainingCards = structContainer.querySelectorAll('.struct-card');
                        if (remainingCards.length === 0) {
                            structCardIndex = 0;
                        }
                    }
                }
            });

            // =========================================
            // 미리보기 복사 버튼 이벤트 위임
            // =========================================
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('copy-preview-btn')) {
                    const telegram = e.target.dataset.telegram;
                    // HTML 엔티티 디코딩
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = telegram;
                    const decodedTelegram = textarea.value;
                    
                    navigator.clipboard.writeText(decodedTelegram).then(function() {
                        e.target.textContent = '✓ 복사됨';
                        setTimeout(function() {
                            e.target.textContent = '📋 복사';
                        }, 2000);
                    }).catch(function(err) {
                        console.error('복사 실패:', err);
                        // 폴백: 수동 복사 안내
                        alert('자동 복사에 실패했습니다. 텍스트를 직접 선택하여 복사해주세요.');
                    });
                }
            });

            // 도움말 토글 이벤트
            const helpToggle = document.querySelector('.help-toggle');
            const helpContent = document.querySelector('.help-content');
            
            if (helpToggle && helpContent) {
                helpToggle.addEventListener('click', function() {
                    helpToggle.classList.toggle('expanded');
                    helpContent.classList.toggle('expanded');
                });
            }

            // 탭 전환 이벤트
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // 모든 탭 버튼에서 active 제거
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // 클릭된 버튼에 active 추가
                    this.classList.add('active');

                    // 모든 탭 콘텐츠 숨기기
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // 선택된 탭 콘텐츠 표시
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // 샘플 로드 버튼 클릭 이벤트
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML 규격 샘플 설정
                const sampleXml = `<packet id="송금전문" default=" ">
  <col id="헤더시작" type="X" size="6" />
  <col id="거래구분" type="X" size="2" />
  <col id="계좌번호" type="N" size="12" />
  <col id="송금액" type="N" size="15" />
  <col id="받는사람" type="X" size="20" />
</packet>`;
                
                // 통전문 샘플 설정 (정확히 55자)
                const sampleTelegram = 'HEADER01123456789012000000000100000홍길동              ';
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // 파싱 실행 버튼 클릭 이벤트
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-input과 telegram-input 값 가져오기
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. 둘 다 trim()해서 빈 문자열이면 에러 표시 후 return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("입력값을 확인하세요", 'result-container');
                    return;
                }

                // 3. parseXMLSpec 호출, 결과가 null이면 에러 표시 후 return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML 파싱 실패: 형식을 확인하세요", 'result-container');
                    return;
                }

                // 4. parseTelegram 호출
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults 호출
                displayResults(parsedData);
            });

            // 초기화 버튼 클릭 이벤트
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // 구조체 샘플 로드 버튼 클릭 이벤트
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // 1. recognize-crlf 체크박스 자동 체크
                document.getElementById('recognize-crlf').checked = true;
                
                // 2. 기존 모든 구조체 카드 삭제
                structContainer.innerHTML = '';
                
                // 3. structCardIndex = 0 리셋
                structCardIndex = 0;

                // 4. 구조체 3개 추가
                const sampleStructs = [
                    {
                        // 카드 1: DHF_H
                        name: 'DHF_H',
                        kubun: 'H',
                        definition: `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
  char crlf[2];
} DHF_H;`
                    },
                    {
                        // 카드 2: DHF_D
                        name: 'DHF_D',
                        kubun: 'D',
                        definition: `typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
  char crlf[2];
} DHF_D;`
                    },
                    {
                        // 카드 3: DHF_T
                        name: 'DHF_T',
                        kubun: 'T',
                        definition: `typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
  char crlf[2];
} DHF_T;`
                    }
                ];

                // 각 샘플 구조체마다 카드 생성
                sampleStructs.forEach(function(sample) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);
                    
                    // 카드 내부 입력 필드에 값 설정
                    card.querySelector('.struct-name').value = sample.name;
                    card.querySelector('.struct-kubun').value = sample.kubun;
                    card.querySelector('.struct-definition').value = sample.definition;
                    
                    structCardIndex++;
                });

                // 5. 데이터 설정
                // DHF_H: 1+2+7+2 = 12 bytes (데이터 10 + CRLF 2)
                // DHF_D: 1+16+20+2 = 39 bytes (데이터 37 + CRLF 2)
                // DHF_T: 1+10+20+2 = 33 bytes (데이터 31 + CRLF 2)
                // 일반적인 줄바꿈으로 입력, 각 줄에 \r\n 자동 추가됨
                const sampleData = `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`;

                document.getElementById('struct-data').value = sampleData;
                
                // 6. 완료 메시지 표시
                alert('✓ 샘플 로드 완료\n\n개행문자 인식이 활성화되었습니다.\n각 레코드 끝에 자동으로 CRLF가 추가됩니다.');
            });

            /**
             * =====================================================
             * 테스트 케이스 정의
             * =====================================================
             * 
             * [개행 인식 ON 모드 테스트]
             * - normal: 정상 데이터 - 각 라인이 올바른 길이
             * - short: 길이 부족 - 라인 길이가 구조체 정의보다 짧음
             * - long: 길이 초과 - 라인 길이가 구조체 정의보다 김
             * - mismatch: 매칭 실패 - 구분값에 해당하는 구조체 없음
             * - mixed: 혼합 - 다양한 에러 상황 조합
             * 
             * [개행 인식 OFF 모드 테스트]
             * - continuous: 연속 데이터 - 개행 없이 연속된 레코드
             * - continuous_multi: 연속 다중 - 여러 타입 연속 레코드
             * 
             * 테스트 시 주의사항:
             * - 개행 인식 ON: 각 줄 끝에 CRLF(2 bytes) 자동 추가
             * - 개행 인식 OFF: 모든 줄바꿈 제거 후 연속 파싱
             */
            const testCases = {
                // ========== 개행 인식 ON 테스트 케이스 ==========
                normal: {
                    name: '정상 데이터 (개행 ON)',
                    description: '각 라인 독립 파싱, CRLF 필드 정확히 표시, 길이 뱃지 녹색',
                    mode: 'line-by-line',
                    data: `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`
                },
                short: {
                    name: '길이 부족 (개행 ON)',
                    description: '경고 표시, 다음 라인 침범 안 함, 에러 카드 표시',
                    mode: 'line-by-line',
                    data: `H88123
D12345678901234560000000000000000100
T00000000020000000000000000300`
                },
                long: {
                    name: '길이 초과 (개행 ON)',
                    description: '길이 초과 경고 표시',
                    mode: 'line-by-line',
                    data: `H88123456789999
D123456789012345600000000000000001000`
                },
                mismatch: {
                    name: '매칭 실패 (개행 ON)',
                    description: '에러 카드로 표시, 다음 라인 정상 파싱',
                    mode: 'line-by-line',
                    data: `X1234567890
D123456789012345600000000000000001000`
                },
                mixed: {
                    name: '혼합 테스트 (개행 ON)',
                    description: '정상/부족/초과/매칭실패 혼합',
                    mode: 'line-by-line',
                    data: `H881234567
D123456789012345600000000000000001000
X9999999999
D12345
H88123456789999
T000000000200000000000000003000`
                },
                
                // ========== 개행 인식 OFF 테스트 케이스 ==========
                continuous: {
                    name: '연속 데이터 (개행 OFF)',
                    description: '구분값으로 자동 분리, 줄바꿈 완전 무시',
                    mode: 'continuous',
                    data: `H881234567D123456789012345600000000000000001000D987654321098765400000000000000002000T000000000200000000000000003000`
                },
                continuous_multi: {
                    name: '연속 다중 레코드 (개행 OFF)',
                    description: 'H-D-D-T 순서 연속, 여러 레코드 파싱',
                    mode: 'continuous',
                    data: `H881234567D123456789012345600000000000000001000T0000000001000000000000000010H991234567D987654321098765400000000000000002000T0000000001000000000000000020`
                }
            };

            // 테스트 케이스 모달 관련 요소
            const testModal = document.getElementById('test-case-modal');
            const testBtn = document.getElementById('struct-test-btn');
            const closeTestBtn = testModal.querySelector('.close-test');
            const testButtons = testModal.querySelectorAll('.test-buttons button');

            // 테스트 케이스 버튼 클릭 시 모달 표시
            testBtn.addEventListener('click', function() {
                testModal.classList.add('show');
            });

            // 닫기 버튼 클릭 시 모달 닫기
            closeTestBtn.addEventListener('click', function() {
                testModal.classList.remove('show');
            });

            // 모달 배경 클릭 시 닫기
            testModal.addEventListener('click', function(e) {
                if (e.target === testModal) {
                    testModal.classList.remove('show');
                }
            });

            /**
             * 테스트 케이스 버튼 클릭 이벤트 핸들러
             * - 테스트 케이스 mode에 따라 개행 인식 옵션 자동 설정
             * - line-by-line: 개행 인식 ON (각 줄 독립 파싱)
             * - continuous: 개행 인식 OFF (연속 데이터 파싱)
             */
            testButtons.forEach(function(button) {
                button.addEventListener('click', function() {
                    const caseType = this.getAttribute('data-case');
                    const testCase = testCases[caseType];
                    
                    if (!testCase) return;

                    // 1. 테스트 케이스 모드에 따라 개행 인식 체크박스 설정
                    // line-by-line 모드 = 개행 인식 ON
                    // continuous 모드 = 개행 인식 OFF
                    const isLineByLineMode = testCase.mode === 'line-by-line';
                    document.getElementById('recognize-crlf').checked = isLineByLineMode;
                    
                    // 2. 기존 모든 구조체 카드 삭제
                    structContainer.innerHTML = '';
                    
                    // 3. structCardIndex = 0 리셋
                    structCardIndex = 0;

                    // 4. 구조체 정의 설정
                    // 개행 인식 ON: CRLF 필드 포함
                    // 개행 인식 OFF: CRLF 필드 제외 (연속 데이터이므로)
                    const sampleStructs = isLineByLineMode 
                        ? [
                            // === 개행 인식 ON용 구조체 (CRLF 필드 포함) ===
                            {
                                name: 'DHF_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'H'
  char bank_cd[2];       // 은행 코드
  char cust_id[7];       // 고객 ID
  char crlf[2];          // 개행문자 (CRLF)
} DHF_H;`
                            },
                            {
                                name: 'DHF_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'D'
  char acno[16];         // 계좌번호
  char amt[20];          // 금액
  char crlf[2];          // 개행문자 (CRLF)
} DHF_D;`
                            },
                            {
                                name: 'DHF_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'T'
  char tot_cnt[10];      // 총 건수
  char tot_amt[20];      // 총 금액
  char crlf[2];          // 개행문자 (CRLF)
} DHF_T;`
                            }
                        ]
                        : [
                            // === 개행 인식 OFF용 구조체 (CRLF 필드 제외) ===
                            {
                                name: 'DHF_H',
                                kubun: 'H',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'H'
  char bank_cd[2];       // 은행 코드
  char cust_id[7];       // 고객 ID
} DHF_H;  // 총 10 bytes (개행 없음)`
                            },
                            {
                                name: 'DHF_D',
                                kubun: 'D',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'D'
  char acno[16];         // 계좌번호
  char amt[20];          // 금액
} DHF_D;  // 총 37 bytes (개행 없음)`
                            },
                            {
                                name: 'DHF_T',
                                kubun: 'T',
                                definition: `typedef struct{
  char record_kubun[1];  // 레코드 구분값 'T'
  char tot_cnt[10];      // 총 건수
  char tot_amt[20];      // 총 금액
} DHF_T;  // 총 31 bytes (개행 없음)`
                            }
                        ];

                    // 각 샘플 구조체마다 카드 생성
                    sampleStructs.forEach(function(sample) {
                        const card = createStructCard(structCardIndex);
                        structContainer.appendChild(card);
                        
                        card.querySelector('.struct-name').value = sample.name;
                        card.querySelector('.struct-kubun').value = sample.kubun;
                        card.querySelector('.struct-definition').value = sample.definition;
                        
                        structCardIndex++;
                    });

                    // 5. 테스트 데이터 설정
                    document.getElementById('struct-data').value = testCase.data;
                    
                    // 6. 모달 닫기
                    testModal.classList.remove('show');
                    
                    // 7. 완료 메시지 표시 (모드 정보 포함)
                    const modeInfo = isLineByLineMode 
                        ? '개행문자 인식이 활성화되었습니다.\n각 레코드 끝에 CRLF(2 bytes)가 있습니다.'
                        : '개행문자 인식이 비활성화되었습니다.\n연속 데이터로 파싱됩니다.';
                    
                    alert('✓ 테스트 케이스 로드 완료\n\n' +
                          '테스트: ' + testCase.name + '\n' +
                          '설명: ' + (testCase.description || '') + '\n\n' +
                          modeInfo);
                });
            });

            // ESC 키로 테스트 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && testModal.classList.contains('show')) {
                    testModal.classList.remove('show');
                }
            });

            // 구조체 파싱 실행 버튼 클릭 이벤트
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                // 1. collectStructDefinitions() 호출
                const structDefs = collectStructDefinitions();
                
                // null이면 중단 (에러는 함수 내부에서 표시)
                if (structDefs === null) {
                    return;
                }

                // 2. struct-data 값 가져오기, trim
                const data = document.getElementById('struct-data').value.trim();
                
                // 비어있으면 displayError("데이터를 입력하세요")
                if (data === '') {
                    displayError('데이터를 입력하세요', 'struct-result-container');
                    return;
                }

                // 3. parseStructData(data, structDefs) 호출
                const result = parseStructData(data, structDefs);
                
                // structDefs를 result에 추가
                result.structDefs = structDefs;

                // 4. displayStructResults(result) 호출
                displayStructResults(result);

                // 5. 성공 시 콘솔에 로그
                const count = result.stats.recordCount;
                const percent = result.stats.totalBytes > 0 
                    ? ((result.stats.parsedBytes / result.stats.totalBytes) * 100).toFixed(1)
                    : 0;
                console.log('파싱 완료: 레코드 ' + count + '개, 성공률 ' + percent + '%');
            });

            // 구조체 초기화 버튼 클릭 이벤트
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                // 확인 대화상자
                if (!confirm('모든 입력을 초기화하시겠습니까?')) {
                    return;
                }
                
                // 1. struct-definitions-container innerHTML = ''
                structContainer.innerHTML = '';
                
                // 2. struct-data value = ''
                document.getElementById('struct-data').value = '';
                
                // 3. struct-result-container innerHTML = ''
                document.getElementById('struct-result-container').innerHTML = '';
                
                // 4. structCardIndex = 0
                structCardIndex = 0;
                
                // 5. 첫 번째 빈 카드 자동 추가
                structContainer.appendChild(createStructCard(structCardIndex));
                structCardIndex++;
            });

            // 테스트 실행 버튼 클릭 이벤트 (버튼이 존재할 경우에만)
            const runTestsBtn = document.getElementById('run-tests-btn');
            if (runTestsBtn) {
                runTestsBtn.addEventListener('click', function() {
                    const testResult = runTests();
                    displayTestResults(testResult);
                });
            }

            // 복사 버튼 클릭 이벤트 (이벤트 위임 사용)
            document.getElementById('struct-result-container').addEventListener('click', function(e) {
                // 클릭된 요소가 복사 버튼인지 확인
                if (!e.target.classList.contains('copy-record-btn')) {
                    return;
                }

                const btn = e.target;

                // 1. data-record 속성에서 recordIndex 가져오기
                const recordIndex = btn.getAttribute('data-record');

                // 해당 레코드의 그룹 찾기
                const groupDiv = btn.closest('.struct-result-group');
                if (!groupDiv) {
                    return;
                }

                // 테이블의 tbody에서 모든 행 가져오기
                const tbody = groupDiv.querySelector('tbody');
                if (!tbody) {
                    return;
                }

                const rows = tbody.querySelectorAll('tr');
                
                // 2. TSV 형식으로 변환 (필드명\t크기\t값)
                const tsvLines = [];
                rows.forEach(function(row) {
                    const cells = row.querySelectorAll('td');
                    // 5개 컬럼: 필드명, 크기, 시작, 종료, 값
                    if (cells.length >= 5) {
                        const fieldName = cells[0].textContent;  // 필드명
                        const size = cells[1].textContent;       // 크기
                        const value = cells[4].textContent;      // 값
                        tsvLines.push(fieldName + '\t' + size + '\t' + value);
                    }
                });

                const tsvText = tsvLines.join('\n');

                // 3. 클립보드에 복사
                navigator.clipboard.writeText(tsvText).then(function() {
                    // 4. 복사 성공 시:
                    // - 버튼 텍스트 → "✓ 복사됨"
                    const originalText = btn.textContent;
                    const originalBg = btn.style.backgroundColor;
                    
                    btn.textContent = '✓ 복사됨';
                    // - 배경색 임시 변경
                    btn.style.backgroundColor = '#17a2b8';
                    
                    // - 2초 후 원래대로
                    setTimeout(function() {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = originalBg;
                    }, 2000);
                }).catch(function(err) {
                    console.error('클립보드 복사 실패:', err);
                    alert('복사에 실패했습니다.');
                });
            });

            // =========================================
            // 구조체 카드 접기/펼치기 이벤트
            // - 헤더 클릭 시 본문 토글
            // - 아이콘 변경 (▼ ↔ ▶)
            // =========================================
            structContainer.addEventListener('click', function(e) {
                // 삭제 버튼이나 드래그 핸들 클릭 시 무시
                if (e.target.classList.contains('remove-struct-btn') || 
                    e.target.classList.contains('drag-handle')) {
                    return;
                }

                // 헤더 영역 클릭 확인
                const header = e.target.closest('.struct-card-header');
                if (!header) return;

                const card = header.closest('.struct-card');
                if (!card) return;

                // collapsed 클래스 토글
                card.classList.toggle('collapsed');

                // 접힌 상태에서 구조체명 미리보기 업데이트
                updateStructPreview(card);
            });

            /**
             * 구조체 미리보기 텍스트 업데이트
             * @param {HTMLElement} card - 구조체 카드 요소
             */
            function updateStructPreview(card) {
                const preview = card.querySelector('.struct-preview');
                const nameInput = card.querySelector('.struct-name');
                const kubunInput = card.querySelector('.struct-kubun');

                if (card.classList.contains('collapsed') && preview) {
                    const name = nameInput ? nameInput.value.trim() : '';
                    const kubun = kubunInput ? kubunInput.value.trim() : '';
                    
                    let previewText = '';
                    if (name) previewText += name;
                    if (kubun) previewText += (name ? ' ' : '') + '[' + kubun + ']';
                    
                    preview.textContent = previewText ? '- ' + previewText : '';
                } else if (preview) {
                    preview.textContent = '';
                }
            }

            // 입력값 변경 시 미리보기 업데이트
            structContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('struct-name') || 
                    e.target.classList.contains('struct-kubun')) {
                    const card = e.target.closest('.struct-card');
                    if (card) updateStructPreview(card);
                }
            });

            // =========================================
            // 드래그 앤 드롭 재정렬 기능
            // HTML5 Drag API 사용
            // =========================================
            let draggedCard = null;

            // 드래그 시작
            structContainer.addEventListener('dragstart', function(e) {
                const card = e.target.closest('.struct-card');
                if (!card) return;

                draggedCard = card;
                card.classList.add('dragging');

                // 드래그 이미지 설정 (선택사항)
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', card.getAttribute('data-index'));
            });

            // 드래그 종료
            structContainer.addEventListener('dragend', function(e) {
                const card = e.target.closest('.struct-card');
                if (card) {
                    card.classList.remove('dragging');
                }
                draggedCard = null;

                // 모든 drag-over 클래스 제거
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });

                // 카드 인덱스 재정렬
                renumberStructCards();
            });

            // 드래그 오버
            structContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                const card = e.target.closest('.struct-card');
                if (!card || card === draggedCard) return;

                // drag-over 클래스 추가
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });
                card.classList.add('drag-over');
            });

            // 드롭
            structContainer.addEventListener('drop', function(e) {
                e.preventDefault();

                const targetCard = e.target.closest('.struct-card');
                if (!targetCard || !draggedCard || targetCard === draggedCard) return;

                // 드래그한 카드를 타겟 위치로 이동
                const cards = Array.from(structContainer.querySelectorAll('.struct-card'));
                const draggedIndex = cards.indexOf(draggedCard);
                const targetIndex = cards.indexOf(targetCard);

                if (draggedIndex < targetIndex) {
                    // 아래로 이동
                    targetCard.parentNode.insertBefore(draggedCard, targetCard.nextSibling);
                } else {
                    // 위로 이동
                    targetCard.parentNode.insertBefore(draggedCard, targetCard);
                }

                targetCard.classList.remove('drag-over');
            });

            /**
             * 구조체 카드 번호 재정렬
             */
            function renumberStructCards() {
                const cards = structContainer.querySelectorAll('.struct-card');
                cards.forEach(function(card, index) {
                    const numberSpan = card.querySelector('.struct-number');
                    if (numberSpan) {
                        numberSpan.textContent = '구조체 #' + (index + 1);
                    }
                    card.setAttribute('data-index', index);
                });
            }

            // =========================================
            // 로컬 스토리지 저장/복원 기능
            // - 페이지 떠날 때 자동 저장
            // - 재방문 시 복원 제안
            // =========================================
            const STORAGE_KEY = 'structParserData';

            /**
             * 현재 구조체 정의들을 로컬 스토리지에 저장
             */
            function saveToLocalStorage() {
                const cards = structContainer.querySelectorAll('.struct-card');
                const data = [];

                cards.forEach(function(card) {
                    const name = card.querySelector('.struct-name').value;
                    const kubun = card.querySelector('.struct-kubun').value;
                    const definition = card.querySelector('.struct-definition').value;
                    const collapsed = card.classList.contains('collapsed');

                    // 하나라도 입력된 카드만 저장
                    if (name || kubun || definition) {
                        data.push({
                            name: name,
                            kubun: kubun,
                            definition: definition,
                            collapsed: collapsed
                        });
                    }
                });

                // 데이터가 있을 때만 저장
                if (data.length > 0) {
                    const saveData = {
                        structs: data,
                        structData: document.getElementById('struct-data').value,
                        savedAt: new Date().toISOString()
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
                    console.log('로컬 스토리지에 저장됨:', data.length + '개 구조체');
                }
            }

            /**
             * 로컬 스토리지에서 복원
             */
            function restoreFromLocalStorage() {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (!savedData) return;

                try {
                    const data = JSON.parse(savedData);
                    if (!data.structs || data.structs.length === 0) return;

                    // 저장 시간 표시
                    const savedAt = new Date(data.savedAt);
                    const timeStr = savedAt.toLocaleString('ko-KR');

                    // 복원 알림 표시
                    showRestoreNotification(data, timeStr);
                } catch (e) {
                    console.error('로컬 스토리지 데이터 파싱 실패:', e);
                }
            }

            /**
             * 복원 알림 UI 표시
             */
            function showRestoreNotification(data, timeStr) {
                // 기존 알림 제거
                const existingNotif = document.querySelector('.restore-notification');
                if (existingNotif) existingNotif.remove();

                const notification = document.createElement('div');
                notification.className = 'restore-notification';
                notification.innerHTML = `
                    <span class="restore-notification-text">
                        📁 이전 작업을 복원할 수 있습니다 (${timeStr}, ${data.structs.length}개 구조체)
                    </span>
                    <div class="restore-notification-actions">
                        <button class="restore-btn primary" id="restore-yes">복원</button>
                        <button class="restore-btn secondary" id="restore-no">무시</button>
                    </div>
                `;

                // struct-input-section 앞에 삽입
                const inputSection = document.getElementById('struct-input-section');
                inputSection.parentNode.insertBefore(notification, inputSection);

                // 복원 버튼 이벤트
                document.getElementById('restore-yes').addEventListener('click', function() {
                    doRestore(data);
                    notification.remove();
                });

                // 무시 버튼 이벤트
                document.getElementById('restore-no').addEventListener('click', function() {
                    notification.remove();
                    localStorage.removeItem(STORAGE_KEY); // 저장된 데이터 삭제
                });
            }

            /**
             * 실제 복원 수행
             */
            function doRestore(data) {
                // 기존 카드 삭제
                structContainer.innerHTML = '';
                structCardIndex = 0;

                // 저장된 구조체 복원
                data.structs.forEach(function(struct) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);

                    card.querySelector('.struct-name').value = struct.name || '';
                    card.querySelector('.struct-kubun').value = struct.kubun || '';
                    card.querySelector('.struct-definition').value = struct.definition || '';

                    if (struct.collapsed) {
                        card.classList.add('collapsed');
                        updateStructPreview(card);
                    }

                    structCardIndex++;
                });

                // 데이터 복원
                if (data.structData) {
                    document.getElementById('struct-data').value = data.structData;
                }

                console.log('로컬 스토리지에서 복원됨:', data.structs.length + '개 구조체');
            }

            // 페이지 떠날 때 자동 저장
            window.addEventListener('beforeunload', function() {
                saveToLocalStorage();
            });

            // 페이지 로드 시 복원 제안 표시
            // 구조체 탭이 활성화될 때까지 대기
            setTimeout(function() {
                restoreFromLocalStorage();
            }, 100);

            // =========================================
            // 다크모드 토글 기능
            // - localStorage에 테마 설정 저장
            // =========================================
            const THEME_KEY = 'structParserTheme';
            const themeToggle = document.getElementById('theme-toggle');

            /**
             * 테마 초기화
             */
            function initTheme() {
                const savedTheme = localStorage.getItem(THEME_KEY);
                if (savedTheme === 'dark') {
                    document.body.classList.add('dark-mode');
                    themeToggle.textContent = '☀️';
                } else {
                    themeToggle.textContent = '🌙';
                }
            }

            /**
             * 테마 토글
             */
            function toggleTheme() {
                const isDark = document.body.classList.toggle('dark-mode');
                localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
                themeToggle.textContent = isDark ? '☀️' : '🌙';
            }

            // 테마 초기화
            initTheme();

            // 테마 토글 버튼 클릭 이벤트
            themeToggle.addEventListener('click', toggleTheme);

            // =========================================
            // 키보드 단축키
            // - Ctrl+Enter: 파싱 실행
            // - Ctrl+N: 구조체 추가
            // =========================================
            document.addEventListener('keydown', function(e) {
                // Ctrl+Enter: 파싱 실행
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    
                    // 현재 활성화된 탭 확인
                    const xmlTabActive = document.getElementById('xml-tab').classList.contains('active');
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');

                    if (xmlTabActive) {
                        document.getElementById('parse-btn').click();
                    } else if (structTabActive) {
                        document.getElementById('struct-parse-btn').click();
                    }
                }

                // Ctrl+N: 구조체 추가 (struct 탭에서만)
                if (e.ctrlKey && e.key === 'n') {
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');
                    if (structTabActive) {
                        e.preventDefault();
                        document.getElementById('add-struct-btn').click();
                    }
                }
            });

            /**
             * =====================================================
             * 개행문자 인식 (CRLF) 체크박스 변경 이벤트
             * =====================================================
             * 
             * [옵션 전환 동작]
             * - 체크(ON): 라인 기반 파싱 모드
             *   → 각 줄을 독립 레코드로 처리
             *   → CRLF(2 bytes)가 레코드 끝에 자동 추가
             * 
             * - 해제(OFF): 연속 데이터 파싱 모드
             *   → 모든 줄바꿈 제거 후 연속 파싱
             *   → 구분값 기반 레코드 분리
             * 
             * [사용자 확인]
             * - 기존 데이터/결과가 있으면 재파싱 확인
             * - 취소 시 체크 상태 롤백
             */
            document.getElementById('recognize-crlf').addEventListener('change', function(e) {
                const isChecked = e.target.checked;
                const hasData = document.getElementById('struct-data').value.trim().length > 0;
                const hasResults = document.getElementById('struct-result-container').children.length > 0;

                if (hasData || hasResults) {
                    const confirmed = confirm(
                        '옵션을 변경하면 기존 파싱 결과가 영향을 받을 수 있습니다.\n' +
                        '다시 파싱하시겠습니까?'
                    );

                    if (confirmed) {
                        // 결과 초기화
                        document.getElementById('struct-result-container').innerHTML = '';

                        // 알림
                        const msg = isChecked
                            ? '개행문자 인식이 활성화되었습니다. 각 레코드 끝에 CRLF(2 bytes)가 추가됩니다.'
                            : '개행문자 인식이 비활성화되었습니다. 모든 줄바꿈이 제거됩니다.';

                        // 임시 메시지 표시
                        showTemporaryMessage(msg);
                    } else {
                        // 변경 취소
                        e.target.checked = !isChecked;
                    }
                }
            });

            /**
             * 임시 메시지 표시 함수
             * @param {string} message - 표시할 메시지
             */
            function showTemporaryMessage(message) {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'temporary-message';
                msgDiv.textContent = message;
                document.body.appendChild(msgDiv);

                setTimeout(function() {
                    msgDiv.classList.add('fade-out');
                    setTimeout(function() {
                        msgDiv.remove();
                    }, 300);
                }, 3000);
            }

            // =========================================
            // 도움말 모달 이벤트 핸들러
            // =========================================
            const crlfHelpBtn = document.getElementById('crlf-help');
            const crlfHelpModal = document.getElementById('crlf-help-modal');
            const closeHelpBtn = crlfHelpModal.querySelector('.close-help');

            // 도움말 아이콘 클릭 시 모달 표시
            crlfHelpBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                crlfHelpModal.classList.add('show');
            });

            // 닫기 버튼 클릭 시 모달 닫기
            closeHelpBtn.addEventListener('click', function() {
                crlfHelpModal.classList.remove('show');
            });

            // 모달 배경 클릭 시 닫기
            crlfHelpModal.addEventListener('click', function(e) {
                if (e.target === crlfHelpModal) {
                    crlfHelpModal.classList.remove('show');
                }
            });

            // ESC 키로 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && crlfHelpModal.classList.contains('show')) {
                    crlfHelpModal.classList.remove('show');
                }
            });

            // =========================================
            // 전문 생성 폼 이벤트 핸들러
            // =========================================
            
            /**
             * 숫자 필드 여부 확인 헬퍼 함수
             * @param {string} fieldName - 필드명
             * @returns {boolean} 숫자 필드 여부
             */
            function isNumericField(fieldName) {
                const numericPatterns = /amt|amount|cnt|count|num|number|price|qty|quantity|seq|no|cd|code/i;
                return numericPatterns.test(fieldName);
            }
            
            /**
             * 필드 입력 행 생성 함수
             * @param {Object} field - 필드 정의 객체
             * @param {number} index - 필드 인덱스
             * @param {boolean} recognizeCRLF - CRLF 인식 여부
             * @returns {HTMLTableRowElement} 테이블 행 요소
             */
            function createFieldRow(field, index, recognizeCRLF) {
                const tr = document.createElement('tr');
                
                // CRLF 필드 특수 처리
                const isCRLFField = field.name.toLowerCase().match(/crlf|cr_lf|newline|eol/);
                
                if (isCRLFField && recognizeCRLF) {
                    // 자동 설정 필드
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            <span class="field-tag auto-tag">자동</span>
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text" 
                                   class="field-input auto-field generate-field-input"
                                   value="\\r\\n"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   id="gen-field-${index}"
                                   disabled
                                   readonly />
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}">\\r\\n</code>
                        </td>
                    `;
                } else {
                    // 일반 입력 필드
                    const isNumeric = isNumericField(field.name);
                    
                    tr.innerHTML = `
                        <td>
                            <span class="field-name">${field.name}</span>
                            ${isNumeric ? '<span class="field-tag numeric-tag">숫자</span>' : ''}
                        </td>
                        <td class="field-size">${field.size}</td>
                        <td>
                            <input type="text"
                                   class="field-input generate-field-input"
                                   data-field="${field.name}"
                                   data-size="${field.size}"
                                   data-index="${index}"
                                   data-field-name="${field.name}"
                                   data-field-size="${field.size}"
                                   data-field-index="${index}"
                                   id="gen-field-${index}"
                                   maxlength="${field.size}"
                                   placeholder="최대 ${field.size}자"
                                   ${isNumeric ? 'inputmode="numeric"' : ''} />
                            <div class="input-meta">
                                <span class="char-counter">
                                    <span class="current-length" id="char-count-${index}">0</span>/${field.size}
                                </span>
                            </div>
                        </td>
                        <td class="preview-cell">
                            <code class="preview-text" id="preview-field-${index}" data-field-size="${field.size}"></code>
                        </td>
                    `;
                    
                    // 입력 이벤트 바인딩을 위해 setTimeout 사용 (DOM에 추가된 후 실행)
                    setTimeout(function() {
                        const input = document.getElementById('gen-field-' + index);
                        const charCountEl = document.getElementById('char-count-' + index);
                        const previewEl = document.getElementById('preview-field-' + index);
                        
                        if (input) {
                            input.addEventListener('input', function() {
                                const value = this.value;
                                const size = parseInt(this.dataset.fieldSize);
                                
                                // 글자 수 카운터 업데이트
                                if (charCountEl) {
                                    charCountEl.textContent = value.length;
                                }
                                
                                // 미리보기 업데이트
                                if (previewEl) {
                                    previewEl.classList.remove('filled', 'padded', 'over');
                                    
                                    if (value.length === 0) {
                                        previewEl.textContent = '';
                                    } else if (value.length < size) {
                                        // 패딩 표시
                                        const padded = value + '░'.repeat(size - value.length);
                                        previewEl.textContent = padded;
                                        previewEl.classList.add('padded');
                                    } else if (value.length === size) {
                                        previewEl.textContent = value;
                                        previewEl.classList.add('filled');
                                    } else {
                                        // 초과
                                        previewEl.textContent = value + ' (초과!)';
                                        previewEl.classList.add('over');
                                    }
                                }
                            });
                        }
                    }, 0);
                }
                
                return tr;
            }
            
            /**
             * 폼 이벤트 리스너 연결 함수
             * 현재 선택된 구조체 정보를 클로저로 캡처합니다.
             * @param {Object} structDef - 구조체 정의 객체
             */
            function attachFormEvents(structDef) {
                // 미리보기 버튼
                const previewBtn = document.getElementById('preview-telegram-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', function() {
                        const inputs = document.querySelectorAll('.field-input');
                        let telegram = '';
                        const errors = [];
                        
                        // 각 필드 값 수집 및 패딩
                        inputs.forEach(function(input, index) {
                            const fieldName = input.dataset.field;
                            const fieldSize = parseInt(input.dataset.size);
                            let value = input.value;
                            
                            // CRLF 필드 처리
                            if (input.disabled) {
                                value = '\r\n';
                            }
                            
                            // 필수 필드 검증 (구분값)
                            if (fieldName && fieldName.toLowerCase().match(/kubun|type|구분/) && !value && !input.disabled) {
                                errors.push('"' + fieldName + '" 필드는 필수입니다');
                            }
                            
                            // 패딩 적용
                            const paddedValue = padValue(value, fieldSize, fieldName);
                            telegram += paddedValue;
                        });
                        
                        // 미리보기 박스 표시
                        const previewBox = document.getElementById('telegram-preview-box');
                        
                        if (errors.length > 0) {
                            previewBox.innerHTML = 
                                '<div class="preview-error">' +
                                '  <h5>⚠️ 입력 오류</h5>' +
                                '  <ul>' +
                                errors.map(function(err) { return '<li>' + err + '</li>'; }).join('') +
                                '  </ul>' +
                                '</div>';
                        } else {
                            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                            const escapedTelegram = escapeHtml(telegram);
                            
                            previewBox.innerHTML = 
                                '<div class="preview-success">' +
                                '  <div class="preview-header">' +
                                '    <h5>👁️ 생성된 전문 미리보기</h5>' +
                                '    <button class="copy-preview-btn" data-telegram="' + escapedTelegram + '">' +
                                '      📋 복사' +
                                '    </button>' +
                                '  </div>' +
                                '  <div class="preview-content">' +
                                '    <pre class="telegram-display">' + escapeForDisplay(telegram) + '</pre>' +
                                '  </div>' +
                                '  <div class="preview-info">' +
                                '    <div class="info-item">' +
                                '      <span class="info-label">길이:</span>' +
                                '      <span class="info-value">' + telegram.length + ' bytes</span>' +
                                '    </div>' +
                                '    <div class="info-item">' +
                                '      <span class="info-label">HEX:</span>' +
                                '      <span class="info-value hex-value">' + toHexPreview(telegram) + '</span>' +
                                '    </div>' +
                                (recognizeCRLF ? 
                                '    <div class="info-item">' +
                                '      <span class="info-label">CRLF:</span>' +
                                '      <span class="info-value">포함 (2 bytes)</span>' +
                                '    </div>' : '') +
                                '  </div>' +
                                '</div>';
                        }
                        
                        previewBox.style.display = 'block';
                    });
                }
                
                // 레코드 추가 버튼 - 이제 이벤트 위임 방식으로 document에서 처리
                // (아래 document.addEventListener 참조)
                
                // 초기화 버튼 - 이제 이벤트 위임 방식으로 document에서 처리
                // (아래 document.addEventListener 참조)
                
                // 실시간 입력 처리 (이벤트 위임)
                const formContainer = document.getElementById('generate-form-container');
                if (formContainer) {
                    formContainer.addEventListener('input', function(e) {
                        if (e.target.classList.contains('field-input') && !e.target.disabled) {
                            const input = e.target;
                            const fieldName = input.dataset.field;
                            const fieldSize = parseInt(input.dataset.size);
                            const value = input.value;
                            
                            // 1. 글자 수 카운터 업데이트
                            const row = input.closest('tr');
                            const currentLength = row.querySelector('.current-length');
                            
                            if (currentLength) {
                                currentLength.textContent = value.length;
                                
                                // 색상 변경
                                if (value.length > fieldSize) {
                                    currentLength.style.color = '#dc3545';
                                    input.style.borderColor = '#dc3545';
                                    input.style.backgroundColor = '#fff5f5';
                                } else if (value.length === fieldSize) {
                                    currentLength.style.color = '#28a745';
                                    input.style.borderColor = '#28a745';
                                    input.style.backgroundColor = '#f0fff4';
                                } else {
                                    currentLength.style.color = '#6c757d';
                                    input.style.borderColor = '#ced4da';
                                    input.style.backgroundColor = '#fff';
                                }
                            }
                            
                            // 2. 숫자 필드 검증
                            if (isNumericField(fieldName)) {
                                if (value && !/^[0-9]*$/.test(value)) {
                                    input.setCustomValidity('숫자만 입력 가능합니다');
                                    input.style.borderColor = '#ffc107';
                                } else {
                                    input.setCustomValidity('');
                                }
                            }
                            
                            // 3. 패딩 미리보기
                            const paddedValue = padValue(value, fieldSize, fieldName);
                            const previewCell = row.querySelector('.preview-text');
                            if (previewCell) {
                                previewCell.textContent = paddedValue;
                            }
                            
                            // 4. 길이 초과 시 경고 표시 (자동 자르기 대신)
                            // if (value.length > fieldSize) {
                            //     input.value = value.substring(0, fieldSize);
                            // }
                        }
                    });
                }
            }
            
            /**
             * 폼에서 전문 문자열 생성
             * @param {Object} structDef - 구조체 정의 객체
             * @returns {Object} { raw: 실제 전문, display: 표시용 전문 }
             */
            function buildTelegramFromForm(structDef) {
                const inputs = document.querySelectorAll('#form-fields-body .generate-field-input');
                let raw = '';
                let display = '';
                
                inputs.forEach(function(input, idx) {
                    const field = structDef.fields[idx];
                    let value = input.value;
                    
                    // CRLF 필드 처리
                    if (field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                        raw += '\r\n';
                        display += '\\r\\n';
                        return;
                    }
                    
                    // 값 패딩 (오른쪽 공백 채우기)
                    if (value.length < field.size) {
                        value = value + ' '.repeat(field.size - value.length);
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                    }
                    
                    raw += value;
                    display += value.replace(/ /g, '·');  // 공백을 점으로 표시
                });
                
                return { raw: raw, display: display };
            }
            
            /**
             * 전문 생성 폼 표시 함수
             * @param {Object} structDef - 구조체 정의 객체
             */
            function displayGenerateForm(structDef) {
                // 1. generate-form-container 초기화
                const container = document.getElementById('generate-form-container');
                
                // 2. recognizeCRLF 옵션 확인
                const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                
                // 3. 폼 HTML 생성
                const formHTML = 
                    '<div class="generate-form">' +
                    
                    '  <div class="form-header">' +
                    '    <div class="form-title">' +
                    '      <h4>📝 ' + (structDef.name || '구조체') + ' 입력 폼</h4>' +
                    '      <span class="form-badge">총 ' + structDef.totalSize + ' bytes</span>' +
                    '    </div>' +
                    '    <div class="form-info">' +
                    '      <small>' + structDef.fields.length + '개 필드</small>' +
                    '    </div>' +
                    '  </div>' +
                    
                    '  <table class="input-form-table">' +
                    '    <thead>' +
                    '      <tr>' +
                    '        <th style="width: 25%">필드명</th>' +
                    '        <th style="width: 8%">크기</th>' +
                    '        <th style="width: 42%">입력값</th>' +
                    '        <th style="width: 25%">미리보기</th>' +
                    '      </tr>' +
                    '    </thead>' +
                    '    <tbody id="form-fields-body">' +
                    '    </tbody>' +
                    '  </table>' +
                    
                    '  <div class="form-actions">' +
                    '    <button id="preview-telegram-btn" class="btn-info">' +
                    '      👁️ 미리보기' +
                    '    </button>' +
                    '    <button id="add-to-list-btn" class="btn-success">' +
                    '      ✓ 레코드 추가' +
                    '    </button>' +
                    '    <button id="reset-form-btn" class="btn-secondary">' +
                    '      🔄 초기화' +
                    '    </button>' +
                    '  </div>' +
                    
                    '  <div id="telegram-preview-box" class="preview-box" style="display: none;">' +
                    '  </div>' +
                    
                    '</div>';
                
                // 4. DOM에 추가
                container.innerHTML = formHTML;
                container.style.display = 'block';
                
                // 5. 필드 행 생성
                const tbody = document.getElementById('form-fields-body');
                
                structDef.fields.forEach(function(field, index) {
                    const row = createFieldRow(field, index, recognizeCRLF);
                    tbody.appendChild(row);
                });
                
                // 6. 이벤트 리스너 연결
                attachFormEvents(structDef);
            }
            
            /**
             * 레코드 생성 함수
             * @param {Object} struct - 구조체 정의
             */
            function generateRecord(struct) {
                const inputs = document.querySelectorAll('#form-fields-body .generate-field-input');
                let record = '';
                let hasError = false;
                
                inputs.forEach(function(input, idx) {
                    const field = struct.fields[idx];
                    let value = input.value;
                    
                    // CRLF 필드 처리
                    if (field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                        record += '\r\n';
                        return;
                    }
                    
                    // 값 패딩 (오른쪽 공백 채우기)
                    if (value.length < field.size) {
                        value = value + ' '.repeat(field.size - value.length);
                    } else if (value.length > field.size) {
                        value = value.substring(0, field.size);
                    }
                    
                    record += value;
                });
                
                if (!hasError) {
                    // 생성된 레코드 표시
                    addGeneratedRecord(record, struct.name);
                    showTemporaryMessage('레코드가 생성되었습니다. (' + record.length + ' bytes)');
                }
            }
            
            /**
             * 생성된 레코드를 목록에 추가
             * @param {string} record - 생성된 레코드
             * @param {string} structName - 구조체 이름
             */
            function addGeneratedRecord(record, structName) {
                const area = document.getElementById('generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (area.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'generated-records-header';
                    header.innerHTML = '<h5>📋 생성된 레코드 목록</h5>' +
                        '<button id="copy-all-records" class="secondary-btn">전체 복사</button>' +
                        '<button id="clear-all-records" class="danger-btn">전체 삭제</button>';
                    area.appendChild(header);
                    
                    // 전체 복사 버튼 이벤트
                    document.getElementById('copy-all-records').addEventListener('click', function() {
                        const records = area.querySelectorAll('.generated-record-content');
                        let allRecords = '';
                        records.forEach(function(r) {
                            allRecords += r.textContent + '\n';
                        });
                        navigator.clipboard.writeText(allRecords.trim()).then(function() {
                            showTemporaryMessage('전체 레코드가 복사되었습니다.');
                        });
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-all-records').addEventListener('click', function() {
                        if (confirm('모든 생성된 레코드를 삭제하시겠습니까?')) {
                            area.innerHTML = '';
                            showTemporaryMessage('모든 레코드가 삭제되었습니다.');
                        }
                    });
                }
                
                // 레코드 아이템 생성
                const item = document.createElement('div');
                item.className = 'generated-record-item';
                
                const info = document.createElement('span');
                info.className = 'record-info';
                info.textContent = structName + ' (' + record.length + ' bytes)';
                
                const content = document.createElement('code');
                content.className = 'generated-record-content';
                content.textContent = record.replace(/\r/g, '\\r').replace(/\n/g, '\\n');
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.textContent = '복사';
                copyBtn.addEventListener('click', function() {
                    navigator.clipboard.writeText(record).then(function() {
                        showTemporaryMessage('레코드가 복사되었습니다.');
                    });
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-record-btn';
                deleteBtn.textContent = '삭제';
                deleteBtn.addEventListener('click', function() {
                    item.remove();
                    // 레코드가 모두 삭제되면 헤더도 삭제
                    if (area.querySelectorAll('.generated-record-item').length === 0) {
                        area.innerHTML = '';
                    }
                });
                
                item.appendChild(info);
                item.appendChild(content);
                item.appendChild(copyBtn);
                item.appendChild(deleteBtn);
                area.appendChild(item);
            }
            
            /**
             * 레코드를 목록에 추가
             * @param {Object} record - 레코드 객체 (id, structName, telegram, fieldData, timestamp, length)
             */
            function addRecordToList(record) {
                const container = document.getElementById('generated-records-area');
                
                // 첫 번째 레코드인 경우 헤더 추가
                if (container.children.length === 0) {
                    const header = document.createElement('div');
                    header.className = 'records-header';
                    header.innerHTML = `
                        <div class="header-left">
                            <h4>📦 생성된 레코드 목록</h4>
                            <span class="record-count-badge">0개</span>
                        </div>
                        <div class="header-right">
                            <button id="export-all-records-btn" class="export-btn">
                                💾 전체 내보내기
                            </button>
                            <button id="clear-all-records-btn" class="clear-btn">
                                🗑️ 전체 삭제
                            </button>
                        </div>
                    `;
                    container.appendChild(header);
                    
                    // 목록 컨테이너 추가
                    const listContainer = document.createElement('div');
                    listContainer.id = 'records-list';
                    listContainer.className = 'records-list';
                    container.appendChild(listContainer);
                    
                    // 전체 내보내기 버튼 이벤트
                    document.getElementById('export-all-records-btn').addEventListener('click', function() {
                        if (!window.generatedRecords || window.generatedRecords.length === 0) {
                            showTemporaryMessage('내보낼 레코드가 없습니다.');
                            return;
                        }
                        showExportModal();
                    });
                    
                    // 전체 삭제 버튼 이벤트
                    document.getElementById('clear-all-records-btn').addEventListener('click', function() {
                        if (confirm('모든 생성된 레코드를 삭제하시겠습니까?')) {
                            container.innerHTML = '';
                            window.generatedRecords = [];
                            showTemporaryMessage('모든 레코드가 삭제되었습니다.');
                        }
                    });
                }
                
                // 레코드 카드 생성
                const recordCard = document.createElement('div');
                recordCard.className = 'record-item';
                recordCard.dataset.id = record.id;
                
                const recordIndex = container.querySelectorAll('.record-item').length;
                
                recordCard.innerHTML = `
                    <div class="record-item-header">
                        <div class="record-meta">
                            <span class="record-number">#${recordIndex + 1}</span>
                            <span class="record-struct-name">${record.structName}</span>
                            <span class="record-timestamp">${record.timestamp}</span>
                        </div>
                        <div class="record-actions">
                            <button class="btn-icon copy-record-btn" 
                                    data-id="${record.id}" 
                                    title="복사">
                                📋
                            </button>
                            <button class="btn-icon view-detail-btn" 
                                    data-id="${record.id}"
                                    title="상세보기">
                                👁️
                            </button>
                            <button class="btn-icon delete-record-btn" 
                                    data-id="${record.id}"
                                    title="삭제">
                                🗑️
                            </button>
                        </div>
                    </div>
                    
                    <div class="record-item-body">
                        <div class="telegram-box">
                            <pre class="telegram-text">${escapeForDisplay(record.telegram)}</pre>
                        </div>
                        <div class="record-stats">
                            <span class="stat-item">
                                <span class="stat-label">길이:</span>
                                <span class="stat-value">${record.length} bytes</span>
                            </span>
                        </div>
                    </div>
                    
                    <div class="record-detail" style="display: none;">
                        <table class="detail-table">
                            <thead>
                                <tr>
                                    <th>필드명</th>
                                    <th>크기</th>
                                    <th>입력값</th>
                                    <th>패딩후</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${record.fieldData.map(field => `
                                    <tr>
                                        <td>${field.name}</td>
                                        <td>${field.size}</td>
                                        <td>${field.value || '<비어있음>'}</td>
                                        <td><code>${escapeForDisplay(field.padded)}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                
                // 목록에 추가 (최신이 위로)
                const listContainer = container.querySelector('#records-list');
                listContainer.insertBefore(recordCard, listContainer.firstChild);
                
                // 카운트 업데이트
                updateRecordCount();
                
                // 전역 저장소에 추가
                if (!window.generatedRecords) {
                    window.generatedRecords = [];
                }
                window.generatedRecords.unshift(record);
            }
            
            // =========================================
            // 레코드 카드 이벤트 (이벤트 위임)
            // =========================================
            document.addEventListener('click', function(e) {
              
              // 복사 버튼
              if (e.target.classList.contains('copy-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                const record = window.generatedRecords.find(r => r.id === recordId)
                
                if (record) {
                  navigator.clipboard.writeText(record.telegram).then(() => {
                    const originalText = e.target.textContent
                    e.target.textContent = '✓'
                    e.target.style.backgroundColor = 'rgba(40,167,69,0.3)'
                    
                    setTimeout(() => {
                      e.target.textContent = originalText
                      e.target.style.backgroundColor = ''
                    }, 2000)
                  }).catch(err => {
                    alert('복사 실패: ' + err.message)
                  })
                }
              }
              
              // 상세보기 토글
              if (e.target.classList.contains('view-detail-btn')) {
                const recordId = e.target.dataset.id
                const recordCard = document.querySelector(`.record-item[data-id="${recordId}"]`)
                const detailDiv = recordCard.querySelector('.record-detail')
                
                if (detailDiv.style.display === 'none') {
                  detailDiv.style.display = 'block'
                  e.target.textContent = '🔼'
                  e.target.title = '상세닫기'
                } else {
                  detailDiv.style.display = 'none'
                  e.target.textContent = '👁️'
                  e.target.title = '상세보기'
                }
              }
              
              // 삭제 버튼
              if (e.target.classList.contains('delete-record-btn')) {
                const recordId = parseInt(e.target.dataset.id)
                
                if (confirm('이 레코드를 삭제하시겠습니까?')) {
                  // DOM에서 제거
                  const recordCard = document.querySelector(`.record-item[data-id="${recordId}"]`)
                  recordCard.style.opacity = '0'
                  recordCard.style.transform = 'translateX(-100%)'
                  
                  setTimeout(() => {
                    recordCard.remove()
                    
                    // 배열에서 제거
                    const index = window.generatedRecords.findIndex(r => r.id === recordId)
                    if (index > -1) {
                      window.generatedRecords.splice(index, 1)
                    }
                    
                    // 카운트 업데이트
                    updateRecordCount()
                    
                    // 번호 재정렬
                    reindexRecords()
                    
                    // 목록이 비었으면 헤더도 제거
                    if (window.generatedRecords.length === 0) {
                      document.getElementById('generated-records-area').innerHTML = ''
                    }
                  }, 300)
                }
              }
            })
            
            function updateRecordCount() {
              const badge = document.querySelector('.record-count-badge')
              if (badge) {
                const count = document.querySelectorAll('.record-item').length
                badge.textContent = `${count}개`
              }
            }

            function reindexRecords() {
              document.querySelectorAll('.record-item').forEach((card, index) => {
                const numberSpan = card.querySelector('.record-number')
                numberSpan.textContent = `#${index + 1}`
              })
            }
            
            // =========================================
            // 전체 내보내기 모달 관련 함수들
            // =========================================
            
            /**
             * 전체 내보내기 모달 표시
             */
            function showExportModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-container">
                        <div class="modal-header">
                            <h3>💾 전체 내보내기</h3>
                            <button class="modal-close-btn">✕</button>
                        </div>
                        
                        <div class="modal-body">
                            <p class="modal-description">
                                총 <strong>${window.generatedRecords.length}개</strong>의 레코드를 내보냅니다
                            </p>
                            
                            <div class="export-format-select">
                                <label>내보내기 형식</label>
                                <div class="format-options">
                                    <label class="format-option selected">
                                        <input type="radio" name="export-format" value="continuous" checked>
                                        <span class="option-text">
                                            <strong>연속 데이터</strong>
                                            <small>모든 레코드를 줄바꿈 없이 연결</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="export-format" value="lines">
                                        <span class="option-text">
                                            <strong>줄바꿈 구분</strong>
                                            <small>각 레코드를 줄바꿈으로 구분</small>
                                        </span>
                                    </label>
                                    
                                    <label class="format-option">
                                        <input type="radio" name="export-format" value="hex">
                                        <span class="option-text">
                                            <strong>HEX 형식</strong>
                                            <small>16진수로 변환하여 표시</small>
                                        </span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="export-preview">
                                <label>미리보기</label>
                                <textarea id="export-preview-area" readonly rows="12"></textarea>
                                <div class="preview-stats">
                                    <span id="export-total-bytes">0 bytes</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-footer">
                            <button id="download-export-btn" class="btn-primary">
                                ⬇️ 파일 다운로드
                            </button>
                            <button id="copy-export-btn" class="btn-secondary">
                                📋 클립보드 복사
                            </button>
                            <button class="modal-close-btn btn-cancel">
                                취소
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 포맷 옵션 선택 스타일 처리
                modal.querySelectorAll('.format-option').forEach(option => {
                    option.addEventListener('click', function() {
                        modal.querySelectorAll('.format-option').forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        this.querySelector('input[type="radio"]').checked = true;
                        updateExportPreview();
                    });
                });
                
                // 포맷 변경 시 미리보기 업데이트
                modal.querySelectorAll('input[name="export-format"]').forEach(radio => {
                    radio.addEventListener('change', updateExportPreview);
                });
                
                // 초기 미리보기
                updateExportPreview();
                
                // 닫기 버튼들
                modal.querySelectorAll('.modal-close-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.remove();
                    });
                });
                
                // 오버레이 클릭으로 닫기
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // 다운로드
                modal.querySelector('#download-export-btn').addEventListener('click', () => {
                    const format = modal.querySelector('input[name="export-format"]:checked').value;
                    const data = generateExportData(format);
                    const filename = `telegrams_${new Date().getTime()}.txt`;
                    downloadFile(data, filename);
                });
                
                // 복사
                modal.querySelector('#copy-export-btn').addEventListener('click', () => {
                    const textarea = modal.querySelector('#export-preview-area');
                    textarea.select();
                    document.execCommand('copy');
                    
                    const btn = modal.querySelector('#copy-export-btn');
                    const originalText = btn.textContent;
                    btn.textContent = '✓ 복사됨';
                    btn.style.backgroundColor = '#1e7e34';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                });
            }
            
            /**
             * 내보내기 미리보기 업데이트
             */
            function updateExportPreview() {
                const format = document.querySelector('input[name="export-format"]:checked').value;
                const data = generateExportData(format);
                
                document.getElementById('export-preview-area').value = data;
                document.getElementById('export-total-bytes').textContent = `${data.length} bytes`;
            }
            
            /**
             * 내보내기 데이터 생성
             */
            function generateExportData(format) {
                const records = window.generatedRecords.slice().reverse(); // 원래 순서로
                const telegrams = records.map(r => r.telegram);
                
                switch(format) {
                    case 'continuous':
                        return telegrams.join('');
                        
                    case 'lines':
                        return telegrams.join('\n');
                        
                    case 'hex':
                        return telegrams.map((t, i) => {
                            const hex = toHexString(t);
                            return `레코드 #${i+1}:\n${hex}`;
                        }).join('\n\n');
                        
                    default:
                        return telegrams.join('');
                }
            }
            
            /**
             * 문자열을 HEX 문자열로 변환
             */
            function toHexString(str) {
                return Array.from(str)
                    .map((c, i) => {
                        const hex = c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                        return (i > 0 && i % 16 === 0) ? '\n' + hex : hex;
                    })
                    .join(' ');
            }
            
            /**
             * 파일 다운로드
             */
            function downloadFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            /**
             * 생성 폼 초기화
             */
            function resetGenerateForm() {
                // 비활성화되지 않은 입력 필드만 초기화
                document.querySelectorAll('.field-input:not(:disabled)').forEach(function(input) {
                    input.value = '';
                    input.style.borderColor = '#ced4da';
                    input.style.backgroundColor = '#fff';
                });
                
                // 카운터 초기화
                document.querySelectorAll('.current-length').forEach(function(span) {
                    span.textContent = '0';
                    span.style.color = '#6c757d';
                });
                
                // 미리보기 초기화
                document.querySelectorAll('.preview-text').forEach(function(code) {
                    const row = code.closest('tr');
                    if (row && !row.querySelector('.auto-field')) {
                        code.textContent = '';
                    }
                });
                
                // 미리보기 박스 숨김
                const previewBox = document.getElementById('telegram-preview-box');
                if (previewBox) {
                    previewBox.style.display = 'none';
                }
                
                // 첫 입력 필드로 포커스
                const firstInput = document.querySelector('.field-input:not(:disabled)');
                if (firstInput) firstInput.focus();
            }
            
            /**
             * 레코드 수 반환
             */
            function getRecordCount() {
                return document.querySelectorAll('.record-item').length;
            }
            
            // add-to-list-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'add-to-list-btn') {
                    // 1. 폼 검증
                    const inputs = document.querySelectorAll('.field-input');
                    let telegram = '';
                    const fieldData = [];
                    let hasError = false;
                    
                    inputs.forEach(function(input) {
                        const fieldName = input.dataset.field;
                        const fieldSize = parseInt(input.dataset.size);
                        let value = input.disabled ? '\r\n' : input.value;
                        
                        // 필수 필드 체크
                        if (fieldName && fieldName.toLowerCase().match(/kubun|type/) && !value && !input.disabled) {
                            hasError = true;
                            input.style.borderColor = '#dc3545';
                            input.focus();
                            return;
                        }
                        
                        const paddedValue = padValue(value, fieldSize, fieldName);
                        telegram += paddedValue;
                        
                        fieldData.push({
                            name: fieldName,
                            size: fieldSize,
                            value: value,
                            padded: paddedValue
                        });
                    });
                    
                    if (hasError) {
                        alert('필수 필드를 입력하세요');
                        return;
                    }
                    
                    // 2. 레코드 객체 생성
                    const select = document.getElementById('generate-struct-select');
                    const structName = select.options[select.selectedIndex].text.split('(')[0].trim();
                    
                    const record = {
                        id: Date.now(),
                        structName: structName,
                        telegram: telegram,
                        fieldData: fieldData,
                        timestamp: new Date().toLocaleString('ko-KR'),
                        length: telegram.length
                    };
                    
                    // 3. 목록에 추가
                    addRecordToList(record);
                    
                    // 4. 폼 초기화 옵션
                    const shouldReset = confirm(
                        '레코드가 추가되었습니다.\n\n' +
                        '입력 폼을 초기화하시겠습니까?\n' +
                        '(아니오를 선택하면 같은 값으로 계속 추가할 수 있습니다)'
                    );
                    
                    if (shouldReset) {
                        resetGenerateForm();
                    }
                    
                    // 5. 성공 메시지
                    showTemporaryMessage('✓ 레코드 #' + getRecordCount() + '가 추가되었습니다');
                    
                    // 6. 레코드 영역으로 스크롤
                    document.getElementById('generated-records-area').scrollIntoView({ 
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            });
            
            // reset-form-btn 클릭 이벤트 (이벤트 위임)
            document.addEventListener('click', function(e) {
                if (e.target.id === 'reset-form-btn') {
                    if (confirm('입력한 내용을 모두 초기화하시겠습니까?')) {
                        resetGenerateForm();
                    }
                }
            });
            
            // load-generate-form-btn 클릭 이벤트
            document.getElementById('load-generate-form-btn').addEventListener('click', function() {
                // 1. 구조체 정의 수집
                const structDefs = collectStructDefinitions();
                
                if (!structDefs || structDefs.length === 0) {
                    alert('구조체를 먼저 정의하세요.');
                    return;
                }
                
                // 2. select 옵션 채우기
                const select = document.getElementById('generate-struct-select');
                select.innerHTML = '<option value="">구조체를 선택하세요</option>';
                
                structDefs.forEach(function(struct, index) {
                    const option = document.createElement('option');
                    option.value = index;
                    
                    // 구조체 정보 표시
                    const structInfo = (struct.name || ('구조체' + (index + 1))) + ' (' + struct.totalSize + ' bytes';
                    const fieldInfo = ', ' + struct.fields.length + '개 필드)';
                    option.textContent = structInfo + fieldInfo;
                    
                    select.appendChild(option);
                });
                
                // 3. select 활성화
                select.disabled = false;
                
                // 4. 구조체 선택 이벤트 (기존 이벤트 제거 후 추가)
                const newSelect = select.cloneNode(true);
                select.parentNode.replaceChild(newSelect, select);
                
                newSelect.addEventListener('change', function() {
                    const selectedIndex = parseInt(this.value);
                    
                    if (isNaN(selectedIndex)) {
                        document.getElementById('generate-form-container').style.display = 'none';
                        return;
                    }
                    
                    const selectedStruct = structDefs[selectedIndex];
                    displayGenerateForm(selectedStruct);
                });
                
                // 버튼 비활성화 (한 번만 로드)
                this.disabled = true;
                this.textContent = '✓ 로드 완료';
                
                showTemporaryMessage('구조체 목록을 불러왔습니다. 생성할 구조체를 선택하세요.');
            });
            
            // 구조체 카드 추가/삭제 시 폼 로드 버튼 초기화
            // MutationObserver 사용 (DOMNodeInserted는 deprecated)
            const structObserver = new MutationObserver(function(mutations) {
                const loadBtn = document.getElementById('load-generate-form-btn');
                if (loadBtn && loadBtn.disabled) {
                    loadBtn.disabled = false;
                    loadBtn.textContent = '폼 불러오기';
                }
            });
            
            const structDefsContainer = document.getElementById('struct-definitions-container');
            if (structDefsContainer) {
                structObserver.observe(structDefsContainer, { childList: true, subtree: true });
            }
            
            // 초기 로드 버튼 활성화 확인
            setTimeout(function() {
                const loadBtn = document.getElementById('load-generate-form-btn');
                const cards = document.querySelectorAll('.struct-card');
                if (loadBtn && cards.length > 0) {
                    loadBtn.disabled = false;
                }
            }, 100);
        });
    </script>
</body>
</html>
