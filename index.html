<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>í†µì „ë¬¸ íŒŒì„œ</title>
    <style>
        /* ì „ì²´ ë ˆì´ì•„ì›ƒ */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        /* ì…ë ¥ ì˜ì—­ */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* ê²°ê³¼ ì˜ì—­ */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        #result-table, .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td,
        .result-table th, .result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th, .result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even),
        .result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover,
        .result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7),
        .result-table td:last-child {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* ë°˜ì‘í˜• í…Œì´ë¸” ë˜í¼ */
        .table-wrapper {
            overflow-x: auto;
        }

        /* ë²„íŠ¼ ê·¸ë£¹ */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* ì—ëŸ¬ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* íŒŒì‹± ì—ëŸ¬ ìŠ¤íƒ€ì¼ */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* íƒ­ ìŠ¤íƒ€ì¼ */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* êµ¬ì¡°ì²´ ê²°ê³¼ ê·¸ë£¹ ìŠ¤íƒ€ì¼ */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* êµ¬ì¡°ì²´ ìš”ì•½ ì •ë³´ ìŠ¤íƒ€ì¼ */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* ë³µì‚¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .copy-result-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .copy-result-btn:hover {
            background: #1e7e34;
        }

        /* ë„ì›€ë§ ì„¹ì…˜ ìŠ¤íƒ€ì¼ */
        .help-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .help-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-toggle:hover {
            background: #dee2e6;
        }

        .help-toggle-icon {
            transition: transform 0.3s ease;
        }

        .help-toggle.expanded .help-toggle-icon {
            transform: rotate(180deg);
        }

        .help-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .help-content.expanded {
            padding: 16px;
            max-height: 500px;
        }

        .help-content h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .help-content p {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        .help-content ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }

        .help-content li {
            margin: 5px 0;
            color: #666;
            font-size: 13px;
        }

        .help-content code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .help-content pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin: 10px 0;
        }

        /* í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #run-tests-btn {
            background: #6f42c1;
            margin-left: auto;
        }

        #run-tests-btn:hover {
            background: #5a32a3;
        }

        /* í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìŠ¤íƒ€ì¼ */
        .test-results {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .test-results.success {
            background: #d4edda;
            border: 1px solid #28a745;
        }

        .test-results.failure {
            background: #f8d7da;
            border: 1px solid #dc3545;
        }

        .test-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-pass {
            color: #28a745;
        }

        .test-fail {
            color: #dc3545;
        }

        /* ì„¹ì…˜ í—¤ë” ìŠ¤íƒ€ì¼ */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        /* êµ¬ì¡°ì²´ ì¶”ê°€ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #add-struct-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #add-struct-btn:hover {
            background: #138496;
        }

        /* êµ¬ì¡°ì²´ ì •ì˜ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #struct-definitions-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* êµ¬ì¡°ì²´ ì¹´ë“œ ìŠ¤íƒ€ì¼ */
        .struct-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
        }

        .struct-card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }

        .struct-number {
            font-weight: bold;
            color: #495057;
            font-size: 16px;
        }

        .remove-struct-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .remove-struct-btn:hover {
            background: #c82333;
        }

        .struct-card-body .input-row {
            margin-bottom: 12px;
        }

        .struct-card-body .input-row label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .struct-card-body .input-row input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .struct-card-body .input-row small {
            color: #6c757d;
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }

        .struct-card-body .input-row textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* íŒŒì‹± í†µê³„ ìŠ¤íƒ€ì¼ */
        .parse-stats {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .parse-stats h3 {
            margin: 0 0 12px 0;
            color: #1565c0;
            font-size: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stats-grid > div {
            background: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }

        /* ë ˆì½”ë“œ í—¤ë” ìŠ¤íƒ€ì¼ */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        /* êµ¬ë¶„ê°’ ë°°ì§€ ìŠ¤íƒ€ì¼ */
        .kubun-badge {
            background: #6610f2;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }

        /* ë ˆì½”ë“œ ë³µì‚¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .copy-record-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .copy-record-btn:hover {
            background: #1e7e34;
        }

        /* ëª¨ë°”ì¼ ëŒ€ì‘ */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .record-header {
                flex-wrap: wrap;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <h1>í†µì „ë¬¸ íŒŒì„œ</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML íŒŒì‹±</button>
        <button class="tab-btn" data-tab="struct">C êµ¬ì¡°ì²´ íŒŒì‹±</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        <div id="input-section">
            <label for="xml-input">XML ê·œê²©</label>
            <textarea id="xml-input" rows="10" placeholder="XML ê·œê²© ì…ë ¥"></textarea>
            
            <label for="telegram-input">í†µì „ë¬¸</label>
            <textarea id="telegram-input" rows="5" placeholder="í†µì „ë¬¸ ì…ë ¥"></textarea>
        </div>
        
        <div class="button-group">
            <button id="sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
            <button id="parse-btn">íŒŒì‹± ì‹¤í–‰</button>
            <button id="clear-btn">ì´ˆê¸°í™”</button>
        </div>
        
        <div id="result-container"></div>
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <!-- ë„ì›€ë§ ì„¹ì…˜ -->
        <div class="help-section">
            <button class="help-toggle" type="button">
                <span>ğŸ“– ì‚¬ìš© ë°©ë²• ì•ˆë‚´</span>
                <span class="help-toggle-icon">â–¼</span>
            </button>
            <div class="help-content">
                <h4>C êµ¬ì¡°ì²´ íŒŒì‹± ì‚¬ìš©ë²•</h4>
                <p>ê³ ì • ê¸¸ì´ ë°ì´í„°ë¥¼ C êµ¬ì¡°ì²´ ì •ì˜ì— ë”°ë¼ íŒŒì‹±í•©ë‹ˆë‹¤.</p>
                
                <h4>1. êµ¬ì¡°ì²´ ì •ì˜ í˜•ì‹</h4>
                <p><code>typedef struct { ... } êµ¬ì¡°ì²´ëª…;</code> í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•©ë‹ˆë‹¤.</p>
                <pre>typedef struct {
    char record_kubun[1];  // ë ˆì½”ë“œ êµ¬ë¶„
    char bank_cd[2];       // ì€í–‰ ì½”ë“œ
    char cust_id[7];       // ê³ ê° ID
} DHF_H;</pre>
                
                <h4>2. ë°ì´í„° ì…ë ¥ ê·œì¹™</h4>
                <ul>
                    <li>ê° ì¤„ì´ í•˜ë‚˜ì˜ ë°ì´í„° ë ˆì½”ë“œì…ë‹ˆë‹¤</li>
                    <li>ì—¬ëŸ¬ êµ¬ì¡°ì²´ê°€ ìˆì„ ê²½ìš°, ì²« ê¸€ìë¡œ êµ¬ì¡°ì²´ë¥¼ ìë™ ë§¤ì¹­í•©ë‹ˆë‹¤</li>
                    <li>ì˜ˆ: <code>H</code>ë¡œ ì‹œì‘ â†’ <code>DHF_H</code> (Hë¡œ ëë‚˜ëŠ” êµ¬ì¡°ì²´)</li>
                    <li>ì˜ˆ: <code>D</code>ë¡œ ì‹œì‘ â†’ <code>DHF_D</code> (Dë¡œ ëë‚˜ëŠ” êµ¬ì¡°ì²´)</li>
                </ul>
                
                <h4>3. ì§€ì› ê¸°ëŠ¥</h4>
                <ul>
                    <li>ì—¬ëŸ¬ êµ¬ì¡°ì²´ ë™ì‹œ ì •ì˜ ê°€ëŠ¥</li>
                    <li>ì£¼ì„ ì§€ì›: <code>//</code> í•œì¤„ ì£¼ì„, <code>/* */</code> ë¸”ë¡ ì£¼ì„</li>
                    <li>íŒŒì‹± ê²°ê³¼ë¥¼ TSV í˜•ì‹ìœ¼ë¡œ í´ë¦½ë³´ë“œì— ë³µì‚¬ ê°€ëŠ¥</li>
                </ul>
                
                <h4>4. ì£¼ì˜ì‚¬í•­</h4>
                <ul>
                    <li>ë°ì´í„° ê¸¸ì´ê°€ êµ¬ì¡°ì²´ ì´ í¬ê¸°ì™€ ë‹¤ë¥´ë©´ ê²½ê³ ê°€ í‘œì‹œë©ë‹ˆë‹¤</li>
                    <li>char ë°°ì—´ë§Œ ì •í™•íˆ ì§€ì›ë©ë‹ˆë‹¤ (int, short ë“±ì€ charë¡œ ì²˜ë¦¬)</li>
                </ul>
            </div>
        </div>

        <div id="struct-input-section">
            <div class="section-header">
                <h3>C êµ¬ì¡°ì²´ ì •ì˜</h3>
                <button id="add-struct-btn">+ êµ¬ì¡°ì²´ ì¶”ê°€</button>
            </div>
            
            <div id="struct-definitions-container">
                <!-- êµ¬ì¡°ì²´ ì…ë ¥ ì¹´ë“œë“¤ì´ ì—¬ê¸° ë™ì  ì¶”ê°€ë¨ -->
            </div>
            
            <label for="struct-data" style="margin-top: 20px;">í†µ ë°ì´í„°</label>
            <textarea id="struct-data" rows="10" placeholder="íŒŒì‹±í•  ë°ì´í„° ì…ë ¥ (ì¤„ë°”ê¿ˆ ìœ ë¬´ ë¬´ê´€)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
                <button id="struct-parse-btn">íŒŒì‹± ì‹¤í–‰</button>
                <button id="struct-clear-btn">ì „ì²´ ì´ˆê¸°í™”</button>
            </div>
        </div>

        <div id="struct-result-container"></div>
    </div>

    <script>
        /**
         * =====================================================
         * ì „ì—­ ë³€ìˆ˜
         * =====================================================
         */
        let structCardIndex = 0;

        /**
         * =====================================================
         * ì •ê·œì‹ ìºì‹± - ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ì •ê·œì‹ì„ ë¯¸ë¦¬ ì»´íŒŒì¼
         * =====================================================
         */
        const REGEX_CACHE = {
            // í•œì¤„ ì£¼ì„ ì œê±°: // ë¶€í„° ì¤„ ëê¹Œì§€ ë§¤ì¹­
            singleLineComment: /\/\/.*$/gm,
            
            // ë¸”ë¡ ì£¼ì„ ì œê±°: /* ë¶€í„° */ ê¹Œì§€ (ë¹„íƒìš•ì  ë§¤ì¹­)
            blockComment: /\/\*[\s\S]*?\*\//g,
            
            // typedef struct ë¸”ë¡ ì¶”ì¶œ:
            // - typedef\s+struct: "typedef struct" í‚¤ì›Œë“œ
            // - (\w+)?: ì„ íƒì  êµ¬ì¡°ì²´ ì´ë¦„ (ìº¡ì²˜ ê·¸ë£¹ 1)
            // - \s*\{([^}]+)\}: ì¤‘ê´„í˜¸ì™€ ë‚´ìš© (ìº¡ì²˜ ê·¸ë£¹ 2)
            // - \s*(\w+)\s*;: typedef ë³„ì¹­ ì´ë¦„ (ìº¡ì²˜ ê·¸ë£¹ 3)
            structPattern: /typedef\s+struct\s+(\w+)?\s*\{([^}]+)\}\s*(\w+)\s*;/g,
            
            // í•„ë“œ ì¶”ì¶œ:
            // - (unsigned\s+)?: ì„ íƒì  unsigned í‚¤ì›Œë“œ (ìº¡ì²˜ ê·¸ë£¹ 1)
            // - (\w+): ê¸°ë³¸ íƒ€ì… (char, int ë“±) (ìº¡ì²˜ ê·¸ë£¹ 2)
            // - \s+(\w+): í•„ë“œëª… (ìº¡ì²˜ ê·¸ë£¹ 3)
            // - \s*\[\s*(\d+)\s*\]: ë°°ì—´ í¬ê¸° (ìº¡ì²˜ ê·¸ë£¹ 4)
            fieldPattern: /(unsigned\s+)?(\w+)\s+(\w+)\s*\[\s*(\d+)\s*\]/g,
            
            // êµ¬ì¡°ì²´ëª…ì—ì„œ ìˆ«ì ì¶”ì¶œ: ë¬¸ìì—´ ëì˜ ì—°ì†ëœ ìˆ«ì
            trailingNumber: /(\d+)$/
        };

        /**
         * ì •ê·œì‹ íŒ¨í„´ì„ ë³µì œí•˜ì—¬ ë°˜í™˜
         * ì •ê·œì‹ì€ ìƒíƒœë¥¼ ê°€ì§€ë¯€ë¡œ(lastIndex), ì‚¬ìš© ì „ ë³µì œ í•„ìš”
         * @param {string} name - REGEX_CACHEì˜ í‚¤ ì´ë¦„
         * @returns {RegExp} ë³µì œëœ ì •ê·œì‹ ê°ì²´
         */
        function getRegex(name) {
            const original = REGEX_CACHE[name];
            return new RegExp(original.source, original.flags);
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ì¹´ë“œ ìƒì„± í•¨ìˆ˜
         * êµ¬ì¡°ì²´ ì…ë ¥ì„ ìœ„í•œ ì¹´ë“œ DOM ìš”ì†Œ ìƒì„±
         * =====================================================
         * @param {number} index - êµ¬ì¡°ì²´ ì¸ë±ìŠ¤ ë²ˆí˜¸
         * @returns {HTMLElement} div.struct-card DOM ìš”ì†Œ
         */
        function createStructCard(index) {
            // 1. div ìƒì„±, class="struct-card", data-index="${index}"
            const div = document.createElement('div');
            div.className = 'struct-card';
            div.setAttribute('data-index', index);

            // 2. ë‚´ë¶€ HTML ì„¤ì •
            div.innerHTML = `
                <div class="struct-card-header">
                    <span class="struct-number">êµ¬ì¡°ì²´ #${index + 1}</span>
                    <button class="remove-struct-btn" data-index="${index}">âœ• ì‚­ì œ</button>
                </div>
                
                <div class="struct-card-body">
                    <div class="input-row">
                        <label>êµ¬ì¡°ì²´ëª… (ì„ íƒ)</label>
                        <input type="text" class="struct-name" placeholder="ì˜ˆ: DHF_H, HeaderRecord" />
                    </div>
                    
                    <div class="input-row">
                        <label>êµ¬ë¶„ê°’ (ì„ íƒ)</label>
                        <input type="text" class="struct-kubun" maxlength="5" placeholder="ì˜ˆ: H, 01, HEADER" />
                        <small>ì—¬ëŸ¬ êµ¬ì¡°ì²´ ì‚¬ìš© ì‹œ í•„ìˆ˜. ë°ì´í„° ì²« ê¸€ìë¡œ êµ¬ì¡°ì²´ ì‹ë³„</small>
                    </div>
                    
                    <div class="input-row">
                        <label>êµ¬ì¡°ì²´ ì •ì˜</label>
                        <textarea class="struct-definition" rows="8" placeholder="typedef struct { ... } êµ¬ì¡°ì²´ëª…;"></textarea>
                    </div>
                </div>
            `;

            // 3. ìš”ì†Œ ë°˜í™˜
            return div;
        }

        /**
         * =====================================================
         * XML ê·œê²© íŒŒì‹± í•¨ìˆ˜
         * XML ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ col ìš”ì†Œ ë°°ì—´ë¡œ ë³€í™˜
         * =====================================================
         * @param {string} xmlString - XML ê·œê²© ë¬¸ìì—´
         * @returns {Array|null} col ìš”ì†Œ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseXMLSpec(xmlString) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: ì…ë ¥ê°’ì´ ë¬¸ìì—´ì´ ì•„ë‹™ë‹ˆë‹¤.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: ë¹ˆ ë¬¸ìì—´ì´ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                return null;
            }

            // DOMParserë¥¼ ì‚¬ìš©í•´ XML ë¬¸ì„œë¡œ ë³€í™˜
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', e.message);
                return null;
            }

            // parsererror ì²´í¬
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', parseError.textContent);
                return null;
            }

            // ëª¨ë“  col ìš”ì†Œ ì„ íƒ
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return [];
            }

            // ìœ íš¨í•œ col ìš”ì†Œë“¤ì„ ë‹´ì„ ë°°ì—´
            const result = [];

            // ê° col ìš”ì†Œ ì²˜ë¦¬
            colElements.forEach((col, index) => {
                // ì†ì„± ì¶”ì¶œ
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // í•„ìˆ˜ ì†ì„± ê²€ì¦
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì— í•„ìˆ˜ ì†ì„±ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: ${missingAttrs.join(', ')}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // sizeë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜
                const size = parseInt(sizeAttr, 10);

                // sizeê°€ ìœ íš¨í•œ ì •ìˆ˜ì¸ì§€ ê²€ì¦
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤: "${sizeAttr}"`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: ${size}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // ìœ íš¨í•œ col ì •ë³´ë¥¼ ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        /**
         * =====================================================
         * í†µì „ë¬¸ íŒŒì‹± í•¨ìˆ˜
         * í†µì „ë¬¸ ë¬¸ìì—´ì„ XML ê·œê²©ì— ë§ê²Œ ë¶„ë¦¬
         * =====================================================
         * @param {string} telegramString - í†µì „ë¬¸ ë¬¸ìì—´
         * @param {Array} xmlSpec - parseXMLSpecì˜ ê²°ê³¼ ë°°ì—´
         * @returns {Array} íŒŒì‹±ëœ ê²°ê³¼ ë°°ì—´
         */
        function parseTelegram(telegramString, xmlSpec) {
            // í˜„ì¬ ìœ„ì¹˜ ì´ˆê¸°í™”
            let currentPos = 0;

            // ë¹ˆ ê²°ê³¼ ë°°ì—´ ìƒì„±
            const result = [];

            // xmlSpec ë°°ì—´ ìˆœíšŒ
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // ì‹œì‘/ì¢…ë£Œ ìœ„ì¹˜ ê³„ì‚°
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substringìœ¼ë¡œ ê°’ ì¶”ì¶œ (ì¸ë±ìŠ¤ ë²”ìœ„ ì´ˆê³¼í•´ë„ ì˜¤ë¥˜ ì—†ì´ ì²˜ë¦¬ë¨)
                const value = telegramString.substring(startPos, endPos);

                // ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // í˜„ì¬ ìœ„ì¹˜ ì´ë™
                currentPos += spec.size;
            }

            // í†µì „ë¬¸ ì „ì²´ ê¸¸ì´ì™€ ì˜ˆìƒ ê¸¸ì´ ë¹„êµ
            if (telegramString.length !== currentPos) {
                console.warn(
                    `parseTelegram: í†µì „ë¬¸ ê¸¸ì´(${telegramString.length})ì™€ ì˜ˆìƒ ê¸¸ì´(${currentPos})ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`
                );
            }

            return result;
        }

        /**
         * =====================================================
         * C êµ¬ì¡°ì²´ ì •ì˜ íŒŒì‹± í•¨ìˆ˜
         * êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ êµ¬ì¡°ì²´ ë°°ì—´ë¡œ ë³€í™˜
         * =====================================================
         * @param {string} structText - C êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´
         * @returns {Array|null} êµ¬ì¡°ì²´ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseStructDefinitions(structText) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. ì£¼ì„ ì œê±° ì²˜ë¦¬ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
            let cleanedText = structText.replace(getRegex('singleLineComment'), '');
            cleanedText = cleanedText.replace(getRegex('blockComment'), '');

            // 2. typedef struct ë¸”ë¡ ì¶”ì¶œ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
            const structPattern = getRegex('structPattern');
            
            // íƒ€ì…ë³„ í¬ê¸° ì •ì˜ (ë°”ì´íŠ¸)
            const typeSizes = {
                'char': 1,
                'unsigned char': 1,
                'short': 2,
                'unsigned short': 2,
                'int': 4,
                'unsigned int': 4,
                'long': 4,
                'unsigned long': 4
            };
            
            // ê²°ê³¼ ë°°ì—´
            const result = [];
            
            // typedef struct ë¸”ë¡ë“¤ ì¶”ì¶œ
            let structMatch;
            while ((structMatch = structPattern.exec(cleanedText)) !== null) {
                const fieldsContent = structMatch[2]; // ì¤‘ê´„í˜¸ ì•ˆì˜ ë‚´ìš©
                const structName = structMatch[3];    // typedef êµ¬ì¡°ì²´ëª… (ë§ˆì§€ë§‰ ì´ë¦„)
                
                // í•„ë“œ ë°°ì—´
                const fields = [];
                
                // í•„ë“œë“¤ ì¶”ì¶œ - ìƒˆë¡œìš´ ì •ê·œì‹ ì¸ìŠ¤í„´ìŠ¤ ì‚¬ìš©
                const fieldPattern = getRegex('fieldPattern');
                let fieldMatch;
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    const unsignedPrefix = fieldMatch[1] ? fieldMatch[1].trim() : '';
                    const baseType = fieldMatch[2];
                    const fieldName = fieldMatch[3];
                    const arraySize = parseInt(fieldMatch[4], 10);
                    
                    // ì „ì²´ íƒ€ì…ëª… êµ¬ì„±
                    const fullType = unsignedPrefix ? unsignedPrefix + ' ' + baseType : baseType;
                    
                    // íƒ€ì…ë³„ í¬ê¸° ê³„ì‚°
                    let typeSize = typeSizes[fullType] || typeSizes[baseType] || 1;
                    
                    // char ì™¸ì˜ íƒ€ì…ì€ ê²½ê³  ì¶œë ¥ (í•˜ì§€ë§Œ char ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬)
                    if (baseType !== 'char') {
                        console.warn('parseStructDefinitions: "' + structName + '"ì˜ í•„ë“œ "' + fieldName + '"ì˜ íƒ€ì… "' + fullType + '"ì€ charë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤. í¬ê¸° ê³„ì‚°ì´ ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                        // char ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬ (ë°°ì—´ í¬ê¸°ë§Œ ì‚¬ìš©)
                        typeSize = 1;
                    }
                    
                    fields.push({
                        name: fieldName,
                        type: fullType,
                        size: arraySize * typeSize
                    });
                }
                
                // ë¹ˆ êµ¬ì¡°ì²´ ê²€ì¦ - fieldsê°€ 0ê°œì¸ êµ¬ì¡°ì²´ëŠ” ì œì™¸
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: êµ¬ì¡°ì²´ "' + structName + '"ì— ìœ íš¨í•œ í•„ë“œê°€ ì—†ì–´ ì œì™¸ë©ë‹ˆë‹¤.');
                    continue;
                }
                
                // êµ¬ì¡°ì²´ ê°ì²´ ì¶”ê°€
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // êµ¬ì¡°ì²´ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ë°˜í™˜
            if (result.length === 0) {
                console.error('parseStructDefinitions: íŒŒì‹±ëœ êµ¬ì¡°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return null;
            }
            
            // íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì¶œë ¥
            console.log('parseStructDefinitions: ' + result.length + 'ê°œì˜ êµ¬ì¡°ì²´ê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            return result;
        }

        /**
         * =====================================================
         * ë‹¨ì¼ C êµ¬ì¡°ì²´ ì •ì˜ íŒŒì‹± í•¨ìˆ˜
         * í•˜ë‚˜ì˜ êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ í•„ë“œ ë°°ì—´ë¡œ ë³€í™˜
         * char íƒ€ì…ë§Œ ì§€ì› (unsigned charë„ charë¡œ ì²˜ë¦¬)
         * =====================================================
         * @param {string} structText - ë‹¨ì¼ C êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´
         * @returns {Object|null} { fields: [...], totalSize: number } ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseStructDefinition(structText) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinition: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. ì£¼ì„ ì œê±°
            // // ì£¼ì„ ì œê±°
            let cleanedText = structText.replace(/\/\/.*$/gm, '');
            // /* */ ì£¼ì„ ì œê±°
            cleanedText = cleanedText.replace(/\/\*[\s\S]*?\*\//g, '');

            // 2. í•„ë“œ ì¶”ì¶œ ì •ê·œì‹
            // char ë˜ëŠ” unsigned char íƒ€ì…ì˜ ë°°ì—´ í•„ë“œ ë§¤ì¹­
            // unsigned charë„ charë¡œ ì²˜ë¦¬
            const fieldPattern = /char\s+(\w+)\s*\[\s*(\d+)\s*\]/g;

            // 3. matchAllë¡œ ëª¨ë“  ë§¤ì¹­ ê²°ê³¼ ìˆœíšŒ
            const matches = cleanedText.matchAll(fieldPattern);
            const fields = [];

            for (const match of matches) {
                const fieldName = match[1];
                const size = parseInt(match[2], 10);

                // í•„ë“œ ì •ë³´ë¥¼ fields ë°°ì—´ì— ì¶”ê°€
                fields.push({
                    name: fieldName,
                    size: size
                });
            }

            // 4. fieldsê°€ ë¹„ì–´ìˆìœ¼ë©´ null ë°˜í™˜
            if (fields.length === 0) {
                console.error('parseStructDefinition: ìœ íš¨í•œ í•„ë“œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return null;
            }

            // 5. ì´ í¬ê¸° ê³„ì‚°
            const totalSize = fields.reduce((sum, f) => sum + f.size, 0);

            // 6. ê²°ê³¼ ë°˜í™˜
            return { fields, totalSize };
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ì •ì˜ ìˆ˜ì§‘ í•¨ìˆ˜
         * ëª¨ë“  êµ¬ì¡°ì²´ ì¹´ë“œì—ì„œ ì •ì˜ë¥¼ ìˆ˜ì§‘í•˜ì—¬ ë°°ì—´ë¡œ ë°˜í™˜
         * =====================================================
         * @returns {Array|null} êµ¬ì¡°ì²´ ì •ë³´ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function collectStructDefinitions() {
            // 1. ëª¨ë“  .struct-card ìš”ì†Œ ì„ íƒ
            const cards = document.querySelectorAll('.struct-card');

            // 2. ë¹ˆ ë°°ì—´ structDefs = []
            const structDefs = [];

            // 3. ê° ì¹´ë“œë§ˆë‹¤ ì²˜ë¦¬
            for (let index = 0; index < cards.length; index++) {
                const card = cards[index];

                // a. .struct-name ê°’ ê°€ì ¸ì˜¤ê¸° (trim)
                const structNameInput = card.querySelector('.struct-name');
                const structName = structNameInput ? structNameInput.value.trim() : '';

                // b. .struct-kubun ê°’ ê°€ì ¸ì˜¤ê¸° (trim)
                const kubunInput = card.querySelector('.struct-kubun');
                const kubunValue = kubunInput ? kubunInput.value.trim() : '';

                // c. .struct-definition ê°’ ê°€ì ¸ì˜¤ê¸° (trim)
                const definitionInput = card.querySelector('.struct-definition');
                const definitionText = definitionInput ? definitionInput.value.trim() : '';

                // d. êµ¬ì¡°ì²´ ì •ì˜ê°€ ë¹„ì–´ìˆìœ¼ë©´ í•´ë‹¹ ì¹´ë“œ ê±´ë„ˆë›°ê¸°
                if (definitionText === '') {
                    continue;
                }

                // e. parseStructDefinition(ì •ì˜ í…ìŠ¤íŠ¸) í˜¸ì¶œ
                const parsed = parseStructDefinition(definitionText);

                // f. íŒŒì‹± ì„±ê³µ ì‹œ structDefsì— ì¶”ê°€
                if (parsed !== null) {
                    structDefs.push({
                        name: structName || ('êµ¬ì¡°ì²´' + (index + 1)),
                        kubun: kubunValue || null,
                        fields: parsed.fields,
                        totalSize: parsed.totalSize
                    });
                } else {
                    // g. íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ í‘œì‹œ í›„ null ë°˜í™˜
                    displayError('êµ¬ì¡°ì²´ #' + (index + 1) + ' íŒŒì‹± ì‹¤íŒ¨', 'struct-result-container');
                    return null;
                }
            }

            // 4. structDefsê°€ ë¹„ì–´ìˆìœ¼ë©´ ì—ëŸ¬ í‘œì‹œ í›„ null ë°˜í™˜
            if (structDefs.length === 0) {
                displayError('ìœ íš¨í•œ êµ¬ì¡°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤', 'struct-result-container');
                return null;
            }

            // 5. êµ¬ë¶„ê°’ ê²€ì¦
            if (structDefs.length >= 2) {
                // êµ¬ì¡°ì²´ê°€ 2ê°œ ì´ìƒì¸ë° kubunì´ nullì¸ ê²ƒì´ ìˆìœ¼ë©´ ê²½ê³ 
                const hasNullKubun = structDefs.some(function(def) {
                    return def.kubun === null;
                });
                
                if (hasNullKubun) {
                    console.warn('collectStructDefinitions: ì—¬ëŸ¬ êµ¬ì¡°ì²´ ì¤‘ êµ¬ë¶„ê°’ì´ ì—†ëŠ” ê²ƒì´ ìˆìŠµë‹ˆë‹¤. ë°ì´í„° ë§¤ì¹­ì´ ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }

                // ì¤‘ë³µëœ kubun ê°’ì´ ìˆìœ¼ë©´ ì—ëŸ¬
                const kubunValues = structDefs
                    .filter(function(def) { return def.kubun !== null; })
                    .map(function(def) { return def.kubun; });
                
                const duplicates = kubunValues.filter(function(value, idx, arr) {
                    return arr.indexOf(value) !== idx;
                });

                if (duplicates.length > 0) {
                    displayError('ì¤‘ë³µëœ êµ¬ë¶„ê°’ì´ ìˆìŠµë‹ˆë‹¤: ' + duplicates.join(', '), 'struct-result-container');
                    return null;
                }
            }

            // 6. structDefs ë°˜í™˜
            console.log('collectStructDefinitions: ' + structDefs.length + 'ê°œì˜ êµ¬ì¡°ì²´ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤.');
            return structDefs;
        }

        /**
         * =====================================================
         * kubun ê¸°ë°˜ êµ¬ì¡°ì²´ ì°¾ê¸° í•¨ìˆ˜
         * ë°ì´í„°ì˜ ì²« ë¶€ë¶„ì„ kubun ê°’ê³¼ ë¹„êµí•˜ì—¬ êµ¬ì¡°ì²´ íƒìƒ‰
         * =====================================================
         * @param {string} data - í˜„ì¬ ìœ„ì¹˜ë¶€í„°ì˜ ë°ì´í„°
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Object|null} ë§¤ì¹­ëœ êµ¬ì¡°ì²´ ë˜ëŠ” null
         */
        function findStructByKubun(data, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!data || !Array.isArray(structDefs) || structDefs.length === 0) {
                return null;
            }

            // 1. kubunì´ nullì´ ì•„ë‹Œ êµ¬ì¡°ì²´ë“¤ì„ ìˆœíšŒí•˜ë©° ë§¤ì¹­ ì‹œë„
            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];
                const kubun = structDef.kubun;

                // kubunì´ nullì´ë©´ ê±´ë„ˆë›°ê¸°
                if (kubun === null || kubun === undefined) {
                    continue;
                }

                // kubun ê¸¸ì´ë§Œí¼ dataì—ì„œ ì¶”ì¶œí•˜ì—¬ ë¹„êµ
                const kubunLength = kubun.length;
                const dataKubun = data.substring(0, kubunLength);

                // ë§¤ì¹­ë˜ë©´ í•´ë‹¹ êµ¬ì¡°ì²´ ë°˜í™˜
                if (dataKubun === kubun) {
                    return structDef;
                }
            }

            // 2. ëª¨ë‘ ì‹¤íŒ¨ ì‹œ kubunì´ nullì¸ êµ¬ì¡°ì²´ ë°˜í™˜ (fallback)
            for (let i = 0; i < structDefs.length; i++) {
                if (structDefs[i].kubun === null || structDefs[i].kubun === undefined) {
                    return structDefs[i];
                }
            }

            // 3. fallbackë„ ì—†ìœ¼ë©´ null ë°˜í™˜
            return null;
        }

        /**
         * =====================================================
         * ë§¤ì¹­ êµ¬ì¡°ì²´ ì°¾ê¸° í•¨ìˆ˜
         * ë°ì´í„° ë¼ì¸ì˜ ì²« ê¸€ìë¡œ ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ íƒìƒ‰
         * =====================================================
         * @param {string} line - ë°ì´í„° ë¼ì¸
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Object|null} ë§¤ì¹­ëœ êµ¬ì¡°ì²´ ë˜ëŠ” null
         */
        function findMatchingStruct(line, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. êµ¬ì¡°ì²´ê°€ 1ê°œë§Œ ìˆìœ¼ë©´ ê·¸ê²ƒ ë°˜í™˜
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ë§¤ì¹­ ë¡œì§
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // í•„ë“œê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // ì²« ë²ˆì§¸ í•„ë“œì˜ sizeë§Œí¼ lineì—ì„œ ì¶”ì¶œ
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // êµ¬ì¡°ì²´ëª…ì—ì„œ êµ¬ë¶„ íŒ¨í„´ ì¶”ì¶œ
                // ì˜ˆ: DHF_H â†’ 'H', DHF_D â†’ 'D', ST_HEADER_1 â†’ '1'
                const structName = structDef.name;
                
                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ (ì–¸ë”ìŠ¤ì½”ì–´ ë’¤ ë˜ëŠ” ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ì)
                let structIdentifier = '';
                
                // ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // ë§ˆì§€ë§‰ ë¶€ë¶„ì´ ë‹¨ì¼ ë¬¸ì ë˜ëŠ” ìˆ«ìì¸ ê²½ìš°
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ìˆ«ì ì¶”ì¶œ ì‹œë„ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
                    const numMatch = lastPart.match(getRegex('trailingNumber'));
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // ë§ˆì§€ë§‰ ë¬¸ì ì‚¬ìš©
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ìì™€ line ì²« ë¬¸ì ë¹„êµ
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // ì²« í•„ë“œ ê°’ê³¼ êµ¬ì¡°ì²´ ì‹ë³„ì ë¹„êµ
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜, ì½˜ì†”ì— ê²½ê³ 
            console.warn('findMatchingStruct: ë¼ì¸ "' + line.substring(0, 20) + '..."ì— ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return null;
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ë°ì´í„° íŒŒì‹± í•¨ìˆ˜
         * í†µ ë°ì´í„°ë¥¼ êµ¬ì¡°ì²´ ì •ì˜ì— ë§ê²Œ íŒŒì‹±
         * =====================================================
         * @param {string} dataText - ë°ì´í„° í…ìŠ¤íŠ¸ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„)
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Array} íŒŒì‹± ê²°ê³¼ ë°°ì—´
         */
        function parseStructData(dataText, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: ë°ì´í„° í…ìŠ¤íŠ¸ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return [];
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: êµ¬ì¡°ì²´ ì •ì˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return [];
            }

            // 1. dataTextë¥¼ ì¤„ë°”ê¿ˆìœ¼ë¡œ split, ë¹ˆ ì¤„ ì œê±°
            const lines = dataText.split('\n').filter(function(line) {
                return line.trim() !== '';
            });

            // 2. ê²°ê³¼ ë°°ì—´ ì´ˆê¸°í™”
            const result = [];

            // 3. ê° ë¼ì¸ë§ˆë‹¤ ì²˜ë¦¬
            lines.forEach(function(line, lineIndex) {
                const lineNumber = lineIndex + 1;

                // findMatchingStruct í—¬í¼ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì°¾ê¸°
                const matchedStruct = findMatchingStruct(line, structDefs);

                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ê°ì²´ ì¶”ê°€
                if (!matchedStruct) {
                    result.push({
                        error: true,
                        lineNumber: lineNumber,
                        line: line,
                        message: 'ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì—†ìŒ'
                    });
                    return; // ë‹¤ìŒ ë¼ì¸ìœ¼ë¡œ continue
                }

                // d. ë§¤ì¹­ëœ êµ¬ì¡°ì²´ fieldsë¥¼ ìˆœíšŒí•˜ë©° íŒŒì‹±
                let currentPos = 0;
                matchedStruct.fields.forEach(function(field) {
                    const startPos = currentPos;
                    const endPos = currentPos + field.size;
                    const value = line.substring(startPos, endPos);

                    result.push({
                        structName: matchedStruct.name,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value: value,
                        lineNumber: lineNumber,
                        startPos: startPos,
                        endPos: endPos
                    });

                    currentPos += field.size;
                });

                // ë¼ì¸ ê¸¸ì´ ê²€ì¦ ê²½ê³ 
                const expectedLength = matchedStruct.fields.reduce(function(sum, f) {
                    return sum + f.size;
                }, 0);
                
                if (line.length !== expectedLength) {
                    console.warn('ë¼ì¸ ' + lineNumber + ': ì˜ˆìƒ ê¸¸ì´ ' + expectedLength + ', ì‹¤ì œ ê¸¸ì´ ' + line.length);
                }
            });

            // 4. ê²°ê³¼ ë°°ì—´ ë°˜í™˜
            console.log('parseStructData: ' + result.length + 'ê°œì˜ í•„ë“œê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            return result;
        }

        /**
         * =====================================================
         * ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
         * ì§€ì •ëœ ì»¨í…Œì´ë„ˆì— ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
         * =====================================================
         * @param {string} message - ì—ëŸ¬ ë©”ì‹œì§€
         * @param {string} targetContainer - íƒ€ê²Ÿ ì»¨í…Œì´ë„ˆ ID (ê¸°ë³¸: result-container)
         */
        function displayError(message, targetContainer) {
            // 1. targetContainer ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’: result-container)
            const containerId = targetContainer || 'result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTMLì„ ì—ëŸ¬ ë©”ì‹œì§€ë¡œ ì„¤ì •
            container.innerHTML = `<div class="error-message">âš ï¸ ${message}</div>`;
        }

        /**
         * =====================================================
         * XML íŒŒì‹± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì í™”
         * =====================================================
         * @param {Array} parsedData - parseTelegramì˜ ê²°ê³¼ ë°°ì—´
         */
        function displayResults(parsedData) {
            // 1. result-container ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
            const container = document.getElementById('result-container');

            // 2. innerHTML ì´ˆê¸°í™”
            container.innerHTML = '';

            // DocumentFragment ìƒì„± - DOM ì¡°ì‘ ìµœì í™”
            const fragment = document.createDocumentFragment();

            // 3. table ìš”ì†Œ ìƒì„±
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead ìƒì„± í›„ tr ì¶”ê°€, th 7ê°œ
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['ìˆœë²ˆ', 'í•„ë“œëª…', 'íƒ€ì…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody ìƒì„±
            const tbody = document.createElement('tbody');

            // 6. parsedData ë°°ì—´ ìˆœíšŒ
            parsedData.forEach(function(item, index) {
                // tr ìƒì„±
                const tr = document.createElement('tr');

                // td 7ê°œ ìƒì„±
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    item.value
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    td.textContent = value;

                    // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ td, ì¦‰ value ì»¬ëŸ¼)
                    if (tdIndex === 6 && typeof value === 'string' && value.trim() === '') {
                        td.classList.add('empty-value');
                    }

                    tr.appendChild(td);
                });

                // tbodyì— tr ì¶”ê°€
                tbody.appendChild(tr);
            });

            // 7. tableì— thead, tbody ì¶”ê°€
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. ë°˜ì‘í˜•ì„ ìœ„í•œ wrapper div ìƒì„±
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. fragmentì— ì¶”ê°€ í›„ í•œ ë²ˆì— DOM ì—…ë°ì´íŠ¸
            fragment.appendChild(wrapper);
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ íŒŒì‹± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì í™”
         * =====================================================
         * @param {Object} parseResult - { records, stats } í˜•ì‹ì˜ íŒŒì‹± ê²°ê³¼
         *   - records: ë ˆì½”ë“œ ë°°ì—´ (ê° ë ˆì½”ë“œ: { recordIndex, structName, kubun, fields })
         *   - stats: í†µê³„ ì •ë³´ { totalBytes, parsedBytes, recordCount, errorBytes }
         */
        function displayStructResults(parseResult) {
            // 1. struct-result-container ì´ˆê¸°í™”
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!parseResult || !parseResult.records) {
                container.innerHTML = '<div class="error-message">âš ï¸ íŒŒì‹± ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            const { records, stats } = parseResult;

            // DocumentFragment ìƒì„± - DOM ì¡°ì‘ ìµœì í™”
            const fragment = document.createDocumentFragment();

            // 2. í†µê³„ ì •ë³´ í‘œì‹œ
            if (stats) {
                const percent = stats.totalBytes > 0 
                    ? ((stats.parsedBytes / stats.totalBytes) * 100).toFixed(1) 
                    : 0;

                const statsDiv = document.createElement('div');
                statsDiv.className = 'parse-stats';

                statsDiv.innerHTML = `
                    <h3>ğŸ“Š íŒŒì‹± í†µê³„</h3>
                    <div class="stats-grid">
                        <div>ì „ì²´: ${stats.totalBytes} bytes</div>
                        <div>íŒŒì‹±: ${stats.parsedBytes} bytes (${percent}%)</div>
                        <div>ë ˆì½”ë“œ: ${stats.recordCount}ê°œ</div>
                        <div>ì˜¤ë¥˜: ${stats.errorBytes} bytes</div>
                    </div>
                `;

                fragment.appendChild(statsDiv);
            }

            // ë ˆì½”ë“œê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ í‘œì‹œ
            if (records.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'error-message';
                noDataDiv.textContent = 'âš ï¸ íŒŒì‹±ëœ ë ˆì½”ë“œê°€ ì—†ìŠµë‹ˆë‹¤.';
                fragment.appendChild(noDataDiv);
                container.appendChild(fragment);
                return;
            }

            // 3. ë ˆì½”ë“œë³„ ê·¸ë£¹í™” (recordIndex ê¸°ì¤€)
            const recordMap = new Map();
            records.forEach(function(record) {
                const idx = record.recordIndex;
                if (!recordMap.has(idx)) {
                    recordMap.set(idx, record);
                }
            });

            // 4. ê° ë ˆì½”ë“œë§ˆë‹¤ í…Œì´ë¸” ìƒì„±
            recordMap.forEach(function(record, recordIndex) {
                // ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ìƒì„±
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';

                // ë ˆì½”ë“œ í—¤ë” ìƒì„±
                const headerDiv = document.createElement('div');
                headerDiv.className = 'record-header';

                // ì œëª©: "ë ˆì½”ë“œ #N - êµ¬ì¡°ì²´ëª…"
                const title = document.createElement('h3');
                title.textContent = 'ë ˆì½”ë“œ #' + (recordIndex + 1) + ' - ' + record.structName;
                headerDiv.appendChild(title);

                // êµ¬ë¶„ê°’ ë°°ì§€
                const kubunBadge = document.createElement('span');
                kubunBadge.className = 'kubun-badge';
                kubunBadge.textContent = 'êµ¬ë¶„: ' + (record.kubun || 'N/A');
                headerDiv.appendChild(kubunBadge);

                // ë³µì‚¬ ë²„íŠ¼
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.setAttribute('data-record', recordIndex);
                copyBtn.textContent = 'ğŸ“‹ ë³µì‚¬';
                headerDiv.appendChild(copyBtn);

                groupDiv.appendChild(headerDiv);

                // í…Œì´ë¸” ìƒì„±
                const table = document.createElement('table');
                table.className = 'result-table';

                // thead ìƒì„±
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['í•„ë“œëª…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody ìƒì„±
                const tbody = document.createElement('tbody');

                // í•´ë‹¹ ë ˆì½”ë“œì˜ ëª¨ë“  í•„ë“œë¥¼ í–‰ìœ¼ë¡œ ì¶”ê°€
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field) {
                        const tr = document.createElement('tr');

                        const values = [
                            field.fieldName,   // í•„ë“œëª…
                            field.fieldSize,   // í¬ê¸°
                            field.startPos,    // ì‹œì‘
                            field.endPos,      // ì¢…ë£Œ
                            field.value        // ê°’
                        ];

                        values.forEach(function(value, tdIndex) {
                            const td = document.createElement('td');
                            td.textContent = value;

                            // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ ì»¬ëŸ¼)
                            if (tdIndex === 4 && typeof value === 'string' && value.trim() === '') {
                                td.classList.add('empty-value');
                            }

                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                    });
                }

                table.appendChild(thead);
                table.appendChild(tbody);

                // ë°˜ì‘í˜• wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // fragmentì— ê·¸ë£¹ ì¶”ê°€
                fragment.appendChild(groupDiv);
            });

            // í•œ ë²ˆì— DOM ì—…ë°ì´íŠ¸
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜
         * ë‹¤ì–‘í•œ ì…ë ¥ ìƒí™©ì— ëŒ€í•œ ìë™í™”ëœ í…ŒìŠ¤íŠ¸
         * =====================================================
         * @returns {Object} í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê°ì²´ { passed, failed, results }
         */
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            /**
             * ê°œë³„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í—¬í¼
             */
            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        passed++;
                        results.push({ name: name, passed: true });
                    } else {
                        failed++;
                        results.push({ name: name, passed: false, reason: result || 'ì‹¤íŒ¨' });
                    }
                } catch (e) {
                    failed++;
                    results.push({ name: name, passed: false, reason: e.message });
                }
            }

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 1: êµ¬ì¡°ì²´ 1ê°œë§Œ ìˆëŠ” ê²½ìš°
            // =========================================
            test('êµ¬ì¡°ì²´ 1ê°œë§Œ ìˆëŠ” ê²½ìš°', function() {
                const structDef = `typedef struct {
                    char field1[5];
                    char field2[10];
                } SingleStruct;`;
                
                const data = 'HELLO1234567890';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                
                const parsed = parseStructData(data, defs);
                if (parsed.length !== 2) return 'í•„ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (parsed[0].value !== 'HELLO') return 'ì²« ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== '1234567890') return 'ë‘ ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 2: êµ¬ì¡°ì²´ 5ê°œ ì´ìƒì¸ ê²½ìš°
            // =========================================
            test('êµ¬ì¡°ì²´ 5ê°œ ì´ìƒì¸ ê²½ìš°', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Type_A;
                    typedef struct { char type[1]; char data[4]; } Type_B;
                    typedef struct { char type[1]; char data[4]; } Type_C;
                    typedef struct { char type[1]; char data[4]; } Type_D;
                    typedef struct { char type[1]; char data[4]; } Type_E;
                `;
                
                const data = 'AAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 5) return 'êµ¬ì¡°ì²´ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + (defs ? defs.length : 0);
                
                const parsed = parseStructData(data, defs);
                // 5ì¤„ Ã— 2í•„ë“œ = 10ê°œ í•„ë“œ
                if (parsed.length !== 10) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + parsed.length;
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 3: ë°ì´í„° ë¼ì¸ 100ê°œ ì´ìƒ
            // =========================================
            test('ë°ì´í„° ë¼ì¸ 100ê°œ ì´ìƒ', function() {
                const structDef = `typedef struct { char id[4]; char val[6]; } DataLine;`;
                
                // 100ê°œ ë¼ì¸ ìƒì„±
                let dataLines = [];
                for (let i = 0; i < 100; i++) {
                    const id = ('0000' + i).slice(-4);
                    dataLines.push(id + 'VALUE1');
                }
                const data = dataLines.join('\n');
                
                const defs = parseStructDefinitions(structDef);
                if (!defs) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                
                const parsed = parseStructData(data, defs);
                // 100ì¤„ Ã— 2í•„ë“œ = 200ê°œ í•„ë“œ
                if (parsed.length !== 200) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + parsed.length;
                
                // ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ ë¼ì¸ ê²€ì¦
                if (parsed[0].value !== '0000') return 'ì²« ë¼ì¸ ì²« í•„ë“œ ë¶ˆì¼ì¹˜';
                if (parsed[198].value !== '0099') return 'ë§ˆì§€ë§‰ ë¼ì¸ ì²« í•„ë“œ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 4: ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„°
            // =========================================
            test('ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„° (ì§§ìŒ)', function() {
                const structDef = `typedef struct { char field1[10]; char field2[10]; } TestStruct;`;
                const data = 'SHORTDATA'; // 9ì (ì˜ˆìƒ: 20ì)
                
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData(data, defs);
                
                // íŒŒì‹±ì€ ì„±ê³µí•´ì•¼ í•¨ (ë¶€ì¡±í•œ ë¶€ë¶„ì€ ë¹ˆ ë¬¸ìì—´)
                if (parsed.length !== 2) return 'í•„ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (parsed[0].value !== 'SHORTDATA') return 'ì²« ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== '') return 'ë‘ ë²ˆì§¸ í•„ë“œê°€ ë¹ˆ ë¬¸ìì—´ì´ì–´ì•¼ í•¨';
                
                return true;
            });

            test('ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„° (ê¹€)', function() {
                const structDef = `typedef struct { char field1[5]; } ShortStruct;`;
                const data = 'EXTRALONG_DATA_HERE'; // ì˜ˆìƒë³´ë‹¤ ê¸´ ë°ì´í„°
                
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData(data, defs);
                
                // ì •ì˜ëœ í•„ë“œê¹Œì§€ë§Œ íŒŒì‹±
                if (parsed.length !== 1) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                if (parsed[0].value !== 'EXTRA') return 'ê°’ ë¶ˆì¼ì¹˜: ' + parsed[0].value;
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 5: ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²•
            // =========================================
            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - typedef ëˆ„ë½', function() {
                const structDef = `struct { char field[5]; } BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // nullì„ ë°˜í™˜í•´ì•¼ í•¨
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - ì¤‘ê´„í˜¸ ëˆ„ë½', function() {
                const structDef = `typedef struct char field[5]; BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - ì„¸ë¯¸ì½œë¡  ëˆ„ë½', function() {
                const structDef = `typedef struct { char field[5]; } BadStruct`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ë¹ˆ êµ¬ì¡°ì²´ (í•„ë“œ ì—†ìŒ)', function() {
                const structDef = `typedef struct { } EmptyStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // ë¹ˆ êµ¬ì¡°ì²´ëŠ” ì œì™¸ë˜ë¯€ë¡œ null ë°˜í™˜
                if (defs !== null) return 'ë¹ˆ êµ¬ì¡°ì²´ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 6: ë¹ˆ ì…ë ¥
            // =========================================
            test('ë¹ˆ ì…ë ¥ - êµ¬ì¡°ì²´ ì •ì˜', function() {
                const defs = parseStructDefinitions('');
                if (defs !== null) return 'ë¹ˆ ì…ë ¥ì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            test('ë¹ˆ ì…ë ¥ - ë°ì´í„°', function() {
                const structDef = `typedef struct { char field[5]; } TestStruct;`;
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData('', defs);
                
                if (parsed.length !== 0) return 'ë¹ˆ ë°ì´í„°ì¸ë° ê²°ê³¼ ìˆìŒ';
                return true;
            });

            test('ê³µë°±ë§Œ ìˆëŠ” ì…ë ¥', function() {
                const defs = parseStructDefinitions('   \n\t\n   ');
                if (defs !== null) return 'ê³µë°±ë§Œ ìˆëŠ”ë° íŒŒì‹±ë¨';
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 7: ì£¼ì„ ì²˜ë¦¬
            // =========================================
            test('í•œì¤„ ì£¼ì„ ì²˜ë¦¬', function() {
                const structDef = `typedef struct {
                    // ì´ê²ƒì€ ì£¼ì„ì…ë‹ˆë‹¤
                    char field1[5]; // í•„ë“œ ì„¤ëª…
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                if (defs[0].fields.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            test('ë¸”ë¡ ì£¼ì„ ì²˜ë¦¬', function() {
                const structDef = `typedef struct {
                    /* ë¸”ë¡ ì£¼ì„
                       ì—¬ëŸ¬ ì¤„ */
                    char field1[5];
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                if (defs[0].fields.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 8: êµ¬ì¡°ì²´ ë§¤ì¹­ ë¡œì§
            // =========================================
            test('êµ¬ì¡°ì²´ ë§¤ì¹­ - ì²« ê¸€ì ê¸°ì¤€', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Record_H;
                    typedef struct { char type[1]; char data[9]; } Record_D;
                `;
                
                const data = 'H1234\nD123456789';
                
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData(data, defs);
                
                // H ë¼ì¸: 2í•„ë“œ, D ë¼ì¸: 2í•„ë“œ = 4ê°œ
                if (parsed.length !== 4) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + parsed.length;
                
                // ì²« ë¼ì¸ì€ Record_H
                if (parsed[0].structName !== 'Record_H') return 'ì²« ë¼ì¸ êµ¬ì¡°ì²´ ë§¤ì¹­ ì‹¤íŒ¨';
                // ë‘ ë²ˆì§¸ ë¼ì¸ì€ Record_D
                if (parsed[2].structName !== 'Record_D') return 'ë‘ ë²ˆì§¸ ë¼ì¸ êµ¬ì¡°ì²´ ë§¤ì¹­ ì‹¤íŒ¨';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 9: XML íŒŒì‹±
            // =========================================
            test('XML íŒŒì‹± - ì •ìƒ', function() {
                const xml = `<packet>
                    <col id="field1" type="X" size="5" />
                    <col id="field2" type="N" size="10" />
                </packet>`;
                
                const spec = parseXMLSpec(xml);
                if (!spec || spec.length !== 2) return 'XML íŒŒì‹± ì‹¤íŒ¨';
                if (spec[0].id !== 'field1') return 'ì²« ë²ˆì§¸ í•„ë“œ ID ë¶ˆì¼ì¹˜';
                if (spec[1].size !== 10) return 'ë‘ ë²ˆì§¸ í•„ë“œ í¬ê¸° ë¶ˆì¼ì¹˜';
                
                return true;
            });

            test('XML íŒŒì‹± - ë¹ˆ ì…ë ¥', function() {
                const spec = parseXMLSpec('');
                if (spec !== null) return 'ë¹ˆ ì…ë ¥ì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            test('XML íŒŒì‹± - ì˜ëª»ëœ í˜•ì‹', function() {
                const spec = parseXMLSpec('<invalid><unclosed>');
                if (spec !== null) return 'ì˜ëª»ëœ XMLì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 10: í†µì „ë¬¸ íŒŒì‹±
            // =========================================
            test('í†µì „ë¬¸ íŒŒì‹± - ì •ìƒ', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="3" />
                    <col id="name" type="X" size="5" />
                </packet>`;
                const telegram = 'ABCHELLO';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                if (parsed[0].value !== 'ABC') return 'ì²« ë²ˆì§¸ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== 'HELLO') return 'ë‘ ë²ˆì§¸ ê°’ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            return { passed: passed, failed: failed, results: results };
        }

        /**
         * =====================================================
         * í…ŒìŠ¤íŠ¸ ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ UIì— í‘œì‹œ
         * =====================================================
         * @param {Object} testResult - runTests()ì˜ ë°˜í™˜ê°’
         */
        function displayTestResults(testResult) {
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            const div = document.createElement('div');
            div.className = 'test-results ' + (testResult.failed === 0 ? 'success' : 'failure');

            const title = document.createElement('h3');
            title.textContent = 'í…ŒìŠ¤íŠ¸ ê²°ê³¼: ' + testResult.passed + 'ê°œ í†µê³¼, ' + testResult.failed + 'ê°œ ì‹¤íŒ¨';
            div.appendChild(title);

            testResult.results.forEach(function(result) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                if (result.passed) {
                    item.innerHTML = '<span class="test-pass">âœ“</span> ' + result.name;
                } else {
                    item.innerHTML = '<span class="test-fail">âœ—</span> ' + result.name + 
                                   ' <small>(' + result.reason + ')</small>';
                }
                
                div.appendChild(item);
            });

            container.appendChild(div);
        }

        // =========================================
        // DOMContentLoaded ì´ë²¤íŠ¸ - ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        // =========================================
        document.addEventListener('DOMContentLoaded', function() {
            // =========================================
            // êµ¬ì¡°ì²´ ì¹´ë“œ ì´ˆê¸°í™” - ì²« ë²ˆì§¸ ì¹´ë“œ ìë™ ì¶”ê°€
            // =========================================
            const structContainer = document.getElementById('struct-definitions-container');
            structContainer.appendChild(createStructCard(0));
            structCardIndex = 1;

            // =========================================
            // êµ¬ì¡°ì²´ ì¶”ê°€ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            // =========================================
            document.getElementById('add-struct-btn').addEventListener('click', function() {
                const newCard = createStructCard(structCardIndex);
                structContainer.appendChild(newCard);
                structCardIndex++;
            });

            // =========================================
            // êµ¬ì¡°ì²´ ì‚­ì œ ë²„íŠ¼ ì´ë²¤íŠ¸ ìœ„ì„
            // =========================================
            structContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-struct-btn')) {
                    // í´ë¦­ëœ ë²„íŠ¼ì˜ ë¶€ëª¨ .struct-card ì°¾ê¸°
                    const card = e.target.closest('.struct-card');
                    if (!card) return;

                    // í™•ì¸ ëŒ€í™”ìƒì
                    if (confirm('ì´ êµ¬ì¡°ì²´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        // í•´ë‹¹ ì¹´ë“œ ì œê±°
                        card.remove();

                        // ë‚¨ì€ ì¹´ë“œê°€ 0ê°œë©´ structCardIndexë¥¼ 0ìœ¼ë¡œ ë¦¬ì…‹
                        const remainingCards = structContainer.querySelectorAll('.struct-card');
                        if (remainingCards.length === 0) {
                            structCardIndex = 0;
                        }
                    }
                }
            });

            // ë„ì›€ë§ í† ê¸€ ì´ë²¤íŠ¸
            const helpToggle = document.querySelector('.help-toggle');
            const helpContent = document.querySelector('.help-content');
            
            if (helpToggle && helpContent) {
                helpToggle.addEventListener('click', function() {
                    helpToggle.classList.toggle('expanded');
                    helpContent.classList.toggle('expanded');
                });
            }

            // íƒ­ ì „í™˜ ì´ë²¤íŠ¸
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // ëª¨ë“  íƒ­ ë²„íŠ¼ì—ì„œ active ì œê±°
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // í´ë¦­ëœ ë²„íŠ¼ì— active ì¶”ê°€
                    this.classList.add('active');

                    // ëª¨ë“  íƒ­ ì½˜í…ì¸  ìˆ¨ê¸°ê¸°
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // ì„ íƒëœ íƒ­ ì½˜í…ì¸  í‘œì‹œ
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML ê·œê²© ìƒ˜í”Œ ì„¤ì •
                const sampleXml = `<packet id="ì†¡ê¸ˆì „ë¬¸" default=" ">
  <col id="í—¤ë”ì‹œì‘" type="X" size="6" />
  <col id="ê±°ë˜êµ¬ë¶„" type="X" size="2" />
  <col id="ê³„ì¢Œë²ˆí˜¸" type="N" size="12" />
  <col id="ì†¡ê¸ˆì•¡" type="N" size="15" />
  <col id="ë°›ëŠ”ì‚¬ëŒ" type="X" size="20" />
</packet>`;
                
                // í†µì „ë¬¸ ìƒ˜í”Œ ì„¤ì • (ì •í™•íˆ 55ì)
                const sampleTelegram = 'HEADER01123456789012000000000100000í™ê¸¸ë™              ';
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-inputê³¼ telegram-input ê°’ ê°€ì ¸ì˜¤ê¸°
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. ë‘˜ ë‹¤ trim()í•´ì„œ ë¹ˆ ë¬¸ìì—´ì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”");
                    return;
                }

                // 3. parseXMLSpec í˜¸ì¶œ, ê²°ê³¼ê°€ nullì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML íŒŒì‹± ì‹¤íŒ¨: í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”");
                    return;
                }

                // 4. parseTelegram í˜¸ì¶œ
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults í˜¸ì¶œ
                displayResults(parsedData);
            });

            // ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // êµ¬ì¡°ì²´ ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // 1. ê¸°ì¡´ ëª¨ë“  êµ¬ì¡°ì²´ ì¹´ë“œ ì‚­ì œ
                structContainer.innerHTML = '';
                
                // 2. structCardIndex = 0 ë¦¬ì…‹
                structCardIndex = 0;

                // 3. êµ¬ì¡°ì²´ 3ê°œ ì¶”ê°€
                const sampleStructs = [
                    {
                        // ì¹´ë“œ 1: DHF_H
                        name: 'DHF_H',
                        kubun: 'H',
                        definition: `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
  char crlf[2];
} DHF_H;`
                    },
                    {
                        // ì¹´ë“œ 2: DHF_D
                        name: 'DHF_D',
                        kubun: 'D',
                        definition: `typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
  char crlf[2];
} DHF_D;`
                    },
                    {
                        // ì¹´ë“œ 3: DHF_T
                        name: 'DHF_T',
                        kubun: 'T',
                        definition: `typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
  char crlf[2];
} DHF_T;`
                    }
                ];

                // ê° ìƒ˜í”Œ êµ¬ì¡°ì²´ë§ˆë‹¤ ì¹´ë“œ ìƒì„±
                sampleStructs.forEach(function(sample) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);
                    
                    // ì¹´ë“œ ë‚´ë¶€ ì…ë ¥ í•„ë“œì— ê°’ ì„¤ì •
                    card.querySelector('.struct-name').value = sample.name;
                    card.querySelector('.struct-kubun').value = sample.kubun;
                    card.querySelector('.struct-definition').value = sample.definition;
                    
                    structCardIndex++;
                });

                // 4. ë°ì´í„° ì„¤ì •
                // DHF_H: 1+2+7+2 = 12 bytes
                // DHF_D: 1+16+20+2 = 39 bytes
                // DHF_T: 1+10+20+2 = 33 bytes
                // ì´ 123 bytes (ì¤„ë°”ê¿ˆ ì œê±° ì‹œ)
                const sampleData = `H88123125235XX
D7092357029352901234567890123456789012XX
D2730957203950001234567890123456789012XX
T9710249709001234567890123456789012XX`;

                document.getElementById('struct-data').value = sampleData;
            });

            // êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                // 1. ëª¨ë“  ì¹´ë“œì—ì„œ êµ¬ì¡°ì²´ ì •ì˜ ìˆ˜ì§‘
                const cards = structContainer.querySelectorAll('.struct-card');
                
                if (cards.length === 0) {
                    displayError('êµ¬ì¡°ì²´ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.', 'struct-result-container');
                    return;
                }

                // ì¹´ë“œë³„ë¡œ êµ¬ì¡°ì²´ ì •ì˜ì™€ kubun ê°’ì„ ìˆ˜ì§‘
                const structInfos = [];
                cards.forEach(function(card, idx) {
                    const definition = card.querySelector('.struct-definition').value.trim();
                    const kubun = card.querySelector('.struct-kubun').value.trim();
                    const name = card.querySelector('.struct-name').value.trim();
                    if (definition) {
                        structInfos.push({ definition, kubun: kubun || null, name: name || ('êµ¬ì¡°ì²´' + (idx + 1)) });
                    }
                });

                // ëª¨ë“  ì¹´ë“œì˜ êµ¬ì¡°ì²´ ì •ì˜ë¥¼ í•©ì¹¨
                const combinedStructDefs = structInfos.map(function(info) {
                    return info.definition;
                }).join('\n');

                const structDefInput = combinedStructDefs.trim();
                
                // 2. struct-data ê°’ ê°€ì ¸ì˜¤ê¸°, trim
                const dataInput = document.getElementById('struct-data').value.trim();

                // 3. ë‘˜ ë‹¤ ë¹„ì–´ìˆìœ¼ë©´ displayError í˜¸ì¶œ
                if (structDefInput === '' || dataInput === '') {
                    displayError('ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”', 'struct-result-container');
                    return;
                }

                // 4. parseStructDefinitions í˜¸ì¶œ, nullì´ë©´ displayError
                const structDefs = parseStructDefinitions(structDefInput);
                if (structDefs === null) {
                    displayError('êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨', 'struct-result-container');
                    return;
                }

                // êµ¬ì¡°ì²´ ì •ì˜ì— kubun ì •ë³´ ë§¤í•‘
                structDefs.forEach(function(structDef, idx) {
                    const matchingInfo = structInfos.find(function(info) {
                        return info.definition.indexOf(structDef.name) !== -1;
                    });
                    if (matchingInfo) {
                        structDef.kubun = matchingInfo.kubun;
                    }
                });

                // 5. íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì½˜ì†” ì¶œë ¥
                console.log('íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜: ' + structDefs.length);

                // 6. parseStructData í˜¸ì¶œ
                const parsedData = parseStructData(dataInput, structDefs);

                // 7. parsedDataë¥¼ { records, stats } í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                const totalBytes = dataInput.replace(/\n/g, '').length;
                let parsedBytes = 0;
                let errorBytes = 0;

                // ë ˆì½”ë“œë³„ë¡œ ê·¸ë£¹í™” (lineNumberë¥¼ recordIndexë¡œ ì‚¬ìš©)
                const recordMap = new Map();
                
                parsedData.forEach(function(item) {
                    if (item.error) {
                        errorBytes += item.line ? item.line.length : 0;
                        return;
                    }

                    const recordIndex = item.lineNumber - 1; // 0-based index
                    
                    if (!recordMap.has(recordIndex)) {
                        // í•´ë‹¹ êµ¬ì¡°ì²´ì˜ kubun ì°¾ê¸°
                        const matchedStruct = structDefs.find(function(s) {
                            return s.name === item.structName;
                        });
                        
                        recordMap.set(recordIndex, {
                            recordIndex: recordIndex,
                            structName: item.structName,
                            kubun: matchedStruct ? matchedStruct.kubun : null,
                            fields: []
                        });
                    }

                    recordMap.get(recordIndex).fields.push({
                        fieldName: item.fieldName,
                        fieldSize: item.fieldSize,
                        startPos: item.startPos,
                        endPos: item.endPos,
                        value: item.value
                    });

                    parsedBytes += item.fieldSize;
                });

                const records = Array.from(recordMap.values());

                const parseResult = {
                    records: records,
                    stats: {
                        totalBytes: totalBytes,
                        parsedBytes: parsedBytes,
                        recordCount: records.length,
                        errorBytes: errorBytes
                    }
                };

                // 8. displayStructResults í˜¸ì¶œ
                displayStructResults(parseResult);
            });

            // êµ¬ì¡°ì²´ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                // ëª¨ë“  ì¹´ë“œ ì‚­ì œ í›„ ìƒˆ ì¹´ë“œ í•˜ë‚˜ ì¶”ê°€
                structContainer.innerHTML = '';
                structCardIndex = 0;
                structContainer.appendChild(createStructCard(0));
                structCardIndex = 1;
                
                document.getElementById('struct-data').value = '';
                document.getElementById('struct-result-container').innerHTML = '';
            });

            // í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ë²„íŠ¼ì´ ì¡´ì¬í•  ê²½ìš°ì—ë§Œ)
            const runTestsBtn = document.getElementById('run-tests-btn');
            if (runTestsBtn) {
                runTestsBtn.addEventListener('click', function() {
                    const testResult = runTests();
                    displayTestResults(testResult);
                });
            }

            // ë³µì‚¬ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ì´ë²¤íŠ¸ ìœ„ì„ ì‚¬ìš©)
            document.getElementById('struct-result-container').addEventListener('click', function(e) {
                // í´ë¦­ëœ ìš”ì†Œê°€ ë³µì‚¬ ë²„íŠ¼ì¸ì§€ í™•ì¸ (copy-result-btn ë˜ëŠ” copy-record-btn)
                if (!e.target.classList.contains('copy-result-btn') && !e.target.classList.contains('copy-record-btn')) {
                    return;
                }

                const btn = e.target;

                // í•´ë‹¹ ë ˆì½”ë“œì˜ ê·¸ë£¹ ì°¾ê¸°
                const groupDiv = btn.closest('.struct-result-group');
                if (!groupDiv) {
                    return;
                }

                // í…Œì´ë¸”ì˜ tbodyì—ì„œ ëª¨ë“  í–‰ ê°€ì ¸ì˜¤ê¸°
                const tbody = groupDiv.querySelector('tbody');
                if (!tbody) {
                    return;
                }

                const rows = tbody.querySelectorAll('tr');
                
                // TSV í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (í•„ë“œëª…\tê°’)
                const tsvLines = [];
                rows.forEach(function(row) {
                    const cells = row.querySelectorAll('td');
                    // ìƒˆ í˜•ì‹: 5ê°œ ì»¬ëŸ¼ (í•„ë“œëª…, í¬ê¸°, ì‹œì‘, ì¢…ë£Œ, ê°’)
                    if (cells.length >= 5) {
                        const fieldName = cells[0].textContent;  // í•„ë“œëª…
                        const value = cells[4].textContent;       // ê°’
                        tsvLines.push(fieldName + '\t' + value);
                    }
                });

                const tsvText = tsvLines.join('\n');

                // í´ë¦½ë³´ë“œì— ë³µì‚¬
                navigator.clipboard.writeText(tsvText).then(function() {
                    // ë³µì‚¬ ì„±ê³µ ì‹œ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì„ì‹œ ë³€ê²½
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ“ ë³µì‚¬ë¨';
                    
                    // 2ì´ˆ í›„ ì›ë˜ í…ìŠ¤íŠ¸ë¡œ ë³µì›
                    setTimeout(function() {
                        btn.textContent = originalText;
                    }, 2000);
                }).catch(function(err) {
                    console.error('í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:', err);
                    alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                });
            });
        });
    </script>
</body>
</html>
