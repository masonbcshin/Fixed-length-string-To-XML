<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>í†µì „ë¬¸ íŒŒì„œ</title>
    <style>
        /**
         * =====================================================
         * í†µì „ë¬¸ íŒŒì„œ ìŠ¤íƒ€ì¼ì‹œíŠ¸
         * =====================================================
         * ì£¼ìš” ê¸°ëŠ¥:
         * 1. XML íŒŒì‹± íƒ­ - XML ê·œê²© ê¸°ë°˜ í†µì „ë¬¸ íŒŒì‹±
         * 2. C êµ¬ì¡°ì²´ íŒŒì‹± íƒ­ - C êµ¬ì¡°ì²´ ê¸°ë°˜ íŒŒì‹±
         * 
         * UX ê¸°ëŠ¥:
         * - êµ¬ì¡°ì²´ ì¹´ë“œ ì ‘ê¸°/í¼ì¹˜ê¸° (â–¼ â†” â–¶)
         * - ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì¹´ë“œ ì¬ì •ë ¬
         * - ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ìë™ ì €ì¥/ë³µì›
         * - ë‹¤í¬ëª¨ë“œ ì§€ì›
         * - í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ (Ctrl+Enter, Ctrl+N)
         * =====================================================
         */

        /* =====================================================
         * ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ìŠ¤íƒ€ì¼
         * ===================================================== */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        /* ì…ë ¥ ì˜ì—­ */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* =====================================================
         * ê²°ê³¼ í‘œì‹œ ì˜ì—­
         * ===================================================== */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        #result-table, .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td,
        .result-table th, .result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th, .result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even),
        .result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover,
        .result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7),
        .result-table td:last-child {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* ë°˜ì‘í˜• í…Œì´ë¸” ë˜í¼ */
        .table-wrapper {
            overflow-x: auto;
        }

        /* ë²„íŠ¼ ê·¸ë£¹ */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* ì—ëŸ¬ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* íŒŒì‹± ì—ëŸ¬ ìŠ¤íƒ€ì¼ */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* =====================================================
         * íƒ­ ë„¤ë¹„ê²Œì´ì…˜ ìŠ¤íƒ€ì¼
         * ===================================================== */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* êµ¬ì¡°ì²´ ê²°ê³¼ ê·¸ë£¹ ìŠ¤íƒ€ì¼ */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* êµ¬ì¡°ì²´ ìš”ì•½ ì •ë³´ ìŠ¤íƒ€ì¼ */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* ë³µì‚¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .copy-result-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .copy-result-btn:hover {
            background: #1e7e34;
        }

        /* =====================================================
         * ë„ì›€ë§ ì„¹ì…˜ (ì ‘ê¸°/í¼ì¹˜ê¸°)
         * ===================================================== */
        .help-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .help-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-toggle:hover {
            background: #dee2e6;
        }

        .help-toggle-icon {
            transition: transform 0.3s ease;
        }

        .help-toggle.expanded .help-toggle-icon {
            transform: rotate(180deg);
        }

        .help-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .help-content.expanded {
            padding: 16px;
            max-height: 500px;
        }

        .help-content h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .help-content p {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        .help-content ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }

        .help-content li {
            margin: 5px 0;
            color: #666;
            font-size: 13px;
        }

        .help-content code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .help-content pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin: 10px 0;
        }

        /* í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #run-tests-btn {
            background: #6f42c1;
            margin-left: auto;
        }

        #run-tests-btn:hover {
            background: #5a32a3;
        }

        /* í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìŠ¤íƒ€ì¼ */
        .test-results {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .test-results.success {
            background: #d4edda;
            border: 1px solid #28a745;
        }

        .test-results.failure {
            background: #f8d7da;
            border: 1px solid #dc3545;
        }

        .test-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-pass {
            color: #28a745;
        }

        .test-fail {
            color: #dc3545;
        }

        /* ì„¹ì…˜ í—¤ë” ìŠ¤íƒ€ì¼ */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        .header-options {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .option-checkbox {
            background: #e7f3ff;
            padding: 8px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-checkbox:hover {
            background: #cce5ff;
        }

        .option-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .option-description {
            background: #f8f9fa;
            padding: 10px 15px;
            border-left: 4px solid #6c757d;
            margin-bottom: 15px;
            color: #495057;
        }

        .option-description small {
            font-size: 13px;
            line-height: 1.6;
        }

        /* =====================================================
         * êµ¬ì¡°ì²´ ì •ì˜ ì˜ì—­
         * ===================================================== */
        #add-struct-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #add-struct-btn:hover {
            background: #138496;
        }

        /* êµ¬ì¡°ì²´ ì •ì˜ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #struct-definitions-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* êµ¬ì¡°ì²´ ì¹´ë“œ ìŠ¤íƒ€ì¼ */
        .struct-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        /* ë“œë˜ê·¸ ì•¤ ë“œë¡­ ìŠ¤íƒ€ì¼ */
        .struct-card[draggable="true"] {
            cursor: grab;
        }

        .struct-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .struct-card.drag-over {
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        .struct-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .struct-card-header:hover {
            background: rgba(0, 0, 0, 0.02);
            margin: -5px -5px 10px -5px;
            padding: 5px 5px 15px 5px;
            border-radius: 5px 5px 0 0;
        }

        .struct-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapse-icon {
            font-size: 12px;
            color: #6c757d;
            transition: transform 0.3s ease;
            width: 16px;
            text-align: center;
        }

        .struct-card.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .struct-number {
            font-weight: bold;
            color: #495057;
            font-size: 16px;
        }

        /* ì ‘íŒ ìƒíƒœì˜ êµ¬ì¡°ì²´ëª… ë¯¸ë¦¬ë³´ê¸° */
        .struct-preview {
            font-size: 14px;
            color: #6c757d;
            margin-left: 10px;
            font-style: italic;
        }

        .struct-card-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drag-handle {
            cursor: grab;
            color: #adb5bd;
            font-size: 18px;
            padding: 4px 8px;
        }

        .drag-handle:hover {
            color: #6c757d;
        }

        .remove-struct-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .remove-struct-btn:hover {
            background: #c82333;
        }

        /* ì¹´ë“œ ë³¸ë¬¸ ì ‘ê¸°/í¼ì¹˜ê¸° */
        .struct-card-body {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 1;
        }

        .struct-card.collapsed .struct-card-body {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .struct-card-body .input-row {
            margin-bottom: 12px;
        }

        .struct-card-body .input-row label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .struct-card-body .input-row input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .struct-card-body .input-row small {
            color: #6c757d;
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }

        .struct-card-body .input-row textarea {
            width: 100%;
            box-sizing: border-box;
        }

        /* ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë³µì› ì•Œë¦¼ ìŠ¤íƒ€ì¼ */
        .restore-notification {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .restore-notification-text {
            color: #1565c0;
            font-size: 14px;
        }

        .restore-notification-actions {
            display: flex;
            gap: 10px;
        }

        .restore-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .restore-btn.primary {
            background: #1976d2;
            color: white;
        }

        .restore-btn.primary:hover {
            background: #1565c0;
        }

        .restore-btn.secondary {
            background: #e0e0e0;
            color: #424242;
        }

        .restore-btn.secondary:hover {
            background: #bdbdbd;
        }

        /* ë‹¨ì¶•í‚¤ íŒíŠ¸ ìŠ¤íƒ€ì¼ */
        .shortcut-hint {
            font-size: 11px;
            color: #6c757d;
            margin-left: 5px;
        }

        /* ë‹¤í¬ëª¨ë“œ í† ê¸€ ë²„íŠ¼ */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: #e0e0e0;
        }

        /* íŒŒì‹± ì„¤ì • ì •ë³´ ìŠ¤íƒ€ì¼ */
        .parse-settings-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .parse-settings-info h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 15px;
        }

        .setting-item {
            display: flex;
            margin-bottom: 8px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-weight: bold;
            width: 150px;
        }

        .setting-value {
            padding: 4px 10px;
            border-radius: 4px;
        }

        .setting-value.enabled {
            background: #d4edda;
            color: #155724;
        }

        .setting-value.disabled {
            background: #f8d7da;
            color: #721c24;
        }

        /* íŒŒì‹± í†µê³„ ìŠ¤íƒ€ì¼ */
        .parse-stats {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .parse-stats h3 {
            margin: 0 0 12px 0;
            color: #1565c0;
            font-size: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stats-grid > div {
            background: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
        }

        /* ë ˆì½”ë“œ í—¤ë” ìŠ¤íƒ€ì¼ */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        /* êµ¬ë¶„ê°’ ë°°ì§€ ìŠ¤íƒ€ì¼ */
        .kubun-badge {
            background: #6610f2;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }

        /* ë ˆì½”ë“œ ë³µì‚¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .copy-record-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .copy-record-btn:hover {
            background: #1e7e34;
        }

        /* ìë™ ì„¤ì • í•„ë“œ ìŠ¤íƒ€ì¼ (CRLF ë“±) */
        .auto-field {
            background: #e9ecef;
            cursor: not-allowed;
            color: #6c757d;
            font-style: italic;
        }

        /* ì‹ ê·œ ë ˆì½”ë“œ í¼ í•„ë“œ ì…ë ¥ ìŠ¤íƒ€ì¼ */
        .new-field-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .new-field-input:focus {
            border-color: #80bdff;
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        /* ë¯¸ë¦¬ë³´ê¸° ì…€ ìŠ¤íƒ€ì¼ */
        .preview-cell {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            color: #495057;
        }

        /* ëª¨ë°”ì¼ ëŒ€ì‘ */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .record-header {
                flex-wrap: wrap;
                gap: 8px;
            }

            .theme-toggle {
                top: 10px;
                right: 10px;
                width: 35px;
                height: 35px;
            }
        }

        /* =====================================================
         * ë‹¤í¬ëª¨ë“œ ìŠ¤íƒ€ì¼
         * ===================================================== */
        body.dark-mode {
            background-color: #1a1a2e;
            color: #e0e0e0;
        }

        body.dark-mode h1 {
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .tab-btn.active {
            background: #1a1a2e;
            border-bottom-color: #1a1a2e;
            color: #64b5f6;
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"] {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode textarea::placeholder,
        body.dark-mode input::placeholder {
            color: #888;
        }

        body.dark-mode .struct-card {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .struct-card-header:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .struct-number {
            color: #e0e0e0;
        }

        body.dark-mode .struct-preview {
            color: #aaa;
        }

        body.dark-mode .struct-card-body .input-row label {
            color: #e0e0e0;
        }

        body.dark-mode .struct-card-body .input-row small {
            color: #aaa;
        }

        body.dark-mode .help-section {
            background: #2d2d44;
            border-color: #3d3d5c;
        }

        body.dark-mode .help-toggle {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .help-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .help-content {
            color: #ccc;
        }

        body.dark-mode .help-content h4 {
            color: #e0e0e0;
        }

        body.dark-mode .help-content p,
        body.dark-mode .help-content li {
            color: #bbb;
        }

        body.dark-mode .help-content code {
            background: #3d3d5c;
            color: #64b5f6;
        }

        body.dark-mode .help-content pre {
            background: #1a1a2e;
        }

        body.dark-mode #result-table,
        body.dark-mode .result-table {
            border-color: #3d3d5c;
        }

        body.dark-mode #result-table th,
        body.dark-mode .result-table th {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table td,
        body.dark-mode .result-table td {
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode #result-table tr:nth-child(even),
        body.dark-mode .result-table tr:nth-child(even) {
            background: #252540;
        }

        body.dark-mode #result-table tr:hover,
        body.dark-mode .result-table tr:hover {
            background: #35355c;
        }

        body.dark-mode #result-table td:nth-child(7),
        body.dark-mode .result-table td:last-child {
            background: #2d2d44;
        }

        body.dark-mode .empty-value {
            background: #4a3030;
        }

        body.dark-mode .struct-result-group {
            border-color: #3d3d5c;
            background: #252540;
        }

        body.dark-mode .struct-result-group h3 {
            color: #e0e0e0;
        }

        body.dark-mode .record-header {
            border-bottom-color: #3d3d5c;
        }

        body.dark-mode .record-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .parse-settings-info {
            background: #2d2d3d;
            border-color: #4a4a5a;
        }

        body.dark-mode .parse-settings-info h4 {
            color: #b0b0c0;
        }

        body.dark-mode .setting-label {
            color: #e0e0e0;
        }

        body.dark-mode .setting-value.enabled {
            background: #1e4620;
            color: #a3d9a5;
        }

        body.dark-mode .setting-value.disabled {
            background: #4a2020;
            color: #f5c6cb;
        }

        body.dark-mode .parse-stats {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .parse-stats h3 {
            color: #64b5f6;
        }

        body.dark-mode .stats-grid > div {
            background: #1a1a2e;
            color: #e0e0e0;
        }

        body.dark-mode .error-message {
            background: #4a2020;
            border-color: #8b3030;
            color: #ff8a80;
        }

        body.dark-mode .restore-notification {
            background: #2a3d5c;
            border-color: #3d5c8a;
        }

        body.dark-mode .restore-notification-text {
            color: #64b5f6;
        }

        body.dark-mode .restore-btn.secondary {
            background: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .restore-btn.secondary:hover {
            background: #4d4d6c;
        }

        body.dark-mode .theme-toggle {
            background: #3d3d5c;
            border-color: #4d4d6c;
            color: #e0e0e0;
        }

        body.dark-mode .theme-toggle:hover {
            background: #4d4d6c;
        }

        body.dark-mode .test-results.success {
            background: #1e3a29;
            border-color: #2e8b57;
        }

        body.dark-mode .test-results.failure {
            background: #3a1e1e;
            border-color: #8b2e2e;
        }

        body.dark-mode .test-item {
            border-bottom-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .section-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox {
            background: #1e3a5f;
            border-color: #4a90d9;
            color: #e0e0e0;
        }

        body.dark-mode .option-checkbox:hover {
            background: #2a4a6f;
        }

        body.dark-mode .option-description {
            background: #2d2d2d;
            border-left-color: #6c757d;
            color: #b0b0b0;
        }

        body.dark-mode .drag-handle {
            color: #6c757d;
        }

        body.dark-mode .drag-handle:hover {
            color: #adb5bd;
        }

        body.dark-mode .struct-card.drag-over {
            border-color: #64b5f6;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        /* ë‹¤í¬ëª¨ë“œ - ìë™ ì„¤ì • í•„ë“œ ìŠ¤íƒ€ì¼ */
        body.dark-mode .auto-field {
            background: #3d3d5c;
            color: #adb5bd;
        }

        body.dark-mode .new-field-input {
            background: #2d2d44;
            border-color: #3d3d5c;
            color: #e0e0e0;
        }

        body.dark-mode .new-field-input:focus {
            border-color: #64b5f6;
            box-shadow: 0 0 0 0.2rem rgba(100, 181, 246, 0.25);
        }

        body.dark-mode .preview-cell {
            background: #2d2d44;
            color: #adb5bd;
        }
    </style>
</head>
<body>
    <!-- ë‹¤í¬ëª¨ë“œ í† ê¸€ ë²„íŠ¼ -->
    <button class="theme-toggle" id="theme-toggle" title="ë‹¤í¬ëª¨ë“œ ì „í™˜">ğŸŒ™</button>
    
    <h1>í†µì „ë¬¸ íŒŒì„œ</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML íŒŒì‹±</button>
        <button class="tab-btn" data-tab="struct">C êµ¬ì¡°ì²´ íŒŒì‹±</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        <div id="input-section">
            <label for="xml-input">XML ê·œê²©</label>
            <textarea id="xml-input" rows="10" placeholder="XML ê·œê²© ì…ë ¥"></textarea>
            
            <label for="telegram-input">í†µì „ë¬¸</label>
            <textarea id="telegram-input" rows="5" placeholder="í†µì „ë¬¸ ì…ë ¥"></textarea>
        </div>
        
        <div class="button-group">
            <button id="sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
            <button id="parse-btn">íŒŒì‹± ì‹¤í–‰</button>
            <button id="clear-btn">ì´ˆê¸°í™”</button>
        </div>
        
        <div id="result-container"></div>
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <!-- ë„ì›€ë§ ì„¹ì…˜ -->
        <div class="help-section">
            <button class="help-toggle" type="button">
                <span>ğŸ“– ì‚¬ìš© ë°©ë²• ì•ˆë‚´</span>
                <span class="help-toggle-icon">â–¼</span>
            </button>
            <div class="help-content">
                <h4>C êµ¬ì¡°ì²´ íŒŒì‹± ì‚¬ìš©ë²•</h4>
                <p>ê³ ì • ê¸¸ì´ ë°ì´í„°ë¥¼ C êµ¬ì¡°ì²´ ì •ì˜ì— ë”°ë¼ íŒŒì‹±í•©ë‹ˆë‹¤.</p>
                
                <h4>1. êµ¬ì¡°ì²´ ì •ì˜ í˜•ì‹</h4>
                <p><code>typedef struct { ... } êµ¬ì¡°ì²´ëª…;</code> í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•©ë‹ˆë‹¤.</p>
                <pre>typedef struct {
    char record_kubun[1];  // ë ˆì½”ë“œ êµ¬ë¶„
    char bank_cd[2];       // ì€í–‰ ì½”ë“œ
    char cust_id[7];       // ê³ ê° ID
} DHF_H;</pre>
                
                <h4>2. ë°ì´í„° ì…ë ¥ ê·œì¹™</h4>
                <ul>
                    <li>ê° ì¤„ì´ í•˜ë‚˜ì˜ ë°ì´í„° ë ˆì½”ë“œì…ë‹ˆë‹¤</li>
                    <li>ì—¬ëŸ¬ êµ¬ì¡°ì²´ê°€ ìˆì„ ê²½ìš°, ì²« ê¸€ìë¡œ êµ¬ì¡°ì²´ë¥¼ ìë™ ë§¤ì¹­í•©ë‹ˆë‹¤</li>
                    <li>ì˜ˆ: <code>H</code>ë¡œ ì‹œì‘ â†’ <code>DHF_H</code> (Hë¡œ ëë‚˜ëŠ” êµ¬ì¡°ì²´)</li>
                    <li>ì˜ˆ: <code>D</code>ë¡œ ì‹œì‘ â†’ <code>DHF_D</code> (Dë¡œ ëë‚˜ëŠ” êµ¬ì¡°ì²´)</li>
                </ul>
                
                <h4>3. ì§€ì› ê¸°ëŠ¥</h4>
                <ul>
                    <li>ì—¬ëŸ¬ êµ¬ì¡°ì²´ ë™ì‹œ ì •ì˜ ê°€ëŠ¥</li>
                    <li>ì£¼ì„ ì§€ì›: <code>//</code> í•œì¤„ ì£¼ì„, <code>/* */</code> ë¸”ë¡ ì£¼ì„</li>
                    <li>íŒŒì‹± ê²°ê³¼ë¥¼ TSV í˜•ì‹ìœ¼ë¡œ í´ë¦½ë³´ë“œì— ë³µì‚¬ ê°€ëŠ¥</li>
                </ul>
                
                <h4>4. ì£¼ì˜ì‚¬í•­</h4>
                <ul>
                    <li>ë°ì´í„° ê¸¸ì´ê°€ êµ¬ì¡°ì²´ ì´ í¬ê¸°ì™€ ë‹¤ë¥´ë©´ ê²½ê³ ê°€ í‘œì‹œë©ë‹ˆë‹¤</li>
                    <li>char ë°°ì—´ë§Œ ì •í™•íˆ ì§€ì›ë©ë‹ˆë‹¤ (int, short ë“±ì€ charë¡œ ì²˜ë¦¬)</li>
                </ul>
            </div>
        </div>

        <div id="struct-input-section">
            <div class="section-header">
                <h3>C êµ¬ì¡°ì²´ ì •ì˜</h3>
                <div class="header-options">
                    <label class="option-checkbox">
                        <input type="checkbox" id="recognize-crlf">
                        ê°œí–‰ë¬¸ì ì¸ì‹ (CRLF)
                    </label>
                    <button id="add-struct-btn">+ êµ¬ì¡°ì²´ ì¶”ê°€ <span class="shortcut-hint">(Ctrl+N)</span></button>
                </div>
            </div>
            <div class="option-description">
                <small>
                    â„¹ï¸ ì²´í¬ ì‹œ: ê° ë ˆì½”ë“œ ëì— CRLF(2 bytes) ì¡´ì¬ë¡œ ê°„ì£¼<br>
                    ğŸ“ ì²´í¬ í•´ì œ: ì¤„ë°”ê¿ˆ ì œê±° í›„ ì—°ì† ë°ì´í„°ë¡œ ì²˜ë¦¬
                </small>
            </div>
            
            <div id="struct-definitions-container">
                <!-- êµ¬ì¡°ì²´ ì…ë ¥ ì¹´ë“œë“¤ì´ ì—¬ê¸° ë™ì  ì¶”ê°€ë¨ -->
            </div>
            
            <label for="struct-data" style="margin-top: 20px;">í†µ ë°ì´í„°</label>
            <textarea id="struct-data" rows="10" placeholder="íŒŒì‹±í•  ë°ì´í„° ì…ë ¥ (ì¤„ë°”ê¿ˆ ìœ ë¬´ ë¬´ê´€)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
                <button id="struct-parse-btn">íŒŒì‹± ì‹¤í–‰ <span class="shortcut-hint">(Ctrl+Enter)</span></button>
                <button id="struct-clear-btn">ì „ì²´ ì´ˆê¸°í™”</button>
            </div>
        </div>

        <div id="struct-result-container"></div>
    </div>

    <script>
        /**
         * =====================================================
         * ì „ì—­ ë³€ìˆ˜
         * =====================================================
         */
        let structCardIndex = 0;

        /**
         * =====================================================
         * ì •ê·œì‹ ìºì‹± - ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ì •ê·œì‹ì„ ë¯¸ë¦¬ ì»´íŒŒì¼
         * =====================================================
         */
        const REGEX_CACHE = {
            // í•œì¤„ ì£¼ì„ ì œê±°: // ë¶€í„° ì¤„ ëê¹Œì§€ ë§¤ì¹­
            singleLineComment: /\/\/.*$/gm,
            
            // ë¸”ë¡ ì£¼ì„ ì œê±°: /* ë¶€í„° */ ê¹Œì§€ (ë¹„íƒìš•ì  ë§¤ì¹­)
            blockComment: /\/\*[\s\S]*?\*\//g,
            
            // typedef struct ë¸”ë¡ ì¶”ì¶œ:
            // - typedef\s+struct: "typedef struct" í‚¤ì›Œë“œ
            // - (\w+)?: ì„ íƒì  êµ¬ì¡°ì²´ ì´ë¦„ (ìº¡ì²˜ ê·¸ë£¹ 1)
            // - \s*\{([^}]+)\}: ì¤‘ê´„í˜¸ì™€ ë‚´ìš© (ìº¡ì²˜ ê·¸ë£¹ 2)
            // - \s*(\w+)\s*;: typedef ë³„ì¹­ ì´ë¦„ (ìº¡ì²˜ ê·¸ë£¹ 3)
            structPattern: /typedef\s+struct\s+(\w+)?\s*\{([^}]+)\}\s*(\w+)\s*;/g,
            
            // í•„ë“œ ì¶”ì¶œ:
            // - (unsigned\s+)?: ì„ íƒì  unsigned í‚¤ì›Œë“œ (ìº¡ì²˜ ê·¸ë£¹ 1)
            // - (\w+): ê¸°ë³¸ íƒ€ì… (char, int ë“±) (ìº¡ì²˜ ê·¸ë£¹ 2)
            // - \s+(\w+): í•„ë“œëª… (ìº¡ì²˜ ê·¸ë£¹ 3)
            // - \s*\[\s*(\d+)\s*\]: ë°°ì—´ í¬ê¸° (ìº¡ì²˜ ê·¸ë£¹ 4)
            fieldPattern: /(unsigned\s+)?(\w+)\s+(\w+)\s*\[\s*(\d+)\s*\]/g,
            
            // êµ¬ì¡°ì²´ëª…ì—ì„œ ìˆ«ì ì¶”ì¶œ: ë¬¸ìì—´ ëì˜ ì—°ì†ëœ ìˆ«ì
            trailingNumber: /(\d+)$/
        };

        /**
         * ì •ê·œì‹ íŒ¨í„´ì„ ë³µì œí•˜ì—¬ ë°˜í™˜
         * ì •ê·œì‹ì€ ìƒíƒœë¥¼ ê°€ì§€ë¯€ë¡œ(lastIndex), ì‚¬ìš© ì „ ë³µì œ í•„ìš”
         * @param {string} name - REGEX_CACHEì˜ í‚¤ ì´ë¦„
         * @returns {RegExp} ë³µì œëœ ì •ê·œì‹ ê°ì²´
         */
        function getRegex(name) {
            const original = REGEX_CACHE[name];
            return new RegExp(original.source, original.flags);
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ì¹´ë“œ ìƒì„± í•¨ìˆ˜
         * êµ¬ì¡°ì²´ ì…ë ¥ì„ ìœ„í•œ ì¹´ë“œ DOM ìš”ì†Œ ìƒì„±
         * - ì ‘ê¸°/í¼ì¹˜ê¸° ê¸°ëŠ¥ ì§€ì›
         * - ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì¬ì •ë ¬ ì§€ì›
         * =====================================================
         * @param {number} index - êµ¬ì¡°ì²´ ì¸ë±ìŠ¤ ë²ˆí˜¸
         * @returns {HTMLElement} div.struct-card DOM ìš”ì†Œ
         */
        function createStructCard(index) {
            // 1. div ìƒì„±, class="struct-card", data-index="${index}"
            const div = document.createElement('div');
            div.className = 'struct-card';
            div.setAttribute('data-index', index);
            div.setAttribute('draggable', 'true'); // ë“œë˜ê·¸ ì•¤ ë“œë¡­ í™œì„±í™”

            // 2. ë‚´ë¶€ HTML ì„¤ì • (ì ‘ê¸°/í¼ì¹˜ê¸° ì•„ì´ì½˜ ë° ë“œë˜ê·¸ í•¸ë“¤ í¬í•¨)
            div.innerHTML = `
                <div class="struct-card-header">
                    <div class="struct-header-left">
                        <span class="collapse-icon">â–¼</span>
                        <span class="struct-number">êµ¬ì¡°ì²´ #${index + 1}</span>
                        <span class="struct-preview"></span>
                    </div>
                    <div class="struct-card-header-actions">
                        <span class="drag-handle" title="ë“œë˜ê·¸í•˜ì—¬ ìˆœì„œ ë³€ê²½">â‹®â‹®</span>
                        <button class="remove-struct-btn" data-index="${index}">âœ• ì‚­ì œ</button>
                    </div>
                </div>
                
                <div class="struct-card-body">
                    <div class="input-row">
                        <label>êµ¬ì¡°ì²´ëª… (ì„ íƒ)</label>
                        <input type="text" class="struct-name" placeholder="ì˜ˆ: DHF_H, HeaderRecord" />
                    </div>
                    
                    <div class="input-row">
                        <label>êµ¬ë¶„ê°’ (ì„ íƒ)</label>
                        <input type="text" class="struct-kubun" maxlength="5" placeholder="ì˜ˆ: H, 01, HEADER" />
                        <small>ì—¬ëŸ¬ êµ¬ì¡°ì²´ ì‚¬ìš© ì‹œ í•„ìˆ˜. ë°ì´í„° ì²« ê¸€ìë¡œ êµ¬ì¡°ì²´ ì‹ë³„</small>
                    </div>
                    
                    <div class="input-row">
                        <label>êµ¬ì¡°ì²´ ì •ì˜</label>
                        <textarea class="struct-definition" rows="8" placeholder="typedef struct { ... } êµ¬ì¡°ì²´ëª…;"></textarea>
                    </div>
                </div>
            `;

            // 3. ìš”ì†Œ ë°˜í™˜
            return div;
        }

        /**
         * =====================================================
         * XML ê·œê²© íŒŒì‹± í•¨ìˆ˜
         * XML ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ col ìš”ì†Œ ë°°ì—´ë¡œ ë³€í™˜
         * =====================================================
         * @param {string} xmlString - XML ê·œê²© ë¬¸ìì—´
         * @returns {Array|null} col ìš”ì†Œ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseXMLSpec(xmlString) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: ì…ë ¥ê°’ì´ ë¬¸ìì—´ì´ ì•„ë‹™ë‹ˆë‹¤.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: ë¹ˆ ë¬¸ìì—´ì´ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                return null;
            }

            // DOMParserë¥¼ ì‚¬ìš©í•´ XML ë¬¸ì„œë¡œ ë³€í™˜
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', e.message);
                return null;
            }

            // parsererror ì²´í¬
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', parseError.textContent);
                return null;
            }

            // ëª¨ë“  col ìš”ì†Œ ì„ íƒ
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return [];
            }

            // ìœ íš¨í•œ col ìš”ì†Œë“¤ì„ ë‹´ì„ ë°°ì—´
            const result = [];

            // ê° col ìš”ì†Œ ì²˜ë¦¬
            colElements.forEach((col, index) => {
                // ì†ì„± ì¶”ì¶œ
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // í•„ìˆ˜ ì†ì„± ê²€ì¦
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì— í•„ìˆ˜ ì†ì„±ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: ${missingAttrs.join(', ')}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // sizeë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜
                const size = parseInt(sizeAttr, 10);

                // sizeê°€ ìœ íš¨í•œ ì •ìˆ˜ì¸ì§€ ê²€ì¦
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤: "${sizeAttr}"`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: ${size}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // ìœ íš¨í•œ col ì •ë³´ë¥¼ ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        /**
         * =====================================================
         * í†µì „ë¬¸ íŒŒì‹± í•¨ìˆ˜
         * í†µì „ë¬¸ ë¬¸ìì—´ì„ XML ê·œê²©ì— ë§ê²Œ ë¶„ë¦¬
         * =====================================================
         * @param {string} telegramString - í†µì „ë¬¸ ë¬¸ìì—´
         * @param {Array} xmlSpec - parseXMLSpecì˜ ê²°ê³¼ ë°°ì—´
         * @returns {Array} íŒŒì‹±ëœ ê²°ê³¼ ë°°ì—´
         */
        function parseTelegram(telegramString, xmlSpec) {
            // í˜„ì¬ ìœ„ì¹˜ ì´ˆê¸°í™”
            let currentPos = 0;

            // ë¹ˆ ê²°ê³¼ ë°°ì—´ ìƒì„±
            const result = [];

            // xmlSpec ë°°ì—´ ìˆœíšŒ
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // ì‹œì‘/ì¢…ë£Œ ìœ„ì¹˜ ê³„ì‚°
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substringìœ¼ë¡œ ê°’ ì¶”ì¶œ (ì¸ë±ìŠ¤ ë²”ìœ„ ì´ˆê³¼í•´ë„ ì˜¤ë¥˜ ì—†ì´ ì²˜ë¦¬ë¨)
                const value = telegramString.substring(startPos, endPos);

                // ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // í˜„ì¬ ìœ„ì¹˜ ì´ë™
                currentPos += spec.size;
            }

            // í†µì „ë¬¸ ì „ì²´ ê¸¸ì´ì™€ ì˜ˆìƒ ê¸¸ì´ ë¹„êµ
            if (telegramString.length !== currentPos) {
                console.warn(
                    `parseTelegram: í†µì „ë¬¸ ê¸¸ì´(${telegramString.length})ì™€ ì˜ˆìƒ ê¸¸ì´(${currentPos})ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`
                );
            }

            return result;
        }

        /**
         * =====================================================
         * ê°’ íŒ¨ë”© í•¨ìˆ˜
         * ê°’ì„ ì§€ì •ëœ í¬ê¸°ì— ë§ê²Œ íŒ¨ë”© (ê³µë°±ìœ¼ë¡œ ì±„ì›€)
         * =====================================================
         * @param {string} value - íŒ¨ë”©í•  ê°’
         * @param {number} size - ëª©í‘œ í¬ê¸°
         * @param {string} fieldName - í•„ë“œëª… (ë¡œê¹…ìš©)
         * @returns {string} íŒ¨ë”©ëœ ê°’
         */
        function padValue(value, size, fieldName) {
            // ê°’ì´ ì—†ìœ¼ë©´ ê³µë°±ìœ¼ë¡œ ì±„ì›€
            if (value === null || value === undefined) {
                value = '';
            }
            
            // ë¬¸ìì—´ë¡œ ë³€í™˜
            value = String(value);
            
            // ê°’ì´ sizeë³´ë‹¤ í¬ë©´ ìë¥´ê³  ê²½ê³ 
            if (value.length > size) {
                console.warn('padValue: í•„ë“œ "' + fieldName + '"ì˜ ê°’ì´ í¬ê¸°(' + size + ')ë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤. ê°’ì„ ìë¦…ë‹ˆë‹¤.');
                return value.substring(0, size);
            }
            
            // ê°’ì´ sizeë³´ë‹¤ ì‘ìœ¼ë©´ ê³µë°±ìœ¼ë¡œ íŒ¨ë”© (ìš°ì¸¡ íŒ¨ë”©)
            return value.padEnd(size, ' ');
        }

        /**
         * =====================================================
         * í†µì „ë¬¸ ìƒì„± í•¨ìˆ˜ (29ë‹¨ê³„)
         * í•„ë“œ ë°°ì—´ì„ ë°›ì•„ì„œ í†µì „ë¬¸ ë¬¸ìì—´ ìƒì„±
         * CRLF í•„ë“œëŠ” ê°œí–‰ ì¸ì‹ ì˜µì…˜ì— ë”°ë¼ ìë™ ì²˜ë¦¬
         * =====================================================
         * @param {Array} fields - í•„ë“œ ë°°ì—´ [{name, value, size}, ...]
         * @returns {string} ìƒì„±ëœ í†µì „ë¬¸ ë¬¸ìì—´
         */
        function generateTelegram(fields) {
            // ê°œí–‰ë¬¸ì ì¸ì‹ ì˜µì…˜ í™•ì¸
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // ê²°ê³¼ í†µì „ë¬¸ ë¬¸ìì—´
            let telegram = '';
            
            // ê° í•„ë“œ ì²˜ë¦¬
            for (let i = 0; i < fields.length; i++) {
                const field = fields[i];
                
                // CRLF í•„ë“œ ì—¬ë¶€ í™•ì¸
                if (field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/)) {
                    // CRLF í•„ë“œ ìë™ ì²˜ë¦¬
                    if (recognizeCRLF) {
                        telegram += '\r\n';  // ë¬´ì¡°ê±´ CRLF
                    } else {
                        // ê°œí–‰ ì¸ì‹ ë¹„í™œì„±í™” ì‹œì—ë„ í•„ë“œëŠ” ì±„ì›Œì•¼ í•¨
                        telegram += '  ';    // ê³µë°± 2ê°œ
                        console.warn('CRLF í•„ë“œë¥¼ ê³µë°±ìœ¼ë¡œ ì±„ì›ë‹ˆë‹¤ (ê°œí–‰ ì¸ì‹ ë¹„í™œì„±í™”ë¨)');
                    }
                } else {
                    // ì¼ë°˜ í•„ë“œ ì²˜ë¦¬
                    telegram += padValue(field.value, field.size, field.name);
                }
            }
            
            return telegram;
        }

        /**
         * =====================================================
         * C êµ¬ì¡°ì²´ ì •ì˜ íŒŒì‹± í•¨ìˆ˜
         * êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ êµ¬ì¡°ì²´ ë°°ì—´ë¡œ ë³€í™˜
         * =====================================================
         * @param {string} structText - C êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´
         * @returns {Array|null} êµ¬ì¡°ì²´ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseStructDefinitions(structText) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. ì£¼ì„ ì œê±° ì²˜ë¦¬ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
            let cleanedText = structText.replace(getRegex('singleLineComment'), '');
            cleanedText = cleanedText.replace(getRegex('blockComment'), '');

            // 2. typedef struct ë¸”ë¡ ì¶”ì¶œ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
            const structPattern = getRegex('structPattern');
            
            // íƒ€ì…ë³„ í¬ê¸° ì •ì˜ (ë°”ì´íŠ¸)
            const typeSizes = {
                'char': 1,
                'unsigned char': 1,
                'short': 2,
                'unsigned short': 2,
                'int': 4,
                'unsigned int': 4,
                'long': 4,
                'unsigned long': 4
            };
            
            // ê²°ê³¼ ë°°ì—´
            const result = [];
            
            // typedef struct ë¸”ë¡ë“¤ ì¶”ì¶œ
            let structMatch;
            while ((structMatch = structPattern.exec(cleanedText)) !== null) {
                const fieldsContent = structMatch[2]; // ì¤‘ê´„í˜¸ ì•ˆì˜ ë‚´ìš©
                const structName = structMatch[3];    // typedef êµ¬ì¡°ì²´ëª… (ë§ˆì§€ë§‰ ì´ë¦„)
                
                // í•„ë“œ ë°°ì—´
                const fields = [];
                
                // í•„ë“œë“¤ ì¶”ì¶œ - ìƒˆë¡œìš´ ì •ê·œì‹ ì¸ìŠ¤í„´ìŠ¤ ì‚¬ìš©
                const fieldPattern = getRegex('fieldPattern');
                let fieldMatch;
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    const unsignedPrefix = fieldMatch[1] ? fieldMatch[1].trim() : '';
                    const baseType = fieldMatch[2];
                    const fieldName = fieldMatch[3];
                    const arraySize = parseInt(fieldMatch[4], 10);
                    
                    // ì „ì²´ íƒ€ì…ëª… êµ¬ì„±
                    const fullType = unsignedPrefix ? unsignedPrefix + ' ' + baseType : baseType;
                    
                    // íƒ€ì…ë³„ í¬ê¸° ê³„ì‚°
                    let typeSize = typeSizes[fullType] || typeSizes[baseType] || 1;
                    
                    // char ì™¸ì˜ íƒ€ì…ì€ ê²½ê³  ì¶œë ¥ (í•˜ì§€ë§Œ char ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬)
                    if (baseType !== 'char') {
                        console.warn('parseStructDefinitions: "' + structName + '"ì˜ í•„ë“œ "' + fieldName + '"ì˜ íƒ€ì… "' + fullType + '"ì€ charë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤. í¬ê¸° ê³„ì‚°ì´ ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                        // char ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬ (ë°°ì—´ í¬ê¸°ë§Œ ì‚¬ìš©)
                        typeSize = 1;
                    }
                    
                    fields.push({
                        name: fieldName,
                        type: fullType,
                        size: arraySize * typeSize
                    });
                }
                
                // ë¹ˆ êµ¬ì¡°ì²´ ê²€ì¦ - fieldsê°€ 0ê°œì¸ êµ¬ì¡°ì²´ëŠ” ì œì™¸
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: êµ¬ì¡°ì²´ "' + structName + '"ì— ìœ íš¨í•œ í•„ë“œê°€ ì—†ì–´ ì œì™¸ë©ë‹ˆë‹¤.');
                    continue;
                }
                
                // êµ¬ì¡°ì²´ ê°ì²´ ì¶”ê°€
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // êµ¬ì¡°ì²´ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ë°˜í™˜
            if (result.length === 0) {
                console.error('parseStructDefinitions: íŒŒì‹±ëœ êµ¬ì¡°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return null;
            }
            
            // íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì¶œë ¥
            console.log('parseStructDefinitions: ' + result.length + 'ê°œì˜ êµ¬ì¡°ì²´ê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            return result;
        }

        /**
         * =====================================================
         * ë‹¨ì¼ C êµ¬ì¡°ì²´ ì •ì˜ íŒŒì‹± í•¨ìˆ˜
         * í•˜ë‚˜ì˜ êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ í•„ë“œ ë°°ì—´ë¡œ ë³€í™˜
         * char íƒ€ì…ë§Œ ì§€ì› (unsigned charë„ charë¡œ ì²˜ë¦¬)
         * =====================================================
         * @param {string} structText - ë‹¨ì¼ C êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´
         * @returns {Object|null} { fields: [...], totalSize: number } ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseStructDefinition(structText) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinition: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. ì£¼ì„ ì œê±°
            // // ì£¼ì„ ì œê±°
            let cleanedText = structText.replace(/\/\/.*$/gm, '');
            // /* */ ì£¼ì„ ì œê±°
            cleanedText = cleanedText.replace(/\/\*[\s\S]*?\*\//g, '');

            // 2. í•„ë“œ ì¶”ì¶œ ì •ê·œì‹
            // char ë˜ëŠ” unsigned char íƒ€ì…ì˜ ë°°ì—´ í•„ë“œ ë§¤ì¹­
            // unsigned charë„ charë¡œ ì²˜ë¦¬
            const fieldPattern = /char\s+(\w+)\s*\[\s*(\d+)\s*\]/g;

            // 3. matchAllë¡œ ëª¨ë“  ë§¤ì¹­ ê²°ê³¼ ìˆœíšŒ
            const matches = cleanedText.matchAll(fieldPattern);
            const fields = [];

            for (const match of matches) {
                const fieldName = match[1];
                const size = parseInt(match[2], 10);

                // í•„ë“œ ì •ë³´ë¥¼ fields ë°°ì—´ì— ì¶”ê°€
                fields.push({
                    name: fieldName,
                    size: size
                });
            }

            // 4. fieldsê°€ ë¹„ì–´ìˆìœ¼ë©´ null ë°˜í™˜
            if (fields.length === 0) {
                console.error('parseStructDefinition: ìœ íš¨í•œ í•„ë“œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return null;
            }

            // 5. ì´ í¬ê¸° ê³„ì‚°
            const totalSize = fields.reduce((sum, f) => sum + f.size, 0);

            // 6. ê²°ê³¼ ë°˜í™˜
            return { fields, totalSize };
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ì •ì˜ ìˆ˜ì§‘ í•¨ìˆ˜
         * ëª¨ë“  êµ¬ì¡°ì²´ ì¹´ë“œì—ì„œ ì •ì˜ë¥¼ ìˆ˜ì§‘í•˜ì—¬ ë°°ì—´ë¡œ ë°˜í™˜
         * =====================================================
         * @returns {Array|null} êµ¬ì¡°ì²´ ì •ë³´ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function collectStructDefinitions() {
            // 1. ëª¨ë“  .struct-card ìš”ì†Œ ì„ íƒ
            const cards = document.querySelectorAll('.struct-card');

            // 2. ë¹ˆ ë°°ì—´ structDefs = []
            const structDefs = [];

            // 3. ê° ì¹´ë“œë§ˆë‹¤ ì²˜ë¦¬
            for (let index = 0; index < cards.length; index++) {
                const card = cards[index];

                // a. .struct-name ê°’ ê°€ì ¸ì˜¤ê¸° (trim)
                const structNameInput = card.querySelector('.struct-name');
                const structName = structNameInput ? structNameInput.value.trim() : '';

                // b. .struct-kubun ê°’ ê°€ì ¸ì˜¤ê¸° (trim)
                const kubunInput = card.querySelector('.struct-kubun');
                const kubunValue = kubunInput ? kubunInput.value.trim() : '';

                // c. .struct-definition ê°’ ê°€ì ¸ì˜¤ê¸° (trim)
                const definitionInput = card.querySelector('.struct-definition');
                const definitionText = definitionInput ? definitionInput.value.trim() : '';

                // d. êµ¬ì¡°ì²´ ì •ì˜ê°€ ë¹„ì–´ìˆìœ¼ë©´ í•´ë‹¹ ì¹´ë“œ ê±´ë„ˆë›°ê¸°
                if (definitionText === '') {
                    continue;
                }

                // e. parseStructDefinition(ì •ì˜ í…ìŠ¤íŠ¸) í˜¸ì¶œ
                const parsed = parseStructDefinition(definitionText);

                // f. íŒŒì‹± ì„±ê³µ ì‹œ structDefsì— ì¶”ê°€
                if (parsed !== null) {
                    // CRLF í•„ë“œ ì¡´ì¬ í™•ì¸
                    const hasCRLFField = parsed.fields.some(function(f) {
                        return f.name.toLowerCase().match(/crlf|cr_lf|newline/);
                    });
                    
                    // ì˜µì…˜ê³¼ ì¼ì¹˜ ì—¬ë¶€ í™•ì¸
                    const recognizeCRLF = document.getElementById('recognize-crlf').checked;
                    const currentName = structName || ('êµ¬ì¡°ì²´' + (index + 1));
                    
                    if (recognizeCRLF && !hasCRLFField) {
                        console.warn('êµ¬ì¡°ì²´ "' + currentName + '": ê°œí–‰ ì¸ì‹ í™œì„±í™”ë˜ì—ˆìœ¼ë‚˜ crlf í•„ë“œ ì—†ìŒ');
                    }
                    
                    if (!recognizeCRLF && hasCRLFField) {
                        console.warn('êµ¬ì¡°ì²´ "' + currentName + '": crlf í•„ë“œê°€ ìˆìœ¼ë‚˜ ê°œí–‰ ì¸ì‹ ë¹„í™œì„±í™”ë¨');
                    }
                    
                    structDefs.push({
                        name: currentName,
                        kubun: kubunValue || null,
                        fields: parsed.fields,
                        totalSize: parsed.totalSize,
                        hasCRLFField: hasCRLFField
                    });
                } else {
                    // g. íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ í‘œì‹œ í›„ null ë°˜í™˜
                    displayError('êµ¬ì¡°ì²´ #' + (index + 1) + ' íŒŒì‹± ì‹¤íŒ¨', 'struct-result-container');
                    return null;
                }
            }

            // 4. structDefsê°€ ë¹„ì–´ìˆìœ¼ë©´ ì—ëŸ¬ í‘œì‹œ í›„ null ë°˜í™˜
            if (structDefs.length === 0) {
                displayError('ìœ íš¨í•œ êµ¬ì¡°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤', 'struct-result-container');
                return null;
            }

            // 5. ì…ë ¥ ê²€ì¦ ê°•í™”
            for (let i = 0; i < structDefs.length; i++) {
                const def = structDefs[i];
                
                // êµ¬ì¡°ì²´ëª…ì— íŠ¹ìˆ˜ë¬¸ì ìˆìœ¼ë©´ ê²½ê³  (ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ í—ˆìš©)
                if (def.name && !/^[a-zA-Z0-9_ê°€-í£]+$/.test(def.name)) {
                    console.warn('collectStructDefinitions: êµ¬ì¡°ì²´ "' + def.name + '"ì˜ ì´ë¦„ì— íŠ¹ìˆ˜ë¬¸ìê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì˜ˆìƒì¹˜ ëª»í•œ ë™ì‘ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }
                
                // êµ¬ë¶„ê°’ì´ ë„ˆë¬´ ê¸¸ë©´ (10ì ì´ìƒ) ê²½ê³ 
                if (def.kubun && def.kubun.length >= 10) {
                    console.warn('collectStructDefinitions: êµ¬ì¡°ì²´ "' + def.name + '"ì˜ êµ¬ë¶„ê°’ì´ ' + def.kubun.length + 'ìë¡œ ë„ˆë¬´ ê¹ë‹ˆë‹¤. 10ì ë¯¸ë§Œì„ ê¶Œì¥í•©ë‹ˆë‹¤.');
                }
            }

            // 6. êµ¬ë¶„ê°’ ê²€ì¦
            if (structDefs.length >= 2) {
                // êµ¬ì¡°ì²´ê°€ 2ê°œ ì´ìƒì¸ë° kubunì´ nullì¸ ê²ƒì´ ìˆìœ¼ë©´ ê²½ê³ 
                const hasNullKubun = structDefs.some(function(def) {
                    return def.kubun === null;
                });
                
                if (hasNullKubun) {
                    console.warn('collectStructDefinitions: ì—¬ëŸ¬ êµ¬ì¡°ì²´ ì¤‘ êµ¬ë¶„ê°’ì´ ì—†ëŠ” ê²ƒì´ ìˆìŠµë‹ˆë‹¤. ë°ì´í„° ë§¤ì¹­ì´ ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }

                // ì¤‘ë³µëœ kubun ê°’ì´ ìˆìœ¼ë©´ ì—ëŸ¬
                const kubunValues = structDefs
                    .filter(function(def) { return def.kubun !== null; })
                    .map(function(def) { return def.kubun; });
                
                const duplicates = kubunValues.filter(function(value, idx, arr) {
                    return arr.indexOf(value) !== idx;
                });

                if (duplicates.length > 0) {
                    displayError('ì¤‘ë³µëœ êµ¬ë¶„ê°’ì´ ìˆìŠµë‹ˆë‹¤: ' + duplicates.join(', '), 'struct-result-container');
                    return null;
                }

                // êµ¬ë¶„ê°’ ê¸¸ì´ ì¼ê´€ì„± ê²€ì‚¬ (ëª¨ë‘ ê°™ì€ ê¸¸ì´ ê¶Œì¥)
                const kubunLengths = kubunValues.map(function(k) { return k.length; });
                const uniqueLengths = kubunLengths.filter(function(len, idx, arr) {
                    return arr.indexOf(len) === idx;
                });
                
                if (uniqueLengths.length > 1) {
                    console.warn('collectStructDefinitions: êµ¬ë¶„ê°’ ê¸¸ì´ê°€ ì¼ê´€ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê¸¸ì´: ' + uniqueLengths.join(', ') + '. ëª¨ë‘ ê°™ì€ ê¸¸ì´ë¡œ í†µì¼í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.');
                }
            }

            // 7. structDefs ë°˜í™˜
            console.log('collectStructDefinitions: ' + structDefs.length + 'ê°œì˜ êµ¬ì¡°ì²´ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤.');
            return structDefs;
        }

        /**
         * =====================================================
         * kubun ê¸°ë°˜ êµ¬ì¡°ì²´ ì°¾ê¸° í•¨ìˆ˜
         * ë°ì´í„°ì˜ ì²« ë¶€ë¶„ì„ kubun ê°’ê³¼ ë¹„êµí•˜ì—¬ êµ¬ì¡°ì²´ íƒìƒ‰
         * =====================================================
         * @param {string} data - í˜„ì¬ ìœ„ì¹˜ë¶€í„°ì˜ ë°ì´í„°
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Object|null} ë§¤ì¹­ëœ êµ¬ì¡°ì²´ ë˜ëŠ” null
         */
        function findStructByKubun(data, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!data || !Array.isArray(structDefs) || structDefs.length === 0) {
                return null;
            }

            // 1. kubunì´ nullì´ ì•„ë‹Œ êµ¬ì¡°ì²´ë“¤ì„ ìˆœíšŒí•˜ë©° ë§¤ì¹­ ì‹œë„
            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];
                const kubun = structDef.kubun;

                // kubunì´ nullì´ë©´ ê±´ë„ˆë›°ê¸°
                if (kubun === null || kubun === undefined) {
                    continue;
                }

                // kubun ê¸¸ì´ë§Œí¼ dataì—ì„œ ì¶”ì¶œí•˜ì—¬ ë¹„êµ
                const kubunLength = kubun.length;
                const dataKubun = data.substring(0, kubunLength);

                // ë§¤ì¹­ë˜ë©´ í•´ë‹¹ êµ¬ì¡°ì²´ ë°˜í™˜
                if (dataKubun === kubun) {
                    return structDef;
                }
            }

            // 2. ëª¨ë‘ ì‹¤íŒ¨ ì‹œ kubunì´ nullì¸ êµ¬ì¡°ì²´ ë°˜í™˜ (fallback)
            for (let i = 0; i < structDefs.length; i++) {
                if (structDefs[i].kubun === null || structDefs[i].kubun === undefined) {
                    return structDefs[i];
                }
            }

            // 3. fallbackë„ ì—†ìœ¼ë©´ null ë°˜í™˜
            return null;
        }

        /**
         * =====================================================
         * ë§¤ì¹­ êµ¬ì¡°ì²´ ì°¾ê¸° í•¨ìˆ˜
         * ë°ì´í„° ë¼ì¸ì˜ ì²« ê¸€ìë¡œ ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ íƒìƒ‰
         * =====================================================
         * @param {string} line - ë°ì´í„° ë¼ì¸
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Object|null} ë§¤ì¹­ëœ êµ¬ì¡°ì²´ ë˜ëŠ” null
         */
        function findMatchingStruct(line, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. êµ¬ì¡°ì²´ê°€ 1ê°œë§Œ ìˆìœ¼ë©´ ê·¸ê²ƒ ë°˜í™˜
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ë§¤ì¹­ ë¡œì§
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // í•„ë“œê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // ì²« ë²ˆì§¸ í•„ë“œì˜ sizeë§Œí¼ lineì—ì„œ ì¶”ì¶œ
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // êµ¬ì¡°ì²´ëª…ì—ì„œ êµ¬ë¶„ íŒ¨í„´ ì¶”ì¶œ
                // ì˜ˆ: DHF_H â†’ 'H', DHF_D â†’ 'D', ST_HEADER_1 â†’ '1'
                const structName = structDef.name;
                
                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ (ì–¸ë”ìŠ¤ì½”ì–´ ë’¤ ë˜ëŠ” ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ì)
                let structIdentifier = '';
                
                // ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // ë§ˆì§€ë§‰ ë¶€ë¶„ì´ ë‹¨ì¼ ë¬¸ì ë˜ëŠ” ìˆ«ìì¸ ê²½ìš°
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ìˆ«ì ì¶”ì¶œ ì‹œë„ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
                    const numMatch = lastPart.match(getRegex('trailingNumber'));
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // ë§ˆì§€ë§‰ ë¬¸ì ì‚¬ìš©
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ìì™€ line ì²« ë¬¸ì ë¹„êµ
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // ì²« í•„ë“œ ê°’ê³¼ êµ¬ì¡°ì²´ ì‹ë³„ì ë¹„êµ
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜, ì½˜ì†”ì— ê²½ê³ 
            console.warn('findMatchingStruct: ë¼ì¸ "' + line.substring(0, 20) + '..."ì— ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return null;
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ë°ì´í„° íŒŒì‹± í•¨ìˆ˜
         * í†µ ë°ì´í„°ë¥¼ êµ¬ì¡°ì²´ ì •ì˜ì— ë§ê²Œ íŒŒì‹±
         * =====================================================
         * @param {string} dataText - ë°ì´í„° í…ìŠ¤íŠ¸ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„)
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Object} { records: [...], stats: {...} } í˜•ì‹ì˜ íŒŒì‹± ê²°ê³¼
         */
        function parseStructData(dataText, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: ë°ì´í„° í…ìŠ¤íŠ¸ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: êµ¬ì¡°ì²´ ì •ì˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return { records: [], stats: { totalBytes: 0, parsedBytes: 0, recordCount: 0, errorBytes: 0 } };
            }

            // 1. ì˜µì…˜ ì½ê¸°
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // 2. ë°ì´í„° ì „ì²˜ë¦¬
            let processedData;

            if (recognizeCRLF) {
                // ê°œí–‰ë¬¸ì ì¸ì‹ ëª¨ë“œ

                // ë¨¼ì € ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ ì²˜ë¦¬
                let temp = dataText.replace(/\\r\\n/g, '\r\n')
                                   .replace(/\\n/g, '\n')
                                   .replace(/\\r/g, '\r');

                // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë ˆì½”ë“œ ë¶„ë¦¬
                const lines = temp.split(/\r?\n/).filter(line => line.trim().length > 0);

                // ê° ë ˆì½”ë“œì— CRLF ì¶”ê°€ (ì—†ìœ¼ë©´)
                processedData = lines.map(line => {
                    // ì´ë¯¸ CRLFë¡œ ëë‚˜ëŠ”ì§€ í™•ì¸
                    if (line.endsWith('\r\n')) {
                        return line;
                    }
                    // CRLF ì¶”ê°€
                    return line + '\r\n';
                }).join('');

                console.log(`ê°œí–‰ ì¸ì‹ ëª¨ë“œ: ${lines.length}ê°œ ë ˆì½”ë“œ, ê° ë ˆì½”ë“œ ëì— CRLF ì¶”ê°€`);

                // CRLF í•„ë“œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ê²½ê³ ë§Œ)
                const hasCrlfField = structDefs.some(struct => 
                    struct.fields && struct.fields.some(field => 
                        field.name && field.name.toLowerCase() === 'crlf'
                    )
                );
                if (!hasCrlfField) {
                    console.warn('ê²½ê³ : ê°œí–‰ ì¸ì‹ ëª¨ë“œì´ì§€ë§Œ êµ¬ì¡°ì²´ì— crlf í•„ë“œê°€ ì—†ìŠµë‹ˆë‹¤.');
                }

            } else {
                // ê°œí–‰ë¬¸ì ë¬´ì‹œ ëª¨ë“œ

                // ëª¨ë“  ê°œí–‰ ì œê±°
                processedData = dataText.replace(/[\r\n]/g, '');

                console.log(`ê°œí–‰ ë¬´ì‹œ ëª¨ë“œ: ì´ ${processedData.length} bytes`);

                // CRLF í•„ë“œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ê²½ê³ ë§Œ)
                const hasCrlfField = structDefs.some(struct => 
                    struct.fields && struct.fields.some(field => 
                        field.name && field.name.toLowerCase() === 'crlf'
                    )
                );
                if (hasCrlfField) {
                    console.warn('ê²½ê³ : ê°œí–‰ ë¬´ì‹œ ëª¨ë“œì´ì§€ë§Œ êµ¬ì¡°ì²´ì— crlf í•„ë“œê°€ ìˆìŠµë‹ˆë‹¤.');
                }
            }

            // 3. í†µê³„ ì´ˆê¸°í™”
            const totalBytes = processedData.length;
            let parsedBytes = 0;
            let errorBytes = 0;

            // 4. ë ˆì½”ë“œ ë°°ì—´ ì´ˆê¸°í™”
            const records = [];

            // 5. ìˆœì°¨ íŒŒì‹± ë¡œì§ (currentPos ë£¨í”„)
            let currentPos = 0;
            let recordIndex = 0;

            while (currentPos < processedData.length) {
                // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë‚¨ì€ ë°ì´í„°
                const remainingData = processedData.substring(currentPos);

                // findStructByKubun í•¨ìˆ˜ë¥¼ ë¨¼ì € ì‹œë„, ì‹¤íŒ¨ ì‹œ findMatchingStruct ì‚¬ìš©
                let matchedStruct = findStructByKubun(remainingData, structDefs);
                if (!matchedStruct) {
                    matchedStruct = findMatchingStruct(remainingData, structDefs);
                }

                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ 1ë°”ì´íŠ¸ ìŠ¤í‚µí•˜ê³  ê³„ì†
                if (!matchedStruct) {
                    errorBytes += 1;
                    console.warn('ìœ„ì¹˜ ' + currentPos + ': ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì—†ìŒ, 1ë°”ì´íŠ¸ ìŠ¤í‚µ');
                    currentPos += 1;
                    continue;
                }

                // êµ¬ì¡°ì²´ í¬ê¸° ê³„ì‚°
                const expectedLength = matchedStruct.fields.reduce(function(sum, f) {
                    return sum + f.size;
                }, 0);

                // ë°ì´í„°ê°€ êµ¬ì¡°ì²´ í¬ê¸°ë³´ë‹¤ ì§§ìœ¼ë©´ ë‚˜ë¨¸ì§€ ì—ëŸ¬ ì²˜ë¦¬ í›„ ì¢…ë£Œ
                if (remainingData.length < expectedLength) {
                    errorBytes += remainingData.length;
                    console.warn('ìœ„ì¹˜ ' + currentPos + ': ë°ì´í„° ë¶€ì¡± (í•„ìš”: ' + expectedLength + ', ì‹¤ì œ: ' + remainingData.length + ')');
                    break;
                }

                // í•„ë“œ ë°°ì—´ ìƒì„±
                const fields = [];
                let fieldPos = 0;

                matchedStruct.fields.forEach(function(field) {
                    const startPos = fieldPos;
                    const endPos = fieldPos + field.size;
                    const value = remainingData.substring(startPos, endPos);

                    fields.push({
                        fieldName: field.name,
                        fieldSize: field.size,
                        startPos: currentPos + startPos,
                        endPos: currentPos + endPos,
                        value: value
                    });

                    fieldPos += field.size;
                });

                // ë ˆì½”ë“œ ê°ì²´ ì¶”ê°€
                records.push({
                    recordIndex: recordIndex,
                    structName: matchedStruct.name,
                    kubun: matchedStruct.kubun || null,
                    fields: fields
                });

                parsedBytes += expectedLength;
                currentPos += expectedLength;
                recordIndex++;
            }

            // 6. ê²°ê³¼ ë°˜í™˜
            console.log('parseStructData: ' + records.length + 'ê°œì˜ ë ˆì½”ë“œê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            return {
                records: records,
                stats: {
                    totalBytes: totalBytes,
                    parsedBytes: parsedBytes,
                    recordCount: records.length,
                    errorBytes: errorBytes
                }
            };
        }

        /**
         * =====================================================
         * ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
         * ì§€ì •ëœ ì»¨í…Œì´ë„ˆì— ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
         * =====================================================
         * @param {string} message - ì—ëŸ¬ ë©”ì‹œì§€
         * @param {string} targetContainer - íƒ€ê²Ÿ ì»¨í…Œì´ë„ˆ ID (ê¸°ë³¸: struct-result-container)
         */
        function displayError(message, targetContainer) {
            // 1. targetContainer ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’: struct-result-container)
            const containerId = targetContainer || 'struct-result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTMLì„ ì—ëŸ¬ ë©”ì‹œì§€ë¡œ ì„¤ì •
            container.innerHTML = `<div class="error-message">âš ï¸ ${message}</div>`;
        }

        /**
         * =====================================================
         * XML íŒŒì‹± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì í™”
         * =====================================================
         * @param {Array} parsedData - parseTelegramì˜ ê²°ê³¼ ë°°ì—´
         */
        function displayResults(parsedData) {
            // 1. result-container ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
            const container = document.getElementById('result-container');

            // 2. innerHTML ì´ˆê¸°í™”
            container.innerHTML = '';

            // DocumentFragment ìƒì„± - DOM ì¡°ì‘ ìµœì í™”
            const fragment = document.createDocumentFragment();

            // 3. table ìš”ì†Œ ìƒì„±
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead ìƒì„± í›„ tr ì¶”ê°€, th 7ê°œ
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['ìˆœë²ˆ', 'í•„ë“œëª…', 'íƒ€ì…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody ìƒì„±
            const tbody = document.createElement('tbody');

            // 6. parsedData ë°°ì—´ ìˆœíšŒ
            parsedData.forEach(function(item, index) {
                // tr ìƒì„±
                const tr = document.createElement('tr');

                // td 7ê°œ ìƒì„±
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    item.value
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    td.textContent = value;

                    // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ td, ì¦‰ value ì»¬ëŸ¼)
                    if (tdIndex === 6 && typeof value === 'string' && value.trim() === '') {
                        td.classList.add('empty-value');
                    }

                    tr.appendChild(td);
                });

                // tbodyì— tr ì¶”ê°€
                tbody.appendChild(tr);
            });

            // 7. tableì— thead, tbody ì¶”ê°€
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. ë°˜ì‘í˜•ì„ ìœ„í•œ wrapper div ìƒì„±
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. fragmentì— ì¶”ê°€ í›„ í•œ ë²ˆì— DOM ì—…ë°ì´íŠ¸
            fragment.appendChild(wrapper);
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ íŒŒì‹± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì í™”
         * =====================================================
         * @param {Object} parseResult - { records, stats } í˜•ì‹ì˜ íŒŒì‹± ê²°ê³¼
         *   - records: ë ˆì½”ë“œ ë°°ì—´ (ê° ë ˆì½”ë“œ: { recordIndex, structName, kubun, fields })
         *   - stats: í†µê³„ ì •ë³´ { totalBytes, parsedBytes, recordCount, errorBytes }
         */
        function displayStructResults(parseResult) {
            // 1. struct-result-container ì´ˆê¸°í™”
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!parseResult || !parseResult.records) {
                container.innerHTML = '<div class="error-message">âš ï¸ íŒŒì‹± ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            const { records, stats } = parseResult;

            // íŒŒì‹± ì„¤ì • ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;

            // DocumentFragment ìƒì„± - DOM ì¡°ì‘ ìµœì í™”
            const fragment = document.createDocumentFragment();

            // íŒŒì‹± ì„¤ì • ì •ë³´ í‘œì‹œ
            const settingsDiv = document.createElement('div');
            settingsDiv.className = 'parse-settings-info';
            settingsDiv.innerHTML = `
                <h4>âš™ï¸ íŒŒì‹± ì„¤ì •</h4>
                <div class="setting-item">
                    <span class="setting-label">ê°œí–‰ë¬¸ì ì¸ì‹:</span>
                    <span class="setting-value ${recognizeCRLF ? 'enabled' : 'disabled'}">
                        ${recognizeCRLF ? 'âœ“ í™œì„± (ê° ë ˆì½”ë“œ +2 bytes)' : 'âœ— ë¹„í™œì„±'}
                    </span>
                </div>
            `;
            fragment.appendChild(settingsDiv);

            // 2. í†µê³„ ì •ë³´ í‘œì‹œ
            if (stats) {
                const percent = stats.totalBytes > 0 
                    ? ((stats.parsedBytes / stats.totalBytes) * 100).toFixed(1) 
                    : 0;

                const statsDiv = document.createElement('div');
                statsDiv.className = 'parse-stats';

                statsDiv.innerHTML = `
                    <h3>ğŸ“Š íŒŒì‹± í†µê³„</h3>
                    <div class="stats-grid">
                        <div>ì „ì²´: ${stats.totalBytes} bytes</div>
                        <div>íŒŒì‹±: ${stats.parsedBytes} bytes (${percent}%)</div>
                        <div>ë ˆì½”ë“œ: ${stats.recordCount}ê°œ</div>
                        <div>ì˜¤ë¥˜: ${stats.errorBytes} bytes</div>
                    </div>
                `;

                fragment.appendChild(statsDiv);
            }

            // ë ˆì½”ë“œê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ í‘œì‹œ
            if (records.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'error-message';
                noDataDiv.textContent = 'âš ï¸ íŒŒì‹±ëœ ë ˆì½”ë“œê°€ ì—†ìŠµë‹ˆë‹¤.';
                fragment.appendChild(noDataDiv);
                container.appendChild(fragment);
                return;
            }

            // 3. ë ˆì½”ë“œë³„ ê·¸ë£¹í™” (recordIndex ê¸°ì¤€)
            const recordMap = new Map();
            records.forEach(function(record) {
                const idx = record.recordIndex;
                if (!recordMap.has(idx)) {
                    recordMap.set(idx, record);
                }
            });

            // 4. ê° ë ˆì½”ë“œë§ˆë‹¤ í…Œì´ë¸” ìƒì„±
            recordMap.forEach(function(record, recordIndex) {
                // ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ìƒì„±
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';

                // ë ˆì½”ë“œ í—¤ë” ìƒì„±
                const headerDiv = document.createElement('div');
                headerDiv.className = 'record-header';

                // ì œëª©: "ë ˆì½”ë“œ #N - êµ¬ì¡°ì²´ëª…"
                const title = document.createElement('h3');
                title.textContent = 'ë ˆì½”ë“œ #' + (recordIndex + 1) + ' - ' + record.structName;
                headerDiv.appendChild(title);

                // êµ¬ë¶„ê°’ ë°°ì§€
                const kubunBadge = document.createElement('span');
                kubunBadge.className = 'kubun-badge';
                kubunBadge.textContent = 'êµ¬ë¶„: ' + (record.kubun || 'N/A');
                headerDiv.appendChild(kubunBadge);

                // ë³µì‚¬ ë²„íŠ¼
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-record-btn';
                copyBtn.setAttribute('data-record', recordIndex);
                copyBtn.textContent = 'ğŸ“‹ ë³µì‚¬';
                headerDiv.appendChild(copyBtn);

                groupDiv.appendChild(headerDiv);

                // í…Œì´ë¸” ìƒì„±
                const table = document.createElement('table');
                table.className = 'result-table';

                // thead ìƒì„±
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['í•„ë“œëª…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody ìƒì„±
                const tbody = document.createElement('tbody');

                // í•´ë‹¹ ë ˆì½”ë“œì˜ ëª¨ë“  í•„ë“œë¥¼ í–‰ìœ¼ë¡œ ì¶”ê°€
                if (record.fields && record.fields.length > 0) {
                    record.fields.forEach(function(field) {
                        const tr = document.createElement('tr');

                        const values = [
                            field.fieldName,   // í•„ë“œëª…
                            field.fieldSize,   // í¬ê¸°
                            field.startPos,    // ì‹œì‘
                            field.endPos,      // ì¢…ë£Œ
                            field.value        // ê°’
                        ];

                        values.forEach(function(value, tdIndex) {
                            const td = document.createElement('td');
                            td.textContent = value;

                            // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ ì»¬ëŸ¼)
                            if (tdIndex === 4 && typeof value === 'string' && value.trim() === '') {
                                td.classList.add('empty-value');
                            }

                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                    });
                }

                table.appendChild(thead);
                table.appendChild(tbody);

                // ë°˜ì‘í˜• wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // fragmentì— ê·¸ë£¹ ì¶”ê°€
                fragment.appendChild(groupDiv);
            });

            // í•œ ë²ˆì— DOM ì—…ë°ì´íŠ¸
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * ì‹ ê·œ ë ˆì½”ë“œ ì…ë ¥ í¼ í‘œì‹œ í•¨ìˆ˜ (33ë‹¨ê³„)
         * êµ¬ì¡°ì²´ í•„ë“œ ë°°ì—´ì„ ë°›ì•„ ì…ë ¥ í¼ì„ ìƒì„±
         * CRLF í•„ë“œëŠ” ê°œí–‰ ì¸ì‹ ì˜µì…˜ì— ë”°ë¼ ìë™ ì²˜ë¦¬
         * =====================================================
         * @param {Array} fields - í•„ë“œ ë°°ì—´ [{name, size}, ...]
         * @param {HTMLElement} container - í¼ì„ í‘œì‹œí•  ì»¨í…Œì´ë„ˆ ìš”ì†Œ
         * @returns {HTMLElement} ìƒì„±ëœ í…Œì´ë¸” ìš”ì†Œ
         */
        function showNewRecordForm(fields, container) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!Array.isArray(fields) || fields.length === 0) {
                console.error('showNewRecordForm: ìœ íš¨í•˜ì§€ ì•Šì€ í•„ë“œ ë°°ì—´ì…ë‹ˆë‹¤.');
                return null;
            }
            
            if (!container || !(container instanceof HTMLElement)) {
                console.error('showNewRecordForm: ìœ íš¨í•˜ì§€ ì•Šì€ ì»¨í…Œì´ë„ˆì…ë‹ˆë‹¤.');
                return null;
            }
            
            // ê°œí–‰ë¬¸ì ì¸ì‹ ì˜µì…˜ í™•ì¸
            const recognizeCRLF = document.getElementById('recognize-crlf').checked;
            
            // í…Œì´ë¸” ìƒì„±
            const table = document.createElement('table');
            table.className = 'result-table new-record-form';
            
            // thead ìƒì„±
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['í•„ë“œëª…', 'í¬ê¸°', 'ì…ë ¥ê°’', 'ë¯¸ë¦¬ë³´ê¸°'];
            
            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // tbody ìƒì„±
            const tbody = document.createElement('tbody');
            
            // ê° í•„ë“œì— ëŒ€í•´ í–‰ ìƒì„±
            fields.forEach(function(field) {
                const tr = document.createElement('tr');
                
                // CRLF í•„ë“œ ì—¬ë¶€ í™•ì¸
                const isCRLFField = field.name && field.name.toLowerCase().match(/crlf|cr_lf|newline/);
                
                // í•„ë“œëª… ì…€
                const tdName = document.createElement('td');
                tdName.textContent = field.name;
                tr.appendChild(tdName);
                
                // í¬ê¸° ì…€
                const tdSize = document.createElement('td');
                tdSize.textContent = field.size;
                tr.appendChild(tdSize);
                
                // ì…ë ¥ê°’ ì…€
                const tdInput = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                
                if (isCRLFField && recognizeCRLF) {
                    // CRLF í•„ë“œì´ê³  ê°œí–‰ ì¸ì‹ í™œì„±í™”: ìë™ ì„¤ì •
                    input.value = '\\r\\n';
                    input.disabled = true;
                    input.className = 'auto-field';
                    input.title = 'ìë™ ì„¤ì •ë¨';
                } else {
                    // ì¼ë°˜ í•„ë“œ ë˜ëŠ” ê°œí–‰ ì¸ì‹ ë¹„í™œì„±í™”ëœ CRLF í•„ë“œ: ìˆ˜ë™ ì…ë ¥ ê°€ëŠ¥
                    input.className = 'new-field-input';
                    input.setAttribute('data-field', field.name);
                    input.setAttribute('data-size', field.size);
                    input.maxLength = field.size;
                    
                    if (isCRLFField) {
                        input.placeholder = 'ì˜ˆ: CR+LF ë˜ëŠ” ê³µë°±';
                    } else {
                        input.placeholder = field.name + ' ê°’ ì…ë ¥';
                    }
                    
                    // ì…ë ¥ê°’ ë³€ê²½ ì‹œ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
                    input.addEventListener('input', function() {
                        const previewCell = tr.querySelector('.preview-cell');
                        if (previewCell) {
                            previewCell.textContent = input.value || '';
                        }
                    });
                }
                
                tdInput.appendChild(input);
                tr.appendChild(tdInput);
                
                // ë¯¸ë¦¬ë³´ê¸° ì…€
                const tdPreview = document.createElement('td');
                tdPreview.className = 'preview-cell';
                
                if (isCRLFField && recognizeCRLF) {
                    tdPreview.textContent = '\\r\\n';
                } else {
                    tdPreview.textContent = '';
                }
                
                tr.appendChild(tdPreview);
                tbody.appendChild(tr);
            });
            
            table.appendChild(tbody);
            
            // ì»¨í…Œì´ë„ˆ ë¹„ìš°ê³  í…Œì´ë¸” ì¶”ê°€
            container.innerHTML = '';
            container.appendChild(table);
            
            console.log('showNewRecordForm: ' + fields.length + 'ê°œ í•„ë“œì˜ ì…ë ¥ í¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            return table;
        }

        /**
         * =====================================================
         * í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜
         * ë‹¤ì–‘í•œ ì…ë ¥ ìƒí™©ì— ëŒ€í•œ ìë™í™”ëœ í…ŒìŠ¤íŠ¸
         * =====================================================
         * @returns {Object} í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê°ì²´ { passed, failed, results }
         */
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            /**
             * ê°œë³„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í—¬í¼
             */
            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        passed++;
                        results.push({ name: name, passed: true });
                    } else {
                        failed++;
                        results.push({ name: name, passed: false, reason: result || 'ì‹¤íŒ¨' });
                    }
                } catch (e) {
                    failed++;
                    results.push({ name: name, passed: false, reason: e.message });
                }
            }

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 1: êµ¬ì¡°ì²´ 1ê°œë§Œ ìˆëŠ” ê²½ìš°
            // =========================================
            test('êµ¬ì¡°ì²´ 1ê°œë§Œ ìˆëŠ” ê²½ìš°', function() {
                const structDef = `typedef struct {
                    char field1[5];
                    char field2[10];
                } SingleStruct;`;
                
                const data = 'HELLO1234567890';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                
                const result = parseStructData(data, defs);
                if (result.records.length !== 1) return 'ë ˆì½”ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (result.records[0].fields.length !== 2) return 'í•„ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (result.records[0].fields[0].value !== 'HELLO') return 'ì²« ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                if (result.records[0].fields[1].value !== '1234567890') return 'ë‘ ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 2: êµ¬ì¡°ì²´ 5ê°œ ì´ìƒì¸ ê²½ìš°
            // =========================================
            test('êµ¬ì¡°ì²´ 5ê°œ ì´ìƒì¸ ê²½ìš°', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Type_A;
                    typedef struct { char type[1]; char data[4]; } Type_B;
                    typedef struct { char type[1]; char data[4]; } Type_C;
                    typedef struct { char type[1]; char data[4]; } Type_D;
                    typedef struct { char type[1]; char data[4]; } Type_E;
                `;
                
                const data = 'AAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 5) return 'êµ¬ì¡°ì²´ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + (defs ? defs.length : 0);
                
                const result = parseStructData(data, defs);
                // 5ì¤„ = 5ê°œ ë ˆì½”ë“œ
                if (result.records.length !== 5) return 'ë ˆì½”ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + result.records.length;
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 3: ë°ì´í„° ë¼ì¸ 100ê°œ ì´ìƒ
            // =========================================
            test('ë°ì´í„° ë¼ì¸ 100ê°œ ì´ìƒ', function() {
                const structDef = `typedef struct { char id[4]; char val[6]; } DataLine;`;
                
                // 100ê°œ ë¼ì¸ ìƒì„±
                let dataLines = [];
                for (let i = 0; i < 100; i++) {
                    const id = ('0000' + i).slice(-4);
                    dataLines.push(id + 'VALUE1');
                }
                const data = dataLines.join('\n');
                
                const defs = parseStructDefinitions(structDef);
                if (!defs) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                
                const result = parseStructData(data, defs);
                // 100ì¤„ = 100ê°œ ë ˆì½”ë“œ
                if (result.records.length !== 100) return 'ë ˆì½”ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + result.records.length;
                
                // ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ ë ˆì½”ë“œ ê²€ì¦
                if (result.records[0].fields[0].value !== '0000') return 'ì²« ë ˆì½”ë“œ ì²« í•„ë“œ ë¶ˆì¼ì¹˜';
                if (result.records[99].fields[0].value !== '0099') return 'ë§ˆì§€ë§‰ ë ˆì½”ë“œ ì²« í•„ë“œ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 4: ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„°
            // =========================================
            test('ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„° (ì§§ìŒ)', function() {
                const structDef = `typedef struct { char field1[10]; char field2[10]; } TestStruct;`;
                const data = 'SHORTDATA'; // 9ì (ì˜ˆìƒ: 20ì)
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // íŒŒì‹±ì€ ì„±ê³µí•´ì•¼ í•¨ (ë¶€ì¡±í•œ ë¶€ë¶„ì€ ë¹ˆ ë¬¸ìì—´)
                if (result.records.length !== 1) return 'ë ˆì½”ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (result.records[0].fields.length !== 2) return 'í•„ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (result.records[0].fields[0].value !== 'SHORTDATA') return 'ì²« ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                if (result.records[0].fields[1].value !== '') return 'ë‘ ë²ˆì§¸ í•„ë“œê°€ ë¹ˆ ë¬¸ìì—´ì´ì–´ì•¼ í•¨';
                
                return true;
            });

            test('ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„° (ê¹€)', function() {
                const structDef = `typedef struct { char field1[5]; } ShortStruct;`;
                const data = 'EXTRALONG_DATA_HERE'; // ì˜ˆìƒë³´ë‹¤ ê¸´ ë°ì´í„°
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // ì •ì˜ëœ í•„ë“œê¹Œì§€ë§Œ íŒŒì‹±
                if (result.records.length !== 1) return 'ë ˆì½”ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                if (result.records[0].fields[0].value !== 'EXTRA') return 'ê°’ ë¶ˆì¼ì¹˜: ' + result.records[0].fields[0].value;
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 5: ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²•
            // =========================================
            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - typedef ëˆ„ë½', function() {
                const structDef = `struct { char field[5]; } BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // nullì„ ë°˜í™˜í•´ì•¼ í•¨
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - ì¤‘ê´„í˜¸ ëˆ„ë½', function() {
                const structDef = `typedef struct char field[5]; BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - ì„¸ë¯¸ì½œë¡  ëˆ„ë½', function() {
                const structDef = `typedef struct { char field[5]; } BadStruct`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ë¹ˆ êµ¬ì¡°ì²´ (í•„ë“œ ì—†ìŒ)', function() {
                const structDef = `typedef struct { } EmptyStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // ë¹ˆ êµ¬ì¡°ì²´ëŠ” ì œì™¸ë˜ë¯€ë¡œ null ë°˜í™˜
                if (defs !== null) return 'ë¹ˆ êµ¬ì¡°ì²´ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 6: ë¹ˆ ì…ë ¥
            // =========================================
            test('ë¹ˆ ì…ë ¥ - êµ¬ì¡°ì²´ ì •ì˜', function() {
                const defs = parseStructDefinitions('');
                if (defs !== null) return 'ë¹ˆ ì…ë ¥ì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            test('ë¹ˆ ì…ë ¥ - ë°ì´í„°', function() {
                const structDef = `typedef struct { char field[5]; } TestStruct;`;
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData('', defs);
                
                if (result.records.length !== 0) return 'ë¹ˆ ë°ì´í„°ì¸ë° ê²°ê³¼ ìˆìŒ';
                return true;
            });

            test('ê³µë°±ë§Œ ìˆëŠ” ì…ë ¥', function() {
                const defs = parseStructDefinitions('   \n\t\n   ');
                if (defs !== null) return 'ê³µë°±ë§Œ ìˆëŠ”ë° íŒŒì‹±ë¨';
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 7: ì£¼ì„ ì²˜ë¦¬
            // =========================================
            test('í•œì¤„ ì£¼ì„ ì²˜ë¦¬', function() {
                const structDef = `typedef struct {
                    // ì´ê²ƒì€ ì£¼ì„ì…ë‹ˆë‹¤
                    char field1[5]; // í•„ë“œ ì„¤ëª…
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                if (defs[0].fields.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            test('ë¸”ë¡ ì£¼ì„ ì²˜ë¦¬', function() {
                const structDef = `typedef struct {
                    /* ë¸”ë¡ ì£¼ì„
                       ì—¬ëŸ¬ ì¤„ */
                    char field1[5];
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                if (defs[0].fields.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 8: êµ¬ì¡°ì²´ ë§¤ì¹­ ë¡œì§
            // =========================================
            test('êµ¬ì¡°ì²´ ë§¤ì¹­ - ì²« ê¸€ì ê¸°ì¤€', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Record_H;
                    typedef struct { char type[1]; char data[9]; } Record_D;
                `;
                
                const data = 'H1234\nD123456789';
                
                const defs = parseStructDefinitions(structDef);
                const result = parseStructData(data, defs);
                
                // H ë¼ì¸: 1ë ˆì½”ë“œ, D ë¼ì¸: 1ë ˆì½”ë“œ = 2ê°œ ë ˆì½”ë“œ
                if (result.records.length !== 2) return 'ë ˆì½”ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + result.records.length;
                
                // ì²« ë¼ì¸ì€ Record_H
                if (result.records[0].structName !== 'Record_H') return 'ì²« ë¼ì¸ êµ¬ì¡°ì²´ ë§¤ì¹­ ì‹¤íŒ¨';
                // ë‘ ë²ˆì§¸ ë¼ì¸ì€ Record_D
                if (result.records[1].structName !== 'Record_D') return 'ë‘ ë²ˆì§¸ ë¼ì¸ êµ¬ì¡°ì²´ ë§¤ì¹­ ì‹¤íŒ¨';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 9: XML íŒŒì‹±
            // =========================================
            test('XML íŒŒì‹± - ì •ìƒ', function() {
                const xml = `<packet>
                    <col id="field1" type="X" size="5" />
                    <col id="field2" type="N" size="10" />
                </packet>`;
                
                const spec = parseXMLSpec(xml);
                if (!spec || spec.length !== 2) return 'XML íŒŒì‹± ì‹¤íŒ¨';
                if (spec[0].id !== 'field1') return 'ì²« ë²ˆì§¸ í•„ë“œ ID ë¶ˆì¼ì¹˜';
                if (spec[1].size !== 10) return 'ë‘ ë²ˆì§¸ í•„ë“œ í¬ê¸° ë¶ˆì¼ì¹˜';
                
                return true;
            });

            test('XML íŒŒì‹± - ë¹ˆ ì…ë ¥', function() {
                const spec = parseXMLSpec('');
                if (spec !== null) return 'ë¹ˆ ì…ë ¥ì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            test('XML íŒŒì‹± - ì˜ëª»ëœ í˜•ì‹', function() {
                const spec = parseXMLSpec('<invalid><unclosed>');
                if (spec !== null) return 'ì˜ëª»ëœ XMLì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 10: í†µì „ë¬¸ íŒŒì‹±
            // =========================================
            test('í†µì „ë¬¸ íŒŒì‹± - ì •ìƒ', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="3" />
                    <col id="name" type="X" size="5" />
                </packet>`;
                const telegram = 'ABCHELLO';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                if (parsed[0].value !== 'ABC') return 'ì²« ë²ˆì§¸ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== 'HELLO') return 'ë‘ ë²ˆì§¸ ê°’ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            return { passed: passed, failed: failed, results: results };
        }

        /**
         * =====================================================
         * í…ŒìŠ¤íŠ¸ ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ UIì— í‘œì‹œ
         * =====================================================
         * @param {Object} testResult - runTests()ì˜ ë°˜í™˜ê°’
         */
        function displayTestResults(testResult) {
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            const div = document.createElement('div');
            div.className = 'test-results ' + (testResult.failed === 0 ? 'success' : 'failure');

            const title = document.createElement('h3');
            title.textContent = 'í…ŒìŠ¤íŠ¸ ê²°ê³¼: ' + testResult.passed + 'ê°œ í†µê³¼, ' + testResult.failed + 'ê°œ ì‹¤íŒ¨';
            div.appendChild(title);

            testResult.results.forEach(function(result) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                if (result.passed) {
                    item.innerHTML = '<span class="test-pass">âœ“</span> ' + result.name;
                } else {
                    item.innerHTML = '<span class="test-fail">âœ—</span> ' + result.name + 
                                   ' <small>(' + result.reason + ')</small>';
                }
                
                div.appendChild(item);
            });

            container.appendChild(div);
        }

        // =========================================
        // DOMContentLoaded ì´ë²¤íŠ¸ - ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        // =========================================
        document.addEventListener('DOMContentLoaded', function() {
            // =========================================
            // êµ¬ì¡°ì²´ ì¹´ë“œ ì´ˆê¸°í™” - ì²« ë²ˆì§¸ ì¹´ë“œ ìë™ ì¶”ê°€
            // =========================================
            const structContainer = document.getElementById('struct-definitions-container');
            structContainer.appendChild(createStructCard(0));
            structCardIndex = 1;

            // =========================================
            // êµ¬ì¡°ì²´ ì¶”ê°€ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            // =========================================
            document.getElementById('add-struct-btn').addEventListener('click', function() {
                const newCard = createStructCard(structCardIndex);
                structContainer.appendChild(newCard);
                structCardIndex++;
            });

            // =========================================
            // êµ¬ì¡°ì²´ ì‚­ì œ ë²„íŠ¼ ì´ë²¤íŠ¸ ìœ„ì„
            // =========================================
            structContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('remove-struct-btn')) {
                    // í´ë¦­ëœ ë²„íŠ¼ì˜ ë¶€ëª¨ .struct-card ì°¾ê¸°
                    const card = e.target.closest('.struct-card');
                    if (!card) return;

                    // í™•ì¸ ëŒ€í™”ìƒì
                    if (confirm('ì´ êµ¬ì¡°ì²´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        // í•´ë‹¹ ì¹´ë“œ ì œê±°
                        card.remove();

                        // ë‚¨ì€ ì¹´ë“œê°€ 0ê°œë©´ structCardIndexë¥¼ 0ìœ¼ë¡œ ë¦¬ì…‹
                        const remainingCards = structContainer.querySelectorAll('.struct-card');
                        if (remainingCards.length === 0) {
                            structCardIndex = 0;
                        }
                    }
                }
            });

            // ë„ì›€ë§ í† ê¸€ ì´ë²¤íŠ¸
            const helpToggle = document.querySelector('.help-toggle');
            const helpContent = document.querySelector('.help-content');
            
            if (helpToggle && helpContent) {
                helpToggle.addEventListener('click', function() {
                    helpToggle.classList.toggle('expanded');
                    helpContent.classList.toggle('expanded');
                });
            }

            // íƒ­ ì „í™˜ ì´ë²¤íŠ¸
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // ëª¨ë“  íƒ­ ë²„íŠ¼ì—ì„œ active ì œê±°
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // í´ë¦­ëœ ë²„íŠ¼ì— active ì¶”ê°€
                    this.classList.add('active');

                    // ëª¨ë“  íƒ­ ì½˜í…ì¸  ìˆ¨ê¸°ê¸°
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // ì„ íƒëœ íƒ­ ì½˜í…ì¸  í‘œì‹œ
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML ê·œê²© ìƒ˜í”Œ ì„¤ì •
                const sampleXml = `<packet id="ì†¡ê¸ˆì „ë¬¸" default=" ">
  <col id="í—¤ë”ì‹œì‘" type="X" size="6" />
  <col id="ê±°ë˜êµ¬ë¶„" type="X" size="2" />
  <col id="ê³„ì¢Œë²ˆí˜¸" type="N" size="12" />
  <col id="ì†¡ê¸ˆì•¡" type="N" size="15" />
  <col id="ë°›ëŠ”ì‚¬ëŒ" type="X" size="20" />
</packet>`;
                
                // í†µì „ë¬¸ ìƒ˜í”Œ ì„¤ì • (ì •í™•íˆ 55ì)
                const sampleTelegram = 'HEADER01123456789012000000000100000í™ê¸¸ë™              ';
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-inputê³¼ telegram-input ê°’ ê°€ì ¸ì˜¤ê¸°
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. ë‘˜ ë‹¤ trim()í•´ì„œ ë¹ˆ ë¬¸ìì—´ì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”", 'result-container');
                    return;
                }

                // 3. parseXMLSpec í˜¸ì¶œ, ê²°ê³¼ê°€ nullì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML íŒŒì‹± ì‹¤íŒ¨: í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”", 'result-container');
                    return;
                }

                // 4. parseTelegram í˜¸ì¶œ
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults í˜¸ì¶œ
                displayResults(parsedData);
            });

            // ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // êµ¬ì¡°ì²´ ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // 1. recognize-crlf ì²´í¬ë°•ìŠ¤ ìë™ ì²´í¬
                document.getElementById('recognize-crlf').checked = true;
                
                // 2. ê¸°ì¡´ ëª¨ë“  êµ¬ì¡°ì²´ ì¹´ë“œ ì‚­ì œ
                structContainer.innerHTML = '';
                
                // 3. structCardIndex = 0 ë¦¬ì…‹
                structCardIndex = 0;

                // 4. êµ¬ì¡°ì²´ 3ê°œ ì¶”ê°€
                const sampleStructs = [
                    {
                        // ì¹´ë“œ 1: DHF_H
                        name: 'DHF_H',
                        kubun: 'H',
                        definition: `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
  char crlf[2];
} DHF_H;`
                    },
                    {
                        // ì¹´ë“œ 2: DHF_D
                        name: 'DHF_D',
                        kubun: 'D',
                        definition: `typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
  char crlf[2];
} DHF_D;`
                    },
                    {
                        // ì¹´ë“œ 3: DHF_T
                        name: 'DHF_T',
                        kubun: 'T',
                        definition: `typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
  char crlf[2];
} DHF_T;`
                    }
                ];

                // ê° ìƒ˜í”Œ êµ¬ì¡°ì²´ë§ˆë‹¤ ì¹´ë“œ ìƒì„±
                sampleStructs.forEach(function(sample) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);
                    
                    // ì¹´ë“œ ë‚´ë¶€ ì…ë ¥ í•„ë“œì— ê°’ ì„¤ì •
                    card.querySelector('.struct-name').value = sample.name;
                    card.querySelector('.struct-kubun').value = sample.kubun;
                    card.querySelector('.struct-definition').value = sample.definition;
                    
                    structCardIndex++;
                });

                // 5. ë°ì´í„° ì„¤ì •
                // DHF_H: 1+2+7+2 = 12 bytes (ë°ì´í„° 10 + CRLF 2)
                // DHF_D: 1+16+20+2 = 39 bytes (ë°ì´í„° 37 + CRLF 2)
                // DHF_T: 1+10+20+2 = 33 bytes (ë°ì´í„° 31 + CRLF 2)
                // ì¼ë°˜ì ì¸ ì¤„ë°”ê¿ˆìœ¼ë¡œ ì…ë ¥, ê° ì¤„ì— \r\n ìë™ ì¶”ê°€ë¨
                const sampleData = `H881234567
D123456789012345600000000000000001000
D987654321098765400000000000000002000
T000000000200000000000000003000`;

                document.getElementById('struct-data').value = sampleData;
                
                // 6. ì™„ë£Œ ë©”ì‹œì§€ í‘œì‹œ
                alert('âœ“ ìƒ˜í”Œ ë¡œë“œ ì™„ë£Œ\n\nê°œí–‰ë¬¸ì ì¸ì‹ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.\nê° ë ˆì½”ë“œ ëì— ìë™ìœ¼ë¡œ CRLFê°€ ì¶”ê°€ë©ë‹ˆë‹¤.');
            });

            // êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                // 1. collectStructDefinitions() í˜¸ì¶œ
                const structDefs = collectStructDefinitions();
                
                // nullì´ë©´ ì¤‘ë‹¨ (ì—ëŸ¬ëŠ” í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ í‘œì‹œ)
                if (structDefs === null) {
                    return;
                }

                // 2. struct-data ê°’ ê°€ì ¸ì˜¤ê¸°, trim
                const data = document.getElementById('struct-data').value.trim();
                
                // ë¹„ì–´ìˆìœ¼ë©´ displayError("ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”")
                if (data === '') {
                    displayError('ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”', 'struct-result-container');
                    return;
                }

                // 3. parseStructData(data, structDefs) í˜¸ì¶œ
                const result = parseStructData(data, structDefs);

                // 4. displayStructResults(result) í˜¸ì¶œ
                displayStructResults(result);

                // 5. ì„±ê³µ ì‹œ ì½˜ì†”ì— ë¡œê·¸
                const count = result.stats.recordCount;
                const percent = result.stats.totalBytes > 0 
                    ? ((result.stats.parsedBytes / result.stats.totalBytes) * 100).toFixed(1)
                    : 0;
                console.log('íŒŒì‹± ì™„ë£Œ: ë ˆì½”ë“œ ' + count + 'ê°œ, ì„±ê³µë¥  ' + percent + '%');
            });

            // êµ¬ì¡°ì²´ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                // í™•ì¸ ëŒ€í™”ìƒì
                if (!confirm('ëª¨ë“  ì…ë ¥ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    return;
                }
                
                // 1. struct-definitions-container innerHTML = ''
                structContainer.innerHTML = '';
                
                // 2. struct-data value = ''
                document.getElementById('struct-data').value = '';
                
                // 3. struct-result-container innerHTML = ''
                document.getElementById('struct-result-container').innerHTML = '';
                
                // 4. structCardIndex = 0
                structCardIndex = 0;
                
                // 5. ì²« ë²ˆì§¸ ë¹ˆ ì¹´ë“œ ìë™ ì¶”ê°€
                structContainer.appendChild(createStructCard(structCardIndex));
                structCardIndex++;
            });

            // í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ë²„íŠ¼ì´ ì¡´ì¬í•  ê²½ìš°ì—ë§Œ)
            const runTestsBtn = document.getElementById('run-tests-btn');
            if (runTestsBtn) {
                runTestsBtn.addEventListener('click', function() {
                    const testResult = runTests();
                    displayTestResults(testResult);
                });
            }

            // ë³µì‚¬ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ì´ë²¤íŠ¸ ìœ„ì„ ì‚¬ìš©)
            document.getElementById('struct-result-container').addEventListener('click', function(e) {
                // í´ë¦­ëœ ìš”ì†Œê°€ ë³µì‚¬ ë²„íŠ¼ì¸ì§€ í™•ì¸
                if (!e.target.classList.contains('copy-record-btn')) {
                    return;
                }

                const btn = e.target;

                // 1. data-record ì†ì„±ì—ì„œ recordIndex ê°€ì ¸ì˜¤ê¸°
                const recordIndex = btn.getAttribute('data-record');

                // í•´ë‹¹ ë ˆì½”ë“œì˜ ê·¸ë£¹ ì°¾ê¸°
                const groupDiv = btn.closest('.struct-result-group');
                if (!groupDiv) {
                    return;
                }

                // í…Œì´ë¸”ì˜ tbodyì—ì„œ ëª¨ë“  í–‰ ê°€ì ¸ì˜¤ê¸°
                const tbody = groupDiv.querySelector('tbody');
                if (!tbody) {
                    return;
                }

                const rows = tbody.querySelectorAll('tr');
                
                // 2. TSV í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (í•„ë“œëª…\tí¬ê¸°\tê°’)
                const tsvLines = [];
                rows.forEach(function(row) {
                    const cells = row.querySelectorAll('td');
                    // 5ê°œ ì»¬ëŸ¼: í•„ë“œëª…, í¬ê¸°, ì‹œì‘, ì¢…ë£Œ, ê°’
                    if (cells.length >= 5) {
                        const fieldName = cells[0].textContent;  // í•„ë“œëª…
                        const size = cells[1].textContent;       // í¬ê¸°
                        const value = cells[4].textContent;      // ê°’
                        tsvLines.push(fieldName + '\t' + size + '\t' + value);
                    }
                });

                const tsvText = tsvLines.join('\n');

                // 3. í´ë¦½ë³´ë“œì— ë³µì‚¬
                navigator.clipboard.writeText(tsvText).then(function() {
                    // 4. ë³µì‚¬ ì„±ê³µ ì‹œ:
                    // - ë²„íŠ¼ í…ìŠ¤íŠ¸ â†’ "âœ“ ë³µì‚¬ë¨"
                    const originalText = btn.textContent;
                    const originalBg = btn.style.backgroundColor;
                    
                    btn.textContent = 'âœ“ ë³µì‚¬ë¨';
                    // - ë°°ê²½ìƒ‰ ì„ì‹œ ë³€ê²½
                    btn.style.backgroundColor = '#17a2b8';
                    
                    // - 2ì´ˆ í›„ ì›ë˜ëŒ€ë¡œ
                    setTimeout(function() {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = originalBg;
                    }, 2000);
                }).catch(function(err) {
                    console.error('í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:', err);
                    alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                });
            });

            // =========================================
            // êµ¬ì¡°ì²´ ì¹´ë“œ ì ‘ê¸°/í¼ì¹˜ê¸° ì´ë²¤íŠ¸
            // - í—¤ë” í´ë¦­ ì‹œ ë³¸ë¬¸ í† ê¸€
            // - ì•„ì´ì½˜ ë³€ê²½ (â–¼ â†” â–¶)
            // =========================================
            structContainer.addEventListener('click', function(e) {
                // ì‚­ì œ ë²„íŠ¼ì´ë‚˜ ë“œë˜ê·¸ í•¸ë“¤ í´ë¦­ ì‹œ ë¬´ì‹œ
                if (e.target.classList.contains('remove-struct-btn') || 
                    e.target.classList.contains('drag-handle')) {
                    return;
                }

                // í—¤ë” ì˜ì—­ í´ë¦­ í™•ì¸
                const header = e.target.closest('.struct-card-header');
                if (!header) return;

                const card = header.closest('.struct-card');
                if (!card) return;

                // collapsed í´ë˜ìŠ¤ í† ê¸€
                card.classList.toggle('collapsed');

                // ì ‘íŒ ìƒíƒœì—ì„œ êµ¬ì¡°ì²´ëª… ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
                updateStructPreview(card);
            });

            /**
             * êµ¬ì¡°ì²´ ë¯¸ë¦¬ë³´ê¸° í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
             * @param {HTMLElement} card - êµ¬ì¡°ì²´ ì¹´ë“œ ìš”ì†Œ
             */
            function updateStructPreview(card) {
                const preview = card.querySelector('.struct-preview');
                const nameInput = card.querySelector('.struct-name');
                const kubunInput = card.querySelector('.struct-kubun');

                if (card.classList.contains('collapsed') && preview) {
                    const name = nameInput ? nameInput.value.trim() : '';
                    const kubun = kubunInput ? kubunInput.value.trim() : '';
                    
                    let previewText = '';
                    if (name) previewText += name;
                    if (kubun) previewText += (name ? ' ' : '') + '[' + kubun + ']';
                    
                    preview.textContent = previewText ? '- ' + previewText : '';
                } else if (preview) {
                    preview.textContent = '';
                }
            }

            // ì…ë ¥ê°’ ë³€ê²½ ì‹œ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            structContainer.addEventListener('input', function(e) {
                if (e.target.classList.contains('struct-name') || 
                    e.target.classList.contains('struct-kubun')) {
                    const card = e.target.closest('.struct-card');
                    if (card) updateStructPreview(card);
                }
            });

            // =========================================
            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì¬ì •ë ¬ ê¸°ëŠ¥
            // HTML5 Drag API ì‚¬ìš©
            // =========================================
            let draggedCard = null;

            // ë“œë˜ê·¸ ì‹œì‘
            structContainer.addEventListener('dragstart', function(e) {
                const card = e.target.closest('.struct-card');
                if (!card) return;

                draggedCard = card;
                card.classList.add('dragging');

                // ë“œë˜ê·¸ ì´ë¯¸ì§€ ì„¤ì • (ì„ íƒì‚¬í•­)
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', card.getAttribute('data-index'));
            });

            // ë“œë˜ê·¸ ì¢…ë£Œ
            structContainer.addEventListener('dragend', function(e) {
                const card = e.target.closest('.struct-card');
                if (card) {
                    card.classList.remove('dragging');
                }
                draggedCard = null;

                // ëª¨ë“  drag-over í´ë˜ìŠ¤ ì œê±°
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });

                // ì¹´ë“œ ì¸ë±ìŠ¤ ì¬ì •ë ¬
                renumberStructCards();
            });

            // ë“œë˜ê·¸ ì˜¤ë²„
            structContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                const card = e.target.closest('.struct-card');
                if (!card || card === draggedCard) return;

                // drag-over í´ë˜ìŠ¤ ì¶”ê°€
                document.querySelectorAll('.struct-card.drag-over').forEach(function(c) {
                    c.classList.remove('drag-over');
                });
                card.classList.add('drag-over');
            });

            // ë“œë¡­
            structContainer.addEventListener('drop', function(e) {
                e.preventDefault();

                const targetCard = e.target.closest('.struct-card');
                if (!targetCard || !draggedCard || targetCard === draggedCard) return;

                // ë“œë˜ê·¸í•œ ì¹´ë“œë¥¼ íƒ€ê²Ÿ ìœ„ì¹˜ë¡œ ì´ë™
                const cards = Array.from(structContainer.querySelectorAll('.struct-card'));
                const draggedIndex = cards.indexOf(draggedCard);
                const targetIndex = cards.indexOf(targetCard);

                if (draggedIndex < targetIndex) {
                    // ì•„ë˜ë¡œ ì´ë™
                    targetCard.parentNode.insertBefore(draggedCard, targetCard.nextSibling);
                } else {
                    // ìœ„ë¡œ ì´ë™
                    targetCard.parentNode.insertBefore(draggedCard, targetCard);
                }

                targetCard.classList.remove('drag-over');
            });

            /**
             * êµ¬ì¡°ì²´ ì¹´ë“œ ë²ˆí˜¸ ì¬ì •ë ¬
             */
            function renumberStructCards() {
                const cards = structContainer.querySelectorAll('.struct-card');
                cards.forEach(function(card, index) {
                    const numberSpan = card.querySelector('.struct-number');
                    if (numberSpan) {
                        numberSpan.textContent = 'êµ¬ì¡°ì²´ #' + (index + 1);
                    }
                    card.setAttribute('data-index', index);
                });
            }

            // =========================================
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥/ë³µì› ê¸°ëŠ¥
            // - í˜ì´ì§€ ë– ë‚  ë•Œ ìë™ ì €ì¥
            // - ì¬ë°©ë¬¸ ì‹œ ë³µì› ì œì•ˆ
            // =========================================
            const STORAGE_KEY = 'structParserData';

            /**
             * í˜„ì¬ êµ¬ì¡°ì²´ ì •ì˜ë“¤ì„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
             */
            function saveToLocalStorage() {
                const cards = structContainer.querySelectorAll('.struct-card');
                const data = [];

                cards.forEach(function(card) {
                    const name = card.querySelector('.struct-name').value;
                    const kubun = card.querySelector('.struct-kubun').value;
                    const definition = card.querySelector('.struct-definition').value;
                    const collapsed = card.classList.contains('collapsed');

                    // í•˜ë‚˜ë¼ë„ ì…ë ¥ëœ ì¹´ë“œë§Œ ì €ì¥
                    if (name || kubun || definition) {
                        data.push({
                            name: name,
                            kubun: kubun,
                            definition: definition,
                            collapsed: collapsed
                        });
                    }
                });

                // ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ ì €ì¥
                if (data.length > 0) {
                    const saveData = {
                        structs: data,
                        structData: document.getElementById('struct-data').value,
                        savedAt: new Date().toISOString()
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
                    console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ë¨:', data.length + 'ê°œ êµ¬ì¡°ì²´');
                }
            }

            /**
             * ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë³µì›
             */
            function restoreFromLocalStorage() {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (!savedData) return;

                try {
                    const data = JSON.parse(savedData);
                    if (!data.structs || data.structs.length === 0) return;

                    // ì €ì¥ ì‹œê°„ í‘œì‹œ
                    const savedAt = new Date(data.savedAt);
                    const timeStr = savedAt.toLocaleString('ko-KR');

                    // ë³µì› ì•Œë¦¼ í‘œì‹œ
                    showRestoreNotification(data, timeStr);
                } catch (e) {
                    console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨:', e);
                }
            }

            /**
             * ë³µì› ì•Œë¦¼ UI í‘œì‹œ
             */
            function showRestoreNotification(data, timeStr) {
                // ê¸°ì¡´ ì•Œë¦¼ ì œê±°
                const existingNotif = document.querySelector('.restore-notification');
                if (existingNotif) existingNotif.remove();

                const notification = document.createElement('div');
                notification.className = 'restore-notification';
                notification.innerHTML = `
                    <span class="restore-notification-text">
                        ğŸ“ ì´ì „ ì‘ì—…ì„ ë³µì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (${timeStr}, ${data.structs.length}ê°œ êµ¬ì¡°ì²´)
                    </span>
                    <div class="restore-notification-actions">
                        <button class="restore-btn primary" id="restore-yes">ë³µì›</button>
                        <button class="restore-btn secondary" id="restore-no">ë¬´ì‹œ</button>
                    </div>
                `;

                // struct-input-section ì•ì— ì‚½ì…
                const inputSection = document.getElementById('struct-input-section');
                inputSection.parentNode.insertBefore(notification, inputSection);

                // ë³µì› ë²„íŠ¼ ì´ë²¤íŠ¸
                document.getElementById('restore-yes').addEventListener('click', function() {
                    doRestore(data);
                    notification.remove();
                });

                // ë¬´ì‹œ ë²„íŠ¼ ì´ë²¤íŠ¸
                document.getElementById('restore-no').addEventListener('click', function() {
                    notification.remove();
                    localStorage.removeItem(STORAGE_KEY); // ì €ì¥ëœ ë°ì´í„° ì‚­ì œ
                });
            }

            /**
             * ì‹¤ì œ ë³µì› ìˆ˜í–‰
             */
            function doRestore(data) {
                // ê¸°ì¡´ ì¹´ë“œ ì‚­ì œ
                structContainer.innerHTML = '';
                structCardIndex = 0;

                // ì €ì¥ëœ êµ¬ì¡°ì²´ ë³µì›
                data.structs.forEach(function(struct) {
                    const card = createStructCard(structCardIndex);
                    structContainer.appendChild(card);

                    card.querySelector('.struct-name').value = struct.name || '';
                    card.querySelector('.struct-kubun').value = struct.kubun || '';
                    card.querySelector('.struct-definition').value = struct.definition || '';

                    if (struct.collapsed) {
                        card.classList.add('collapsed');
                        updateStructPreview(card);
                    }

                    structCardIndex++;
                });

                // ë°ì´í„° ë³µì›
                if (data.structData) {
                    document.getElementById('struct-data').value = data.structData;
                }

                console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë³µì›ë¨:', data.structs.length + 'ê°œ êµ¬ì¡°ì²´');
            }

            // í˜ì´ì§€ ë– ë‚  ë•Œ ìë™ ì €ì¥
            window.addEventListener('beforeunload', function() {
                saveToLocalStorage();
            });

            // í˜ì´ì§€ ë¡œë“œ ì‹œ ë³µì› ì œì•ˆ í‘œì‹œ
            // êµ¬ì¡°ì²´ íƒ­ì´ í™œì„±í™”ë  ë•Œê¹Œì§€ ëŒ€ê¸°
            setTimeout(function() {
                restoreFromLocalStorage();
            }, 100);

            // =========================================
            // ë‹¤í¬ëª¨ë“œ í† ê¸€ ê¸°ëŠ¥
            // - localStorageì— í…Œë§ˆ ì„¤ì • ì €ì¥
            // =========================================
            const THEME_KEY = 'structParserTheme';
            const themeToggle = document.getElementById('theme-toggle');

            /**
             * í…Œë§ˆ ì´ˆê¸°í™”
             */
            function initTheme() {
                const savedTheme = localStorage.getItem(THEME_KEY);
                if (savedTheme === 'dark') {
                    document.body.classList.add('dark-mode');
                    themeToggle.textContent = 'â˜€ï¸';
                } else {
                    themeToggle.textContent = 'ğŸŒ™';
                }
            }

            /**
             * í…Œë§ˆ í† ê¸€
             */
            function toggleTheme() {
                const isDark = document.body.classList.toggle('dark-mode');
                localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
                themeToggle.textContent = isDark ? 'â˜€ï¸' : 'ğŸŒ™';
            }

            // í…Œë§ˆ ì´ˆê¸°í™”
            initTheme();

            // í…Œë§ˆ í† ê¸€ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            themeToggle.addEventListener('click', toggleTheme);

            // =========================================
            // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
            // - Ctrl+Enter: íŒŒì‹± ì‹¤í–‰
            // - Ctrl+N: êµ¬ì¡°ì²´ ì¶”ê°€
            // =========================================
            document.addEventListener('keydown', function(e) {
                // Ctrl+Enter: íŒŒì‹± ì‹¤í–‰
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    
                    // í˜„ì¬ í™œì„±í™”ëœ íƒ­ í™•ì¸
                    const xmlTabActive = document.getElementById('xml-tab').classList.contains('active');
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');

                    if (xmlTabActive) {
                        document.getElementById('parse-btn').click();
                    } else if (structTabActive) {
                        document.getElementById('struct-parse-btn').click();
                    }
                }

                // Ctrl+N: êµ¬ì¡°ì²´ ì¶”ê°€ (struct íƒ­ì—ì„œë§Œ)
                if (e.ctrlKey && e.key === 'n') {
                    const structTabActive = document.getElementById('struct-tab').classList.contains('active');
                    if (structTabActive) {
                        e.preventDefault();
                        document.getElementById('add-struct-btn').click();
                    }
                }
            });
        });
    </script>
</body>
</html>
