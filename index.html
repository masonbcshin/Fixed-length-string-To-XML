<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>í†µì „ë¬¸ íŒŒì„œ</title>
    <style>
        /* ì „ì²´ ë ˆì´ì•„ì›ƒ */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        /* ì…ë ¥ ì˜ì—­ */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* ê²°ê³¼ ì˜ì—­ */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        #result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7) {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* ë°˜ì‘í˜• í…Œì´ë¸” ë˜í¼ */
        .table-wrapper {
            overflow-x: auto;
        }

        /* ë²„íŠ¼ ê·¸ë£¹ */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* ì—ëŸ¬ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* íŒŒì‹± ì—ëŸ¬ ìŠ¤íƒ€ì¼ */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* íƒ­ ìŠ¤íƒ€ì¼ */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* êµ¬ì¡°ì²´ ê²°ê³¼ ê·¸ë£¹ ìŠ¤íƒ€ì¼ */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* êµ¬ì¡°ì²´ ìš”ì•½ ì •ë³´ ìŠ¤íƒ€ì¼ */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* ëª¨ë°”ì¼ ëŒ€ì‘ */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>í†µì „ë¬¸ íŒŒì„œ</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML íŒŒì‹±</button>
        <button class="tab-btn" data-tab="struct">C êµ¬ì¡°ì²´ íŒŒì‹±</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        <div id="input-section">
            <label for="xml-input">XML ê·œê²©</label>
            <textarea id="xml-input" rows="10" placeholder="XML ê·œê²© ì…ë ¥"></textarea>
            
            <label for="telegram-input">í†µì „ë¬¸</label>
            <textarea id="telegram-input" rows="5" placeholder="í†µì „ë¬¸ ì…ë ¥"></textarea>
        </div>
        
        <div class="button-group">
            <button id="sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
            <button id="parse-btn">íŒŒì‹± ì‹¤í–‰</button>
            <button id="clear-btn">ì´ˆê¸°í™”</button>
        </div>
        
        <div id="result-container"></div>
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <div id="struct-input-section">
            <label for="struct-definitions">C êµ¬ì¡°ì²´ ì •ì˜ (ì—¬ëŸ¬ ê°œ ì…ë ¥ ê°€ëŠ¥)</label>
            <textarea id="struct-definitions" rows="20" placeholder="typedef struct { ... } êµ¬ì¡°ì²´ëª…; í˜•ì‹ìœ¼ë¡œ ì…ë ¥"></textarea>
            
            <label for="struct-data">í†µ ë°ì´í„°</label>
            <textarea id="struct-data" rows="8" placeholder="êµ¬ë¶„ê°’ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë°ì´í„° ì…ë ¥ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
                <button id="struct-parse-btn">íŒŒì‹± ì‹¤í–‰</button>
                <button id="struct-clear-btn">ì´ˆê¸°í™”</button>
            </div>
        </div>

        <div id="struct-result-container"></div>
    </div>

    <script>
        // XML ê·œê²© ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ ë°°ì—´ë¡œ ë³€í™˜
        function parseXMLSpec(xmlString) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: ì…ë ¥ê°’ì´ ë¬¸ìì—´ì´ ì•„ë‹™ë‹ˆë‹¤.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: ë¹ˆ ë¬¸ìì—´ì´ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                return null;
            }

            // DOMParserë¥¼ ì‚¬ìš©í•´ XML ë¬¸ì„œë¡œ ë³€í™˜
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', e.message);
                return null;
            }

            // parsererror ì²´í¬
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', parseError.textContent);
                return null;
            }

            // ëª¨ë“  col ìš”ì†Œ ì„ íƒ
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return [];
            }

            // ìœ íš¨í•œ col ìš”ì†Œë“¤ì„ ë‹´ì„ ë°°ì—´
            const result = [];

            // ê° col ìš”ì†Œ ì²˜ë¦¬
            colElements.forEach((col, index) => {
                // ì†ì„± ì¶”ì¶œ
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // í•„ìˆ˜ ì†ì„± ê²€ì¦
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì— í•„ìˆ˜ ì†ì„±ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: ${missingAttrs.join(', ')}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // sizeë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜
                const size = parseInt(sizeAttr, 10);

                // sizeê°€ ìœ íš¨í•œ ì •ìˆ˜ì¸ì§€ ê²€ì¦
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤: "${sizeAttr}"`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: ${size}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // ìœ íš¨í•œ col ì •ë³´ë¥¼ ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        // í†µì „ë¬¸ì„ XML ê·œê²©ì— ë§ê²Œ íŒŒì‹±
        function parseTelegram(telegramString, xmlSpec) {
            // í˜„ì¬ ìœ„ì¹˜ ì´ˆê¸°í™”
            let currentPos = 0;

            // ë¹ˆ ê²°ê³¼ ë°°ì—´ ìƒì„±
            const result = [];

            // xmlSpec ë°°ì—´ ìˆœíšŒ
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // ì‹œì‘/ì¢…ë£Œ ìœ„ì¹˜ ê³„ì‚°
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substringìœ¼ë¡œ ê°’ ì¶”ì¶œ (ì¸ë±ìŠ¤ ë²”ìœ„ ì´ˆê³¼í•´ë„ ì˜¤ë¥˜ ì—†ì´ ì²˜ë¦¬ë¨)
                const value = telegramString.substring(startPos, endPos);

                // ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // í˜„ì¬ ìœ„ì¹˜ ì´ë™
                currentPos += spec.size;
            }

            // í†µì „ë¬¸ ì „ì²´ ê¸¸ì´ì™€ ì˜ˆìƒ ê¸¸ì´ ë¹„êµ
            if (telegramString.length !== currentPos) {
                console.warn(
                    `parseTelegram: í†µì „ë¬¸ ê¸¸ì´(${telegramString.length})ì™€ ì˜ˆìƒ ê¸¸ì´(${currentPos})ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`
                );
            }

            return result;
        }

        // C êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ êµ¬ì¡°ì²´ ë°°ì—´ë¡œ ë³€í™˜
        function parseStructDefinitions(structText) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // typedef struct ë¸”ë¡ ì¶”ì¶œ ì •ê·œì‹
            const structPattern = /typedef\s+struct\s*\{([^}]+)\}\s*(\w+)\s*;/g;
            
            // í•„ë“œ ì¶”ì¶œ ì •ê·œì‹
            const fieldPattern = /char\s+(\w+)\s*\[\s*(\d+)\s*\]/g;
            
            // ê²°ê³¼ ë°°ì—´
            const result = [];
            
            // typedef struct ë¸”ë¡ë“¤ ì¶”ì¶œ
            let structMatch;
            while ((structMatch = structPattern.exec(structText)) !== null) {
                const fieldsContent = structMatch[1]; // ì¤‘ê´„í˜¸ ì•ˆì˜ ë‚´ìš©
                const structName = structMatch[2];    // êµ¬ì¡°ì²´ëª…
                
                // í•„ë“œ ë°°ì—´
                const fields = [];
                
                // í•„ë“œë“¤ ì¶”ì¶œ
                let fieldMatch;
                // ê° êµ¬ì¡°ì²´ë§ˆë‹¤ fieldPatternì˜ lastIndexë¥¼ ë¦¬ì…‹í•´ì•¼ í•¨
                fieldPattern.lastIndex = 0;
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    fields.push({
                        name: fieldMatch[1],
                        size: parseInt(fieldMatch[2], 10)
                    });
                }
                
                // êµ¬ì¡°ì²´ ê°ì²´ ì¶”ê°€
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // êµ¬ì¡°ì²´ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ë°˜í™˜
            if (result.length === 0) {
                console.error('parseStructDefinitions: íŒŒì‹±ëœ êµ¬ì¡°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return null;
            }
            
            // íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì¶œë ¥
            console.log('parseStructDefinitions: ' + result.length + 'ê°œì˜ êµ¬ì¡°ì²´ê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            return result;
        }

        // ë°ì´í„° ë¼ì¸ì— ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì°¾ê¸°
        function findMatchingStruct(line, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. êµ¬ì¡°ì²´ê°€ 1ê°œë§Œ ìˆìœ¼ë©´ ê·¸ê²ƒ ë°˜í™˜
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ë§¤ì¹­ ë¡œì§
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // í•„ë“œê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // ì²« ë²ˆì§¸ í•„ë“œì˜ sizeë§Œí¼ lineì—ì„œ ì¶”ì¶œ
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // êµ¬ì¡°ì²´ëª…ì—ì„œ êµ¬ë¶„ íŒ¨í„´ ì¶”ì¶œ
                // ì˜ˆ: DHF_H â†’ 'H', DHF_D â†’ 'D', ST_HEADER_1 â†’ '1'
                const structName = structDef.name;
                
                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ (ì–¸ë”ìŠ¤ì½”ì–´ ë’¤ ë˜ëŠ” ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ì)
                let structIdentifier = '';
                
                // ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // ë§ˆì§€ë§‰ ë¶€ë¶„ì´ ë‹¨ì¼ ë¬¸ì ë˜ëŠ” ìˆ«ìì¸ ê²½ìš°
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ìˆ«ì ì¶”ì¶œ ì‹œë„
                    const numMatch = lastPart.match(/(\d+)$/);
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // ë§ˆì§€ë§‰ ë¬¸ì ì‚¬ìš©
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ìì™€ line ì²« ë¬¸ì ë¹„êµ
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // ì²« í•„ë“œ ê°’ê³¼ êµ¬ì¡°ì²´ ì‹ë³„ì ë¹„êµ
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜, ì½˜ì†”ì— ê²½ê³ 
            console.warn('findMatchingStruct: ë¼ì¸ "' + line.substring(0, 20) + '..."ì— ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return null;
        }

        // í†µ ë°ì´í„°ë¥¼ êµ¬ì¡°ì²´ ì •ì˜ì— ë§ê²Œ íŒŒì‹±
        function parseStructData(dataText, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: ë°ì´í„° í…ìŠ¤íŠ¸ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return [];
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: êµ¬ì¡°ì²´ ì •ì˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return [];
            }

            // 1. dataTextë¥¼ ì¤„ë°”ê¿ˆìœ¼ë¡œ split, ë¹ˆ ì¤„ ì œê±°
            const lines = dataText.split('\n').filter(function(line) {
                return line.trim() !== '';
            });

            // 2. ê²°ê³¼ ë°°ì—´ ì´ˆê¸°í™”
            const result = [];

            // 3. ê° ë¼ì¸ë§ˆë‹¤ ì²˜ë¦¬
            lines.forEach(function(line, lineIndex) {
                const lineNumber = lineIndex + 1;

                // findMatchingStruct í—¬í¼ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì°¾ê¸°
                const matchedStruct = findMatchingStruct(line, structDefs);

                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ê°ì²´ ì¶”ê°€
                if (!matchedStruct) {
                    result.push({
                        error: true,
                        lineNumber: lineNumber,
                        line: line,
                        message: 'ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì—†ìŒ'
                    });
                    return; // ë‹¤ìŒ ë¼ì¸ìœ¼ë¡œ continue
                }

                // d. ë§¤ì¹­ëœ êµ¬ì¡°ì²´ fieldsë¥¼ ìˆœíšŒí•˜ë©° íŒŒì‹±
                let currentPos = 0;
                matchedStruct.fields.forEach(function(field) {
                    const startPos = currentPos;
                    const endPos = currentPos + field.size;
                    const value = line.substring(startPos, endPos);

                    result.push({
                        structName: matchedStruct.name,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value: value,
                        lineNumber: lineNumber,
                        startPos: startPos,
                        endPos: endPos
                    });

                    currentPos += field.size;
                });

                // ë¼ì¸ ê¸¸ì´ ê²€ì¦ ê²½ê³ 
                const expectedLength = matchedStruct.fields.reduce(function(sum, f) {
                    return sum + f.size;
                }, 0);
                
                if (line.length !== expectedLength) {
                    console.warn('ë¼ì¸ ' + lineNumber + ': ì˜ˆìƒ ê¸¸ì´ ' + expectedLength + ', ì‹¤ì œ ê¸¸ì´ ' + line.length);
                }
            });

            // 4. ê²°ê³¼ ë°°ì—´ ë°˜í™˜
            console.log('parseStructData: ' + result.length + 'ê°œì˜ í•„ë“œê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            return result;
        }

        // ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
        function displayError(message, targetContainer) {
            // 1. targetContainer ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’: result-container)
            const containerId = targetContainer || 'result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTMLì„ ì—ëŸ¬ ë©”ì‹œì§€ë¡œ ì„¤ì •
            container.innerHTML = `<div class="error-message">âš ï¸ ${message}</div>`;
        }

        // íŒŒì‹± ê²°ê³¼ë¥¼ í…Œì´ë¸”ë¡œ í‘œì‹œ
        function displayResults(parsedData) {
            // 1. result-container ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
            const container = document.getElementById('result-container');

            // 2. innerHTML ì´ˆê¸°í™”
            container.innerHTML = '';

            // 3. table ìš”ì†Œ ìƒì„±
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead ìƒì„± í›„ tr ì¶”ê°€, th 7ê°œ
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['ìˆœë²ˆ', 'í•„ë“œëª…', 'íƒ€ì…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody ìƒì„±
            const tbody = document.createElement('tbody');

            // 6. parsedData ë°°ì—´ ìˆœíšŒ
            parsedData.forEach(function(item, index) {
                // tr ìƒì„±
                const tr = document.createElement('tr');

                // td 7ê°œ ìƒì„±
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    item.value
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    td.textContent = value;

                    // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ td, ì¦‰ value ì»¬ëŸ¼)
                    if (tdIndex === 6 && typeof value === 'string' && value.trim() === '') {
                        td.classList.add('empty-value');
                    }

                    tr.appendChild(td);
                });

                // tbodyì— tr ì¶”ê°€
                tbody.appendChild(tr);
            });

            // 7. tableì— thead, tbody ì¶”ê°€
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. ë°˜ì‘í˜•ì„ ìœ„í•œ wrapper div ìƒì„±
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. result-containerì— wrapper ì¶”ê°€
            container.appendChild(wrapper);
        }

        // êµ¬ì¡°ì²´ íŒŒì‹± ê²°ê³¼ë¥¼ í…Œì´ë¸”ë¡œ í‘œì‹œ
        function displayStructResults(parsedData, structDefs) {
            // 1. struct-result-container ì´ˆê¸°í™”
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // ì—ëŸ¬ê°€ ìˆëŠ”ì§€ í™•ì¸
            const errors = parsedData.filter(function(item) {
                return item.error === true;
            });

            // ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ - ê° ì—ëŸ¬ë¥¼ ê°œë³„ parse-error ë°•ìŠ¤ë¡œ í‘œì‹œ
            errors.forEach(function(e) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'parse-error';
                errorDiv.textContent = 'ë¼ì¸ ' + e.lineNumber + ' íŒŒì‹± ì‹¤íŒ¨: ' + e.line;
                container.appendChild(errorDiv);
            });

            // ì •ìƒ íŒŒì‹± ê²°ê³¼ë§Œ í•„í„°ë§
            const validData = parsedData.filter(function(item) {
                return item.error !== true;
            });

            if (validData.length === 0) {
                if (errors.length === 0) {
                    container.innerHTML = '<div class="error-message">âš ï¸ íŒŒì‹± ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                }
                return;
            }

            // êµ¬ì¡°ì²´ ìš”ì•½ ì •ë³´ í‘œì‹œ
            if (structDefs && structDefs.length > 0) {
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'struct-summary';

                // ì œëª©
                const title = document.createElement('h3');
                title.textContent = 'ğŸ“‹ íŒŒì‹± ì •ë³´';
                summaryDiv.appendChild(title);

                // êµ¬ì¡°ì²´ ìˆ˜
                const structCountP = document.createElement('p');
                structCountP.textContent = 'êµ¬ì¡°ì²´ ìˆ˜: ' + structDefs.length + 'ê°œ';
                summaryDiv.appendChild(structCountP);

                // ê° êµ¬ì¡°ì²´ëª…ê³¼ ì´ í¬ê¸° ëª©ë¡
                const structList = document.createElement('ul');
                structDefs.forEach(function(structDef) {
                    const li = document.createElement('li');
                    // êµ¬ì¡°ì²´ì˜ ì´ í¬ê¸° ê³„ì‚° (ëª¨ë“  í•„ë“œ size í•©ì‚°)
                    const totalSize = structDef.fields.reduce(function(sum, field) {
                        return sum + field.size;
                    }, 0);
                    li.textContent = structDef.name + ': ' + totalSize + ' bytes';
                    structList.appendChild(li);
                });
                summaryDiv.appendChild(structList);

                // ì²˜ë¦¬ëœ ë°ì´í„° ë¼ì¸ ìˆ˜ ê³„ì‚° (unique lineNumber ê°œìˆ˜)
                const uniqueLines = {};
                validData.forEach(function(item) {
                    uniqueLines[item.lineNumber] = true;
                });
                const lineCount = Object.keys(uniqueLines).length;

                const lineCountP = document.createElement('p');
                lineCountP.textContent = 'ë°ì´í„° ë¼ì¸: ' + lineCount + 'ê°œ';
                summaryDiv.appendChild(lineCountP);

                container.appendChild(summaryDiv);
            }

            // 2. ë¼ì¸ë³„ë¡œ ê·¸ë£¹í™”
            const groupedByLine = {};
            validData.forEach(function(item) {
                const lineNum = item.lineNumber;
                if (!groupedByLine[lineNum]) {
                    groupedByLine[lineNum] = {
                        structName: item.structName,
                        fields: []
                    };
                }
                groupedByLine[lineNum].fields.push(item);
            });

            // 3. ê° ë¼ì¸ë§ˆë‹¤ í…Œì´ë¸” ìƒì„±
            const lineNumbers = Object.keys(groupedByLine).sort(function(a, b) {
                return parseInt(a) - parseInt(b);
            });

            lineNumbers.forEach(function(lineNum) {
                const lineData = groupedByLine[lineNum];

                // ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ìƒì„±
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';

                // ì œëª©: "ë¼ì¸ N - êµ¬ì¡°ì²´ëª…"
                const title = document.createElement('h3');
                title.textContent = 'ë¼ì¸ ' + lineNum + ' - ' + lineData.structName;
                groupDiv.appendChild(title);

                // í…Œì´ë¸” ìƒì„±
                const table = document.createElement('table');
                table.id = 'result-table';

                // thead ìƒì„±
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['ìˆœë²ˆ', 'í•„ë“œëª…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody ìƒì„±
                const tbody = document.createElement('tbody');

                // í•´ë‹¹ ë¼ì¸ì˜ ëª¨ë“  í•„ë“œë¥¼ í–‰ìœ¼ë¡œ ì¶”ê°€
                lineData.fields.forEach(function(item, index) {
                    const tr = document.createElement('tr');

                    const values = [
                        index + 1,       // ìˆœë²ˆ
                        item.fieldName,  // í•„ë“œëª…
                        item.fieldSize,  // í¬ê¸°
                        item.startPos,   // ì‹œì‘
                        item.endPos,     // ì¢…ë£Œ
                        item.value       // ê°’
                    ];

                    values.forEach(function(value, tdIndex) {
                        const td = document.createElement('td');
                        td.textContent = value;

                        // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ ì»¬ëŸ¼)
                        if (tdIndex === 5 && typeof value === 'string' && value.trim() === '') {
                            td.classList.add('empty-value');
                        }

                        tr.appendChild(td);
                    });

                    tbody.appendChild(tr);
                });

                table.appendChild(thead);
                table.appendChild(tbody);

                // ë°˜ì‘í˜• wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // 4. ì»¨í…Œì´ë„ˆì— ê·¸ë£¹ ì¶”ê°€
                container.appendChild(groupDiv);
            });
        }

        // DOMContentLoaded ì´ë²¤íŠ¸
        document.addEventListener('DOMContentLoaded', function() {
            // íƒ­ ì „í™˜ ì´ë²¤íŠ¸
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // ëª¨ë“  íƒ­ ë²„íŠ¼ì—ì„œ active ì œê±°
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // í´ë¦­ëœ ë²„íŠ¼ì— active ì¶”ê°€
                    this.classList.add('active');

                    // ëª¨ë“  íƒ­ ì½˜í…ì¸  ìˆ¨ê¸°ê¸°
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // ì„ íƒëœ íƒ­ ì½˜í…ì¸  í‘œì‹œ
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML ê·œê²© ìƒ˜í”Œ ì„¤ì •
                const sampleXml = `<packet id="ì†¡ê¸ˆì „ë¬¸" default=" ">
  <col id="í—¤ë”ì‹œì‘" type="X" size="6" />
  <col id="ê±°ë˜êµ¬ë¶„" type="X" size="2" />
  <col id="ê³„ì¢Œë²ˆí˜¸" type="N" size="12" />
  <col id="ì†¡ê¸ˆì•¡" type="N" size="15" />
  <col id="ë°›ëŠ”ì‚¬ëŒ" type="X" size="20" />
</packet>`;
                
                // í†µì „ë¬¸ ìƒ˜í”Œ ì„¤ì • (ì •í™•íˆ 55ì)
                const sampleTelegram = 'HEADER01123456789012000000000100000í™ê¸¸ë™              ';
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-inputê³¼ telegram-input ê°’ ê°€ì ¸ì˜¤ê¸°
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. ë‘˜ ë‹¤ trim()í•´ì„œ ë¹ˆ ë¬¸ìì—´ì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”");
                    return;
                }

                // 3. parseXMLSpec í˜¸ì¶œ, ê²°ê³¼ê°€ nullì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML íŒŒì‹± ì‹¤íŒ¨: í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”");
                    return;
                }

                // 4. parseTelegram í˜¸ì¶œ
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults í˜¸ì¶œ
                displayResults(parsedData);
            });

            // ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // êµ¬ì¡°ì²´ ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // C êµ¬ì¡°ì²´ ì •ì˜ ìƒ˜í”Œ (DHF_H, DHF_D, DHF_T)
                const sampleStructDef = `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
} DHF_H;

typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
} DHF_D;

typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
} DHF_T;`;

                // í†µ ë°ì´í„° ìƒ˜í”Œ (êµ¬ì¡°ì²´ ê¸¸ì´ì— ë§ê²Œ ì¡°ì •)
                // DHF_H: 1+2+7 = 10ì
                // DHF_D: 1+16+20 = 37ì
                // DHF_T: 1+10+20 = 31ì
                const sampleData = `H881234567
D123456789012345600000000000000100000
D987654321098765400000000000000200000
T000000000200000000000000300000`;

                document.getElementById('struct-definitions').value = sampleStructDef;
                document.getElementById('struct-data').value = sampleData;
            });

            // êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                // 1. struct-definitions ê°’ ê°€ì ¸ì˜¤ê¸°, trim
                const structDefInput = document.getElementById('struct-definitions').value.trim();
                
                // 2. struct-data ê°’ ê°€ì ¸ì˜¤ê¸°, trim
                const dataInput = document.getElementById('struct-data').value.trim();

                // 3. ë‘˜ ë‹¤ ë¹„ì–´ìˆìœ¼ë©´ displayError í˜¸ì¶œ
                if (structDefInput === '' || dataInput === '') {
                    displayError('ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”', 'struct-result-container');
                    return;
                }

                // 4. parseStructDefinitions í˜¸ì¶œ, nullì´ë©´ displayError
                const structDefs = parseStructDefinitions(structDefInput);
                if (structDefs === null) {
                    displayError('êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨', 'struct-result-container');
                    return;
                }

                // 5. íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì½˜ì†” ì¶œë ¥
                console.log('íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜: ' + structDefs.length);

                // 6. parseStructData í˜¸ì¶œ
                const parsedData = parseStructData(dataInput, structDefs);

                // 7. displayStructResults í˜¸ì¶œ (structDefs ì „ë‹¬)
                displayStructResults(parsedData, structDefs);
            });

            // êµ¬ì¡°ì²´ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                document.getElementById('struct-definitions').value = '';
                document.getElementById('struct-data').value = '';
                document.getElementById('struct-result-container').innerHTML = '';
            });
        });
    </script>
</body>
</html>
