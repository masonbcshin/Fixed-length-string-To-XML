<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>í†µì „ë¬¸ íŒŒì„œ</title>
    <style>
        /* ì „ì²´ ë ˆì´ì•„ì›ƒ */
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        /* ì…ë ¥ ì˜ì—­ */
        textarea {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            box-sizing: border-box;
        }

        label {
            display: block;
            font-weight: bold;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        /* ê²°ê³¼ ì˜ì—­ */
        #result-container, #struct-result-container {
            margin-top: 30px;
        }

        /* í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        #result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #result-table th, #result-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        #result-table th {
            background: #f0f0f0;
            font-weight: bold;
        }

        #result-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #result-table tr:hover {
            background: #f0f8ff;
        }

        #result-table td:nth-child(7) {
            font-family: 'Courier New', monospace;
            background: #fafafa;
        }

        .empty-value {
            background: #ffe6e6;
        }

        /* ë°˜ì‘í˜• í…Œì´ë¸” ë˜í¼ */
        .table-wrapper {
            overflow-x: auto;
        }

        /* ë²„íŠ¼ ê·¸ë£¹ */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #sample-btn, #struct-sample-btn {
            background: #28a745;
            margin-right: 10px;
        }

        #sample-btn:hover, #struct-sample-btn:hover {
            background: #1e7e34;
        }

        #clear-btn, #struct-clear-btn {
            background: #6c757d;
        }

        #clear-btn:hover, #struct-clear-btn:hover {
            background: #5a6268;
        }

        /* ì—ëŸ¬ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
        .error-message {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 5px;
            color: #c62828;
            margin-top: 20px;
        }

        /* íŒŒì‹± ì—ëŸ¬ ìŠ¤íƒ€ì¼ */
        .parse-error {
            background: #ffebee;
            padding: 10px;
            border: 1px solid #ef5350;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* íƒ­ ìŠ¤íƒ€ì¼ */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }

        .tab-btn.active {
            background: white;
            border-bottom: 2px solid white;
            font-weight: bold;
            color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* êµ¬ì¡°ì²´ ê²°ê³¼ ê·¸ë£¹ ìŠ¤íƒ€ì¼ */
        .struct-result-group {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            border-radius: 8px;
        }

        .struct-result-group h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .struct-result-group + .struct-result-group {
            margin-top: 20px;
        }

        /* êµ¬ì¡°ì²´ ìš”ì•½ ì •ë³´ ìŠ¤íƒ€ì¼ */
        .struct-summary {
            background: #f0f8ff;
            padding: 15px;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .struct-summary h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .struct-summary p {
            margin: 5px 0;
        }

        .struct-summary ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .struct-summary li {
            margin: 3px 0;
        }

        /* ë³µì‚¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .copy-result-btn {
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .copy-result-btn:hover {
            background: #1e7e34;
        }

        /* ë„ì›€ë§ ì„¹ì…˜ ìŠ¤íƒ€ì¼ */
        .help-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .help-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-toggle:hover {
            background: #dee2e6;
        }

        .help-toggle-icon {
            transition: transform 0.3s ease;
        }

        .help-toggle.expanded .help-toggle-icon {
            transform: rotate(180deg);
        }

        .help-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .help-content.expanded {
            padding: 16px;
            max-height: 500px;
        }

        .help-content h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .help-content p {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        .help-content ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }

        .help-content li {
            margin: 5px 0;
            color: #666;
            font-size: 13px;
        }

        .help-content code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .help-content pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 12px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin: 10px 0;
        }

        /* í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #run-tests-btn {
            background: #6f42c1;
            margin-left: auto;
        }

        #run-tests-btn:hover {
            background: #5a32a3;
        }

        /* í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìŠ¤íƒ€ì¼ */
        .test-results {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }

        .test-results.success {
            background: #d4edda;
            border: 1px solid #28a745;
        }

        .test-results.failure {
            background: #f8d7da;
            border: 1px solid #dc3545;
        }

        .test-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-pass {
            color: #28a745;
        }

        .test-fail {
            color: #dc3545;
        }

        /* ì„¹ì…˜ í—¤ë” ìŠ¤íƒ€ì¼ */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header h3 {
            margin: 0;
        }

        /* êµ¬ì¡°ì²´ ì¶”ê°€ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #add-struct-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #add-struct-btn:hover {
            background: #138496;
        }

        /* êµ¬ì¡°ì²´ ì •ì˜ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #struct-definitions-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* ëª¨ë°”ì¼ ëŒ€ì‘ */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>í†µì „ë¬¸ íŒŒì„œ</h1>
    
    <div class="tab-container">
        <button class="tab-btn active" data-tab="xml">XML íŒŒì‹±</button>
        <button class="tab-btn" data-tab="struct">C êµ¬ì¡°ì²´ íŒŒì‹±</button>
    </div>

    <div id="xml-tab" class="tab-content active">
        <div id="input-section">
            <label for="xml-input">XML ê·œê²©</label>
            <textarea id="xml-input" rows="10" placeholder="XML ê·œê²© ì…ë ¥"></textarea>
            
            <label for="telegram-input">í†µì „ë¬¸</label>
            <textarea id="telegram-input" rows="5" placeholder="í†µì „ë¬¸ ì…ë ¥"></textarea>
        </div>
        
        <div class="button-group">
            <button id="sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
            <button id="parse-btn">íŒŒì‹± ì‹¤í–‰</button>
            <button id="clear-btn">ì´ˆê¸°í™”</button>
        </div>
        
        <div id="result-container"></div>
    </div>

    <div id="struct-tab" class="tab-content" style="display:none;">
        <!-- ë„ì›€ë§ ì„¹ì…˜ -->
        <div class="help-section">
            <button class="help-toggle" type="button">
                <span>ğŸ“– ì‚¬ìš© ë°©ë²• ì•ˆë‚´</span>
                <span class="help-toggle-icon">â–¼</span>
            </button>
            <div class="help-content">
                <h4>C êµ¬ì¡°ì²´ íŒŒì‹± ì‚¬ìš©ë²•</h4>
                <p>ê³ ì • ê¸¸ì´ ë°ì´í„°ë¥¼ C êµ¬ì¡°ì²´ ì •ì˜ì— ë”°ë¼ íŒŒì‹±í•©ë‹ˆë‹¤.</p>
                
                <h4>1. êµ¬ì¡°ì²´ ì •ì˜ í˜•ì‹</h4>
                <p><code>typedef struct { ... } êµ¬ì¡°ì²´ëª…;</code> í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•©ë‹ˆë‹¤.</p>
                <pre>typedef struct {
    char record_kubun[1];  // ë ˆì½”ë“œ êµ¬ë¶„
    char bank_cd[2];       // ì€í–‰ ì½”ë“œ
    char cust_id[7];       // ê³ ê° ID
} DHF_H;</pre>
                
                <h4>2. ë°ì´í„° ì…ë ¥ ê·œì¹™</h4>
                <ul>
                    <li>ê° ì¤„ì´ í•˜ë‚˜ì˜ ë°ì´í„° ë ˆì½”ë“œì…ë‹ˆë‹¤</li>
                    <li>ì—¬ëŸ¬ êµ¬ì¡°ì²´ê°€ ìˆì„ ê²½ìš°, ì²« ê¸€ìë¡œ êµ¬ì¡°ì²´ë¥¼ ìë™ ë§¤ì¹­í•©ë‹ˆë‹¤</li>
                    <li>ì˜ˆ: <code>H</code>ë¡œ ì‹œì‘ â†’ <code>DHF_H</code> (Hë¡œ ëë‚˜ëŠ” êµ¬ì¡°ì²´)</li>
                    <li>ì˜ˆ: <code>D</code>ë¡œ ì‹œì‘ â†’ <code>DHF_D</code> (Dë¡œ ëë‚˜ëŠ” êµ¬ì¡°ì²´)</li>
                </ul>
                
                <h4>3. ì§€ì› ê¸°ëŠ¥</h4>
                <ul>
                    <li>ì—¬ëŸ¬ êµ¬ì¡°ì²´ ë™ì‹œ ì •ì˜ ê°€ëŠ¥</li>
                    <li>ì£¼ì„ ì§€ì›: <code>//</code> í•œì¤„ ì£¼ì„, <code>/* */</code> ë¸”ë¡ ì£¼ì„</li>
                    <li>íŒŒì‹± ê²°ê³¼ë¥¼ TSV í˜•ì‹ìœ¼ë¡œ í´ë¦½ë³´ë“œì— ë³µì‚¬ ê°€ëŠ¥</li>
                </ul>
                
                <h4>4. ì£¼ì˜ì‚¬í•­</h4>
                <ul>
                    <li>ë°ì´í„° ê¸¸ì´ê°€ êµ¬ì¡°ì²´ ì´ í¬ê¸°ì™€ ë‹¤ë¥´ë©´ ê²½ê³ ê°€ í‘œì‹œë©ë‹ˆë‹¤</li>
                    <li>char ë°°ì—´ë§Œ ì •í™•íˆ ì§€ì›ë©ë‹ˆë‹¤ (int, short ë“±ì€ charë¡œ ì²˜ë¦¬)</li>
                </ul>
            </div>
        </div>

        <div id="struct-input-section">
            <div class="section-header">
                <h3>C êµ¬ì¡°ì²´ ì •ì˜</h3>
                <button id="add-struct-btn">+ êµ¬ì¡°ì²´ ì¶”ê°€</button>
            </div>
            
            <div id="struct-definitions-container">
                <!-- êµ¬ì¡°ì²´ ì…ë ¥ ì¹´ë“œë“¤ì´ ì—¬ê¸° ë™ì  ì¶”ê°€ë¨ -->
            </div>
            
            <label for="struct-data" style="margin-top: 20px;">í†µ ë°ì´í„°</label>
            <textarea id="struct-data" rows="10" placeholder="íŒŒì‹±í•  ë°ì´í„° ì…ë ¥ (ì¤„ë°”ê¿ˆ ìœ ë¬´ ë¬´ê´€)"></textarea>
            
            <div class="button-group">
                <button id="struct-sample-btn">ìƒ˜í”Œ ë¡œë“œ</button>
                <button id="struct-parse-btn">íŒŒì‹± ì‹¤í–‰</button>
                <button id="struct-clear-btn">ì „ì²´ ì´ˆê¸°í™”</button>
            </div>
        </div>

        <div id="struct-result-container"></div>
    </div>

    <script>
        /**
         * =====================================================
         * ì •ê·œì‹ ìºì‹± - ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ì •ê·œì‹ì„ ë¯¸ë¦¬ ì»´íŒŒì¼
         * =====================================================
         */
        const REGEX_CACHE = {
            // í•œì¤„ ì£¼ì„ ì œê±°: // ë¶€í„° ì¤„ ëê¹Œì§€ ë§¤ì¹­
            singleLineComment: /\/\/.*$/gm,
            
            // ë¸”ë¡ ì£¼ì„ ì œê±°: /* ë¶€í„° */ ê¹Œì§€ (ë¹„íƒìš•ì  ë§¤ì¹­)
            blockComment: /\/\*[\s\S]*?\*\//g,
            
            // typedef struct ë¸”ë¡ ì¶”ì¶œ:
            // - typedef\s+struct: "typedef struct" í‚¤ì›Œë“œ
            // - (\w+)?: ì„ íƒì  êµ¬ì¡°ì²´ ì´ë¦„ (ìº¡ì²˜ ê·¸ë£¹ 1)
            // - \s*\{([^}]+)\}: ì¤‘ê´„í˜¸ì™€ ë‚´ìš© (ìº¡ì²˜ ê·¸ë£¹ 2)
            // - \s*(\w+)\s*;: typedef ë³„ì¹­ ì´ë¦„ (ìº¡ì²˜ ê·¸ë£¹ 3)
            structPattern: /typedef\s+struct\s+(\w+)?\s*\{([^}]+)\}\s*(\w+)\s*;/g,
            
            // í•„ë“œ ì¶”ì¶œ:
            // - (unsigned\s+)?: ì„ íƒì  unsigned í‚¤ì›Œë“œ (ìº¡ì²˜ ê·¸ë£¹ 1)
            // - (\w+): ê¸°ë³¸ íƒ€ì… (char, int ë“±) (ìº¡ì²˜ ê·¸ë£¹ 2)
            // - \s+(\w+): í•„ë“œëª… (ìº¡ì²˜ ê·¸ë£¹ 3)
            // - \s*\[\s*(\d+)\s*\]: ë°°ì—´ í¬ê¸° (ìº¡ì²˜ ê·¸ë£¹ 4)
            fieldPattern: /(unsigned\s+)?(\w+)\s+(\w+)\s*\[\s*(\d+)\s*\]/g,
            
            // êµ¬ì¡°ì²´ëª…ì—ì„œ ìˆ«ì ì¶”ì¶œ: ë¬¸ìì—´ ëì˜ ì—°ì†ëœ ìˆ«ì
            trailingNumber: /(\d+)$/
        };

        /**
         * ì •ê·œì‹ íŒ¨í„´ì„ ë³µì œí•˜ì—¬ ë°˜í™˜
         * ì •ê·œì‹ì€ ìƒíƒœë¥¼ ê°€ì§€ë¯€ë¡œ(lastIndex), ì‚¬ìš© ì „ ë³µì œ í•„ìš”
         * @param {string} name - REGEX_CACHEì˜ í‚¤ ì´ë¦„
         * @returns {RegExp} ë³µì œëœ ì •ê·œì‹ ê°ì²´
         */
        function getRegex(name) {
            const original = REGEX_CACHE[name];
            return new RegExp(original.source, original.flags);
        }

        /**
         * =====================================================
         * XML ê·œê²© íŒŒì‹± í•¨ìˆ˜
         * XML ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ col ìš”ì†Œ ë°°ì—´ë¡œ ë³€í™˜
         * =====================================================
         * @param {string} xmlString - XML ê·œê²© ë¬¸ìì—´
         * @returns {Array|null} col ìš”ì†Œ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseXMLSpec(xmlString) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof xmlString !== 'string') {
                console.error('parseXMLSpec: ì…ë ¥ê°’ì´ ë¬¸ìì—´ì´ ì•„ë‹™ë‹ˆë‹¤.');
                return null;
            }

            if (xmlString.trim() === '') {
                console.error('parseXMLSpec: ë¹ˆ ë¬¸ìì—´ì´ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                return null;
            }

            // DOMParserë¥¼ ì‚¬ìš©í•´ XML ë¬¸ì„œë¡œ ë³€í™˜
            const parser = new DOMParser();
            let xmlDoc;

            try {
                xmlDoc = parser.parseFromString(xmlString, 'application/xml');
            } catch (e) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', e.message);
                return null;
            }

            // parsererror ì²´í¬
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                console.error('XML íŒŒì‹± ì˜¤ë¥˜:', parseError.textContent);
                return null;
            }

            // ëª¨ë“  col ìš”ì†Œ ì„ íƒ
            const colElements = xmlDoc.querySelectorAll('col');

            if (colElements.length === 0) {
                console.warn('parseXMLSpec: col ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return [];
            }

            // ìœ íš¨í•œ col ìš”ì†Œë“¤ì„ ë‹´ì„ ë°°ì—´
            const result = [];

            // ê° col ìš”ì†Œ ì²˜ë¦¬
            colElements.forEach((col, index) => {
                // ì†ì„± ì¶”ì¶œ
                const id = col.getAttribute('id');
                const type = col.getAttribute('type');
                const sizeAttr = col.getAttribute('size');

                // í•„ìˆ˜ ì†ì„± ê²€ì¦
                const missingAttrs = [];
                if (!id) missingAttrs.push('id');
                if (!type) missingAttrs.push('type');
                if (!sizeAttr) missingAttrs.push('size');

                if (missingAttrs.length > 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì— í•„ìˆ˜ ì†ì„±ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: ${missingAttrs.join(', ')}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // sizeë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜
                const size = parseInt(sizeAttr, 10);

                // sizeê°€ ìœ íš¨í•œ ì •ìˆ˜ì¸ì§€ ê²€ì¦
                if (isNaN(size)) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤: "${sizeAttr}"`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                if (size < 0) {
                    console.warn(
                        `parseXMLSpec: ${index + 1}ë²ˆì§¸ col ìš”ì†Œì˜ size ì†ì„±ì´ ìŒìˆ˜ì…ë‹ˆë‹¤: ${size}`
                    );
                    return; // í•´ë‹¹ ìš”ì†Œ ê±´ë„ˆë›°ê¸°
                }

                // ìœ íš¨í•œ col ì •ë³´ë¥¼ ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: id,
                    type: type,
                    size: size
                });
            });

            return result;
        }

        /**
         * =====================================================
         * í†µì „ë¬¸ íŒŒì‹± í•¨ìˆ˜
         * í†µì „ë¬¸ ë¬¸ìì—´ì„ XML ê·œê²©ì— ë§ê²Œ ë¶„ë¦¬
         * =====================================================
         * @param {string} telegramString - í†µì „ë¬¸ ë¬¸ìì—´
         * @param {Array} xmlSpec - parseXMLSpecì˜ ê²°ê³¼ ë°°ì—´
         * @returns {Array} íŒŒì‹±ëœ ê²°ê³¼ ë°°ì—´
         */
        function parseTelegram(telegramString, xmlSpec) {
            // í˜„ì¬ ìœ„ì¹˜ ì´ˆê¸°í™”
            let currentPos = 0;

            // ë¹ˆ ê²°ê³¼ ë°°ì—´ ìƒì„±
            const result = [];

            // xmlSpec ë°°ì—´ ìˆœíšŒ
            for (let i = 0; i < xmlSpec.length; i++) {
                const spec = xmlSpec[i];

                // ì‹œì‘/ì¢…ë£Œ ìœ„ì¹˜ ê³„ì‚°
                const startPos = currentPos;
                const endPos = currentPos + spec.size;

                // substringìœ¼ë¡œ ê°’ ì¶”ì¶œ (ì¸ë±ìŠ¤ ë²”ìœ„ ì´ˆê³¼í•´ë„ ì˜¤ë¥˜ ì—†ì´ ì²˜ë¦¬ë¨)
                const value = telegramString.substring(startPos, endPos);

                // ê²°ê³¼ ë°°ì—´ì— ì¶”ê°€
                result.push({
                    id: spec.id,
                    type: spec.type,
                    size: spec.size,
                    value: value,
                    startPos: startPos,
                    endPos: endPos
                });

                // í˜„ì¬ ìœ„ì¹˜ ì´ë™
                currentPos += spec.size;
            }

            // í†µì „ë¬¸ ì „ì²´ ê¸¸ì´ì™€ ì˜ˆìƒ ê¸¸ì´ ë¹„êµ
            if (telegramString.length !== currentPos) {
                console.warn(
                    `parseTelegram: í†µì „ë¬¸ ê¸¸ì´(${telegramString.length})ì™€ ì˜ˆìƒ ê¸¸ì´(${currentPos})ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`
                );
            }

            return result;
        }

        /**
         * =====================================================
         * C êµ¬ì¡°ì²´ ì •ì˜ íŒŒì‹± í•¨ìˆ˜
         * êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ êµ¬ì¡°ì²´ ë°°ì—´ë¡œ ë³€í™˜
         * =====================================================
         * @param {string} structText - C êµ¬ì¡°ì²´ ì •ì˜ ë¬¸ìì—´
         * @returns {Array|null} êµ¬ì¡°ì²´ ë°°ì—´ ë˜ëŠ” null (ì—ëŸ¬ ì‹œ)
         */
        function parseStructDefinitions(structText) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof structText !== 'string' || structText.trim() === '') {
                console.error('parseStructDefinitions: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. ì£¼ì„ ì œê±° ì²˜ë¦¬ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
            let cleanedText = structText.replace(getRegex('singleLineComment'), '');
            cleanedText = cleanedText.replace(getRegex('blockComment'), '');

            // 2. typedef struct ë¸”ë¡ ì¶”ì¶œ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
            const structPattern = getRegex('structPattern');
            
            // íƒ€ì…ë³„ í¬ê¸° ì •ì˜ (ë°”ì´íŠ¸)
            const typeSizes = {
                'char': 1,
                'unsigned char': 1,
                'short': 2,
                'unsigned short': 2,
                'int': 4,
                'unsigned int': 4,
                'long': 4,
                'unsigned long': 4
            };
            
            // ê²°ê³¼ ë°°ì—´
            const result = [];
            
            // typedef struct ë¸”ë¡ë“¤ ì¶”ì¶œ
            let structMatch;
            while ((structMatch = structPattern.exec(cleanedText)) !== null) {
                const fieldsContent = structMatch[2]; // ì¤‘ê´„í˜¸ ì•ˆì˜ ë‚´ìš©
                const structName = structMatch[3];    // typedef êµ¬ì¡°ì²´ëª… (ë§ˆì§€ë§‰ ì´ë¦„)
                
                // í•„ë“œ ë°°ì—´
                const fields = [];
                
                // í•„ë“œë“¤ ì¶”ì¶œ - ìƒˆë¡œìš´ ì •ê·œì‹ ì¸ìŠ¤í„´ìŠ¤ ì‚¬ìš©
                const fieldPattern = getRegex('fieldPattern');
                let fieldMatch;
                while ((fieldMatch = fieldPattern.exec(fieldsContent)) !== null) {
                    const unsignedPrefix = fieldMatch[1] ? fieldMatch[1].trim() : '';
                    const baseType = fieldMatch[2];
                    const fieldName = fieldMatch[3];
                    const arraySize = parseInt(fieldMatch[4], 10);
                    
                    // ì „ì²´ íƒ€ì…ëª… êµ¬ì„±
                    const fullType = unsignedPrefix ? unsignedPrefix + ' ' + baseType : baseType;
                    
                    // íƒ€ì…ë³„ í¬ê¸° ê³„ì‚°
                    let typeSize = typeSizes[fullType] || typeSizes[baseType] || 1;
                    
                    // char ì™¸ì˜ íƒ€ì…ì€ ê²½ê³  ì¶œë ¥ (í•˜ì§€ë§Œ char ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬)
                    if (baseType !== 'char') {
                        console.warn('parseStructDefinitions: "' + structName + '"ì˜ í•„ë“œ "' + fieldName + '"ì˜ íƒ€ì… "' + fullType + '"ì€ charë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤. í¬ê¸° ê³„ì‚°ì´ ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                        // char ê¸°ì¤€ìœ¼ë¡œ ì²˜ë¦¬ (ë°°ì—´ í¬ê¸°ë§Œ ì‚¬ìš©)
                        typeSize = 1;
                    }
                    
                    fields.push({
                        name: fieldName,
                        type: fullType,
                        size: arraySize * typeSize
                    });
                }
                
                // ë¹ˆ êµ¬ì¡°ì²´ ê²€ì¦ - fieldsê°€ 0ê°œì¸ êµ¬ì¡°ì²´ëŠ” ì œì™¸
                if (fields.length === 0) {
                    console.warn('parseStructDefinitions: êµ¬ì¡°ì²´ "' + structName + '"ì— ìœ íš¨í•œ í•„ë“œê°€ ì—†ì–´ ì œì™¸ë©ë‹ˆë‹¤.');
                    continue;
                }
                
                // êµ¬ì¡°ì²´ ê°ì²´ ì¶”ê°€
                result.push({
                    name: structName,
                    fields: fields
                });
            }
            
            // êµ¬ì¡°ì²´ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ë°˜í™˜
            if (result.length === 0) {
                console.error('parseStructDefinitions: íŒŒì‹±ëœ êµ¬ì¡°ì²´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return null;
            }
            
            // íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì¶œë ¥
            console.log('parseStructDefinitions: ' + result.length + 'ê°œì˜ êµ¬ì¡°ì²´ê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            return result;
        }

        /**
         * =====================================================
         * ë§¤ì¹­ êµ¬ì¡°ì²´ ì°¾ê¸° í•¨ìˆ˜
         * ë°ì´í„° ë¼ì¸ì˜ ì²« ê¸€ìë¡œ ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ íƒìƒ‰
         * =====================================================
         * @param {string} line - ë°ì´í„° ë¼ì¸
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Object|null} ë§¤ì¹­ëœ êµ¬ì¡°ì²´ ë˜ëŠ” null
         */
        function findMatchingStruct(line, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (!line || !Array.isArray(structDefs) || structDefs.length === 0) {
                console.warn('findMatchingStruct: ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤.');
                return null;
            }

            // 1. êµ¬ì¡°ì²´ê°€ 1ê°œë§Œ ìˆìœ¼ë©´ ê·¸ê²ƒ ë°˜í™˜
            if (structDefs.length === 1) {
                return structDefs[0];
            }

            // 2. ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ë§¤ì¹­ ë¡œì§
            const lineFirstChar = line.charAt(0);

            for (let i = 0; i < structDefs.length; i++) {
                const structDef = structDefs[i];

                // í•„ë“œê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if (!structDef.fields || structDef.fields.length === 0) {
                    continue;
                }

                // ì²« ë²ˆì§¸ í•„ë“œì˜ sizeë§Œí¼ lineì—ì„œ ì¶”ì¶œ
                const firstField = structDef.fields[0];
                const extractedValue = line.substring(0, firstField.size).trim();

                // êµ¬ì¡°ì²´ëª…ì—ì„œ êµ¬ë¶„ íŒ¨í„´ ì¶”ì¶œ
                // ì˜ˆ: DHF_H â†’ 'H', DHF_D â†’ 'D', ST_HEADER_1 â†’ '1'
                const structName = structDef.name;
                
                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ (ì–¸ë”ìŠ¤ì½”ì–´ ë’¤ ë˜ëŠ” ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ì)
                let structIdentifier = '';
                
                // ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ë§ˆì§€ë§‰ ë¶€ë¶„ ì¶”ì¶œ
                const parts = structName.split('_');
                const lastPart = parts[parts.length - 1];
                
                // ë§ˆì§€ë§‰ ë¶€ë¶„ì´ ë‹¨ì¼ ë¬¸ì ë˜ëŠ” ìˆ«ìì¸ ê²½ìš°
                if (lastPart.length === 1) {
                    structIdentifier = lastPart;
                } else {
                    // ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ìˆ«ì ì¶”ì¶œ ì‹œë„ - ìºì‹œëœ ì •ê·œì‹ ì‚¬ìš©
                    const numMatch = lastPart.match(getRegex('trailingNumber'));
                    if (numMatch) {
                        structIdentifier = numMatch[1];
                    } else {
                        // ë§ˆì§€ë§‰ ë¬¸ì ì‚¬ìš©
                        structIdentifier = lastPart.charAt(lastPart.length - 1);
                    }
                }

                // êµ¬ì¡°ì²´ëª… ë§ˆì§€ë§‰ ë¬¸ì/ìˆ«ìì™€ line ì²« ë¬¸ì ë¹„êµ
                if (lineFirstChar === structIdentifier) {
                    return structDef;
                }

                // ì²« í•„ë“œ ê°’ê³¼ êµ¬ì¡°ì²´ ì‹ë³„ì ë¹„êµ
                if (extractedValue === structIdentifier) {
                    return structDef;
                }
            }

            // 3. ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜, ì½˜ì†”ì— ê²½ê³ 
            console.warn('findMatchingStruct: ë¼ì¸ "' + line.substring(0, 20) + '..."ì— ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return null;
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ ë°ì´í„° íŒŒì‹± í•¨ìˆ˜
         * í†µ ë°ì´í„°ë¥¼ êµ¬ì¡°ì²´ ì •ì˜ì— ë§ê²Œ íŒŒì‹±
         * =====================================================
         * @param {string} dataText - ë°ì´í„° í…ìŠ¤íŠ¸ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„)
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         * @returns {Array} íŒŒì‹± ê²°ê³¼ ë°°ì—´
         */
        function parseStructData(dataText, structDefs) {
            // ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬
            if (typeof dataText !== 'string' || dataText.trim() === '') {
                console.error('parseStructData: ë°ì´í„° í…ìŠ¤íŠ¸ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return [];
            }

            if (!Array.isArray(structDefs) || structDefs.length === 0) {
                console.error('parseStructData: êµ¬ì¡°ì²´ ì •ì˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return [];
            }

            // 1. dataTextë¥¼ ì¤„ë°”ê¿ˆìœ¼ë¡œ split, ë¹ˆ ì¤„ ì œê±°
            const lines = dataText.split('\n').filter(function(line) {
                return line.trim() !== '';
            });

            // 2. ê²°ê³¼ ë°°ì—´ ì´ˆê¸°í™”
            const result = [];

            // 3. ê° ë¼ì¸ë§ˆë‹¤ ì²˜ë¦¬
            lines.forEach(function(line, lineIndex) {
                const lineNumber = lineIndex + 1;

                // findMatchingStruct í—¬í¼ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì°¾ê¸°
                const matchedStruct = findMatchingStruct(line, structDefs);

                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ê°ì²´ ì¶”ê°€
                if (!matchedStruct) {
                    result.push({
                        error: true,
                        lineNumber: lineNumber,
                        line: line,
                        message: 'ë§¤ì¹­ë˜ëŠ” êµ¬ì¡°ì²´ ì—†ìŒ'
                    });
                    return; // ë‹¤ìŒ ë¼ì¸ìœ¼ë¡œ continue
                }

                // d. ë§¤ì¹­ëœ êµ¬ì¡°ì²´ fieldsë¥¼ ìˆœíšŒí•˜ë©° íŒŒì‹±
                let currentPos = 0;
                matchedStruct.fields.forEach(function(field) {
                    const startPos = currentPos;
                    const endPos = currentPos + field.size;
                    const value = line.substring(startPos, endPos);

                    result.push({
                        structName: matchedStruct.name,
                        fieldName: field.name,
                        fieldSize: field.size,
                        value: value,
                        lineNumber: lineNumber,
                        startPos: startPos,
                        endPos: endPos
                    });

                    currentPos += field.size;
                });

                // ë¼ì¸ ê¸¸ì´ ê²€ì¦ ê²½ê³ 
                const expectedLength = matchedStruct.fields.reduce(function(sum, f) {
                    return sum + f.size;
                }, 0);
                
                if (line.length !== expectedLength) {
                    console.warn('ë¼ì¸ ' + lineNumber + ': ì˜ˆìƒ ê¸¸ì´ ' + expectedLength + ', ì‹¤ì œ ê¸¸ì´ ' + line.length);
                }
            });

            // 4. ê²°ê³¼ ë°°ì—´ ë°˜í™˜
            console.log('parseStructData: ' + result.length + 'ê°œì˜ í•„ë“œê°€ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            return result;
        }

        /**
         * =====================================================
         * ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
         * ì§€ì •ëœ ì»¨í…Œì´ë„ˆì— ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
         * =====================================================
         * @param {string} message - ì—ëŸ¬ ë©”ì‹œì§€
         * @param {string} targetContainer - íƒ€ê²Ÿ ì»¨í…Œì´ë„ˆ ID (ê¸°ë³¸: result-container)
         */
        function displayError(message, targetContainer) {
            // 1. targetContainer ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’: result-container)
            const containerId = targetContainer || 'result-container';
            const container = document.getElementById(containerId);

            // 2. innerHTMLì„ ì—ëŸ¬ ë©”ì‹œì§€ë¡œ ì„¤ì •
            container.innerHTML = `<div class="error-message">âš ï¸ ${message}</div>`;
        }

        /**
         * =====================================================
         * XML íŒŒì‹± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì í™”
         * =====================================================
         * @param {Array} parsedData - parseTelegramì˜ ê²°ê³¼ ë°°ì—´
         */
        function displayResults(parsedData) {
            // 1. result-container ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
            const container = document.getElementById('result-container');

            // 2. innerHTML ì´ˆê¸°í™”
            container.innerHTML = '';

            // DocumentFragment ìƒì„± - DOM ì¡°ì‘ ìµœì í™”
            const fragment = document.createDocumentFragment();

            // 3. table ìš”ì†Œ ìƒì„±
            const table = document.createElement('table');
            table.id = 'result-table';

            // 4. thead ìƒì„± í›„ tr ì¶”ê°€, th 7ê°œ
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = ['ìˆœë²ˆ', 'í•„ë“œëª…', 'íƒ€ì…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

            headers.forEach(function(headerText) {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);

            // 5. tbody ìƒì„±
            const tbody = document.createElement('tbody');

            // 6. parsedData ë°°ì—´ ìˆœíšŒ
            parsedData.forEach(function(item, index) {
                // tr ìƒì„±
                const tr = document.createElement('tr');

                // td 7ê°œ ìƒì„±
                const values = [
                    index + 1,
                    item.id,
                    item.type,
                    item.size,
                    item.startPos,
                    item.endPos,
                    item.value
                ];

                values.forEach(function(value, tdIndex) {
                    const td = document.createElement('td');
                    td.textContent = value;

                    // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ td, ì¦‰ value ì»¬ëŸ¼)
                    if (tdIndex === 6 && typeof value === 'string' && value.trim() === '') {
                        td.classList.add('empty-value');
                    }

                    tr.appendChild(td);
                });

                // tbodyì— tr ì¶”ê°€
                tbody.appendChild(tr);
            });

            // 7. tableì— thead, tbody ì¶”ê°€
            table.appendChild(thead);
            table.appendChild(tbody);

            // 8. ë°˜ì‘í˜•ì„ ìœ„í•œ wrapper div ìƒì„±
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.appendChild(table);

            // 9. fragmentì— ì¶”ê°€ í›„ í•œ ë²ˆì— DOM ì—…ë°ì´íŠ¸
            fragment.appendChild(wrapper);
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * êµ¬ì¡°ì²´ íŒŒì‹± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ DOM ì¡°ì‘ ìµœì í™”
         * =====================================================
         * @param {Array} parsedData - parseStructDataì˜ ê²°ê³¼ ë°°ì—´
         * @param {Array} structDefs - êµ¬ì¡°ì²´ ì •ì˜ ë°°ì—´
         */
        function displayStructResults(parsedData, structDefs) {
            // 1. struct-result-container ì´ˆê¸°í™”
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            // DocumentFragment ìƒì„± - DOM ì¡°ì‘ ìµœì í™”
            const fragment = document.createDocumentFragment();

            // ì—ëŸ¬ê°€ ìˆëŠ”ì§€ í™•ì¸
            const errors = parsedData.filter(function(item) {
                return item.error === true;
            });

            // ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ - ê° ì—ëŸ¬ë¥¼ ê°œë³„ parse-error ë°•ìŠ¤ë¡œ í‘œì‹œ
            errors.forEach(function(e) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'parse-error';
                errorDiv.textContent = 'ë¼ì¸ ' + e.lineNumber + ' íŒŒì‹± ì‹¤íŒ¨: ' + e.line;
                fragment.appendChild(errorDiv);
            });

            // ì •ìƒ íŒŒì‹± ê²°ê³¼ë§Œ í•„í„°ë§
            const validData = parsedData.filter(function(item) {
                return item.error !== true;
            });

            if (validData.length === 0) {
                if (errors.length === 0) {
                    container.innerHTML = '<div class="error-message">âš ï¸ íŒŒì‹± ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                } else {
                    container.appendChild(fragment);
                }
                return;
            }

            // êµ¬ì¡°ì²´ ìš”ì•½ ì •ë³´ í‘œì‹œ
            if (structDefs && structDefs.length > 0) {
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'struct-summary';

                // ì œëª©
                const title = document.createElement('h3');
                title.textContent = 'ğŸ“‹ íŒŒì‹± ì •ë³´';
                summaryDiv.appendChild(title);

                // êµ¬ì¡°ì²´ ìˆ˜
                const structCountP = document.createElement('p');
                structCountP.textContent = 'êµ¬ì¡°ì²´ ìˆ˜: ' + structDefs.length + 'ê°œ';
                summaryDiv.appendChild(structCountP);

                // ê° êµ¬ì¡°ì²´ëª…ê³¼ ì´ í¬ê¸° ëª©ë¡
                const structList = document.createElement('ul');
                structDefs.forEach(function(structDef) {
                    const li = document.createElement('li');
                    // êµ¬ì¡°ì²´ì˜ ì´ í¬ê¸° ê³„ì‚° (ëª¨ë“  í•„ë“œ size í•©ì‚°)
                    const totalSize = structDef.fields.reduce(function(sum, field) {
                        return sum + field.size;
                    }, 0);
                    li.textContent = structDef.name + ': ' + totalSize + ' bytes';
                    structList.appendChild(li);
                });
                summaryDiv.appendChild(structList);

                // ì²˜ë¦¬ëœ ë°ì´í„° ë¼ì¸ ìˆ˜ ê³„ì‚° (unique lineNumber ê°œìˆ˜)
                const uniqueLines = {};
                validData.forEach(function(item) {
                    uniqueLines[item.lineNumber] = true;
                });
                const lineCount = Object.keys(uniqueLines).length;

                const lineCountP = document.createElement('p');
                lineCountP.textContent = 'ë°ì´í„° ë¼ì¸: ' + lineCount + 'ê°œ';
                summaryDiv.appendChild(lineCountP);

                fragment.appendChild(summaryDiv);
            }

            // 2. ë¼ì¸ë³„ë¡œ ê·¸ë£¹í™”
            const groupedByLine = {};
            validData.forEach(function(item) {
                const lineNum = item.lineNumber;
                if (!groupedByLine[lineNum]) {
                    groupedByLine[lineNum] = {
                        structName: item.structName,
                        fields: []
                    };
                }
                groupedByLine[lineNum].fields.push(item);
            });

            // 3. ê° ë¼ì¸ë§ˆë‹¤ í…Œì´ë¸” ìƒì„±
            const lineNumbers = Object.keys(groupedByLine).sort(function(a, b) {
                return parseInt(a) - parseInt(b);
            });

            lineNumbers.forEach(function(lineNum) {
                const lineData = groupedByLine[lineNum];

                // ê·¸ë£¹ ì»¨í…Œì´ë„ˆ ìƒì„±
                const groupDiv = document.createElement('div');
                groupDiv.className = 'struct-result-group';

                // ë³µì‚¬ ë²„íŠ¼ ì¶”ê°€
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-result-btn';
                copyBtn.setAttribute('data-line', lineNum);
                copyBtn.textContent = 'ğŸ“‹ ë³µì‚¬';
                groupDiv.appendChild(copyBtn);

                // ì œëª©: "ë¼ì¸ N - êµ¬ì¡°ì²´ëª…"
                const title = document.createElement('h3');
                title.textContent = 'ë¼ì¸ ' + lineNum + ' - ' + lineData.structName;
                groupDiv.appendChild(title);

                // í…Œì´ë¸” ìƒì„±
                const table = document.createElement('table');
                table.id = 'result-table';

                // thead ìƒì„±
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['ìˆœë²ˆ', 'í•„ë“œëª…', 'í¬ê¸°', 'ì‹œì‘', 'ì¢…ë£Œ', 'ê°’'];

                headers.forEach(function(headerText) {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);

                // tbody ìƒì„±
                const tbody = document.createElement('tbody');

                // í•´ë‹¹ ë¼ì¸ì˜ ëª¨ë“  í•„ë“œë¥¼ í–‰ìœ¼ë¡œ ì¶”ê°€
                lineData.fields.forEach(function(item, index) {
                    const tr = document.createElement('tr');

                    const values = [
                        index + 1,       // ìˆœë²ˆ
                        item.fieldName,  // í•„ë“œëª…
                        item.fieldSize,  // í¬ê¸°
                        item.startPos,   // ì‹œì‘
                        item.endPos,     // ì¢…ë£Œ
                        item.value       // ê°’
                    ];

                    values.forEach(function(value, tdIndex) {
                        const td = document.createElement('td');
                        td.textContent = value;

                        // valueê°€ ê³µë°±ë§Œ ìˆìœ¼ë©´ class="empty-value" ì¶”ê°€ (ë§ˆì§€ë§‰ ì»¬ëŸ¼)
                        if (tdIndex === 5 && typeof value === 'string' && value.trim() === '') {
                            td.classList.add('empty-value');
                        }

                        tr.appendChild(td);
                    });

                    tbody.appendChild(tr);
                });

                table.appendChild(thead);
                table.appendChild(tbody);

                // ë°˜ì‘í˜• wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                wrapper.appendChild(table);

                groupDiv.appendChild(wrapper);

                // 4. fragmentì— ê·¸ë£¹ ì¶”ê°€
                fragment.appendChild(groupDiv);
            });

            // í•œ ë²ˆì— DOM ì—…ë°ì´íŠ¸
            container.appendChild(fragment);
        }

        /**
         * =====================================================
         * í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜
         * ë‹¤ì–‘í•œ ì…ë ¥ ìƒí™©ì— ëŒ€í•œ ìë™í™”ëœ í…ŒìŠ¤íŠ¸
         * =====================================================
         * @returns {Object} í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê°ì²´ { passed, failed, results }
         */
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            /**
             * ê°œë³„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í—¬í¼
             */
            function test(name, fn) {
                try {
                    const result = fn();
                    if (result === true) {
                        passed++;
                        results.push({ name: name, passed: true });
                    } else {
                        failed++;
                        results.push({ name: name, passed: false, reason: result || 'ì‹¤íŒ¨' });
                    }
                } catch (e) {
                    failed++;
                    results.push({ name: name, passed: false, reason: e.message });
                }
            }

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 1: êµ¬ì¡°ì²´ 1ê°œë§Œ ìˆëŠ” ê²½ìš°
            // =========================================
            test('êµ¬ì¡°ì²´ 1ê°œë§Œ ìˆëŠ” ê²½ìš°', function() {
                const structDef = `typedef struct {
                    char field1[5];
                    char field2[10];
                } SingleStruct;`;
                
                const data = 'HELLO1234567890';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                
                const parsed = parseStructData(data, defs);
                if (parsed.length !== 2) return 'í•„ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (parsed[0].value !== 'HELLO') return 'ì²« ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== '1234567890') return 'ë‘ ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 2: êµ¬ì¡°ì²´ 5ê°œ ì´ìƒì¸ ê²½ìš°
            // =========================================
            test('êµ¬ì¡°ì²´ 5ê°œ ì´ìƒì¸ ê²½ìš°', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Type_A;
                    typedef struct { char type[1]; char data[4]; } Type_B;
                    typedef struct { char type[1]; char data[4]; } Type_C;
                    typedef struct { char type[1]; char data[4]; } Type_D;
                    typedef struct { char type[1]; char data[4]; } Type_E;
                `;
                
                const data = 'AAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE';
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 5) return 'êµ¬ì¡°ì²´ ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + (defs ? defs.length : 0);
                
                const parsed = parseStructData(data, defs);
                // 5ì¤„ Ã— 2í•„ë“œ = 10ê°œ í•„ë“œ
                if (parsed.length !== 10) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + parsed.length;
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 3: ë°ì´í„° ë¼ì¸ 100ê°œ ì´ìƒ
            // =========================================
            test('ë°ì´í„° ë¼ì¸ 100ê°œ ì´ìƒ', function() {
                const structDef = `typedef struct { char id[4]; char val[6]; } DataLine;`;
                
                // 100ê°œ ë¼ì¸ ìƒì„±
                let dataLines = [];
                for (let i = 0; i < 100; i++) {
                    const id = ('0000' + i).slice(-4);
                    dataLines.push(id + 'VALUE1');
                }
                const data = dataLines.join('\n');
                
                const defs = parseStructDefinitions(structDef);
                if (!defs) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                
                const parsed = parseStructData(data, defs);
                // 100ì¤„ Ã— 2í•„ë“œ = 200ê°œ í•„ë“œ
                if (parsed.length !== 200) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + parsed.length;
                
                // ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ ë¼ì¸ ê²€ì¦
                if (parsed[0].value !== '0000') return 'ì²« ë¼ì¸ ì²« í•„ë“œ ë¶ˆì¼ì¹˜';
                if (parsed[198].value !== '0099') return 'ë§ˆì§€ë§‰ ë¼ì¸ ì²« í•„ë“œ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 4: ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„°
            // =========================================
            test('ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„° (ì§§ìŒ)', function() {
                const structDef = `typedef struct { char field1[10]; char field2[10]; } TestStruct;`;
                const data = 'SHORTDATA'; // 9ì (ì˜ˆìƒ: 20ì)
                
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData(data, defs);
                
                // íŒŒì‹±ì€ ì„±ê³µí•´ì•¼ í•¨ (ë¶€ì¡±í•œ ë¶€ë¶„ì€ ë¹ˆ ë¬¸ìì—´)
                if (parsed.length !== 2) return 'í•„ë“œ íŒŒì‹± ì‹¤íŒ¨';
                if (parsed[0].value !== 'SHORTDATA') return 'ì²« ë²ˆì§¸ í•„ë“œ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== '') return 'ë‘ ë²ˆì§¸ í•„ë“œê°€ ë¹ˆ ë¬¸ìì—´ì´ì–´ì•¼ í•¨';
                
                return true;
            });

            test('ê¸¸ì´ê°€ ì•ˆ ë§ëŠ” ë°ì´í„° (ê¹€)', function() {
                const structDef = `typedef struct { char field1[5]; } ShortStruct;`;
                const data = 'EXTRALONG_DATA_HERE'; // ì˜ˆìƒë³´ë‹¤ ê¸´ ë°ì´í„°
                
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData(data, defs);
                
                // ì •ì˜ëœ í•„ë“œê¹Œì§€ë§Œ íŒŒì‹±
                if (parsed.length !== 1) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                if (parsed[0].value !== 'EXTRA') return 'ê°’ ë¶ˆì¼ì¹˜: ' + parsed[0].value;
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 5: ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²•
            // =========================================
            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - typedef ëˆ„ë½', function() {
                const structDef = `struct { char field[5]; } BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // nullì„ ë°˜í™˜í•´ì•¼ í•¨
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - ì¤‘ê´„í˜¸ ëˆ„ë½', function() {
                const structDef = `typedef struct char field[5]; BadStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ì˜ëª»ëœ êµ¬ì¡°ì²´ ë¬¸ë²• - ì„¸ë¯¸ì½œë¡  ëˆ„ë½', function() {
                const structDef = `typedef struct { char field[5]; } BadStruct`;
                const defs = parseStructDefinitions(structDef);
                
                if (defs !== null) return 'ì˜ëª»ëœ ë¬¸ë²•ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            test('ë¹ˆ êµ¬ì¡°ì²´ (í•„ë“œ ì—†ìŒ)', function() {
                const structDef = `typedef struct { } EmptyStruct;`;
                const defs = parseStructDefinitions(structDef);
                
                // ë¹ˆ êµ¬ì¡°ì²´ëŠ” ì œì™¸ë˜ë¯€ë¡œ null ë°˜í™˜
                if (defs !== null) return 'ë¹ˆ êµ¬ì¡°ì²´ì¸ë° íŒŒì‹±ë¨';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 6: ë¹ˆ ì…ë ¥
            // =========================================
            test('ë¹ˆ ì…ë ¥ - êµ¬ì¡°ì²´ ì •ì˜', function() {
                const defs = parseStructDefinitions('');
                if (defs !== null) return 'ë¹ˆ ì…ë ¥ì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            test('ë¹ˆ ì…ë ¥ - ë°ì´í„°', function() {
                const structDef = `typedef struct { char field[5]; } TestStruct;`;
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData('', defs);
                
                if (parsed.length !== 0) return 'ë¹ˆ ë°ì´í„°ì¸ë° ê²°ê³¼ ìˆìŒ';
                return true;
            });

            test('ê³µë°±ë§Œ ìˆëŠ” ì…ë ¥', function() {
                const defs = parseStructDefinitions('   \n\t\n   ');
                if (defs !== null) return 'ê³µë°±ë§Œ ìˆëŠ”ë° íŒŒì‹±ë¨';
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 7: ì£¼ì„ ì²˜ë¦¬
            // =========================================
            test('í•œì¤„ ì£¼ì„ ì²˜ë¦¬', function() {
                const structDef = `typedef struct {
                    // ì´ê²ƒì€ ì£¼ì„ì…ë‹ˆë‹¤
                    char field1[5]; // í•„ë“œ ì„¤ëª…
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                if (defs[0].fields.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            test('ë¸”ë¡ ì£¼ì„ ì²˜ë¦¬', function() {
                const structDef = `typedef struct {
                    /* ë¸”ë¡ ì£¼ì„
                       ì—¬ëŸ¬ ì¤„ */
                    char field1[5];
                    char field2[5];
                } CommentStruct;`;
                
                const defs = parseStructDefinitions(structDef);
                if (!defs || defs.length !== 1) return 'êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨';
                if (defs[0].fields.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 8: êµ¬ì¡°ì²´ ë§¤ì¹­ ë¡œì§
            // =========================================
            test('êµ¬ì¡°ì²´ ë§¤ì¹­ - ì²« ê¸€ì ê¸°ì¤€', function() {
                const structDef = `
                    typedef struct { char type[1]; char data[4]; } Record_H;
                    typedef struct { char type[1]; char data[9]; } Record_D;
                `;
                
                const data = 'H1234\nD123456789';
                
                const defs = parseStructDefinitions(structDef);
                const parsed = parseStructData(data, defs);
                
                // H ë¼ì¸: 2í•„ë“œ, D ë¼ì¸: 2í•„ë“œ = 4ê°œ
                if (parsed.length !== 4) return 'í•„ë“œ íŒŒì‹± ê°œìˆ˜ ë¶ˆì¼ì¹˜: ' + parsed.length;
                
                // ì²« ë¼ì¸ì€ Record_H
                if (parsed[0].structName !== 'Record_H') return 'ì²« ë¼ì¸ êµ¬ì¡°ì²´ ë§¤ì¹­ ì‹¤íŒ¨';
                // ë‘ ë²ˆì§¸ ë¼ì¸ì€ Record_D
                if (parsed[2].structName !== 'Record_D') return 'ë‘ ë²ˆì§¸ ë¼ì¸ êµ¬ì¡°ì²´ ë§¤ì¹­ ì‹¤íŒ¨';
                
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 9: XML íŒŒì‹±
            // =========================================
            test('XML íŒŒì‹± - ì •ìƒ', function() {
                const xml = `<packet>
                    <col id="field1" type="X" size="5" />
                    <col id="field2" type="N" size="10" />
                </packet>`;
                
                const spec = parseXMLSpec(xml);
                if (!spec || spec.length !== 2) return 'XML íŒŒì‹± ì‹¤íŒ¨';
                if (spec[0].id !== 'field1') return 'ì²« ë²ˆì§¸ í•„ë“œ ID ë¶ˆì¼ì¹˜';
                if (spec[1].size !== 10) return 'ë‘ ë²ˆì§¸ í•„ë“œ í¬ê¸° ë¶ˆì¼ì¹˜';
                
                return true;
            });

            test('XML íŒŒì‹± - ë¹ˆ ì…ë ¥', function() {
                const spec = parseXMLSpec('');
                if (spec !== null) return 'ë¹ˆ ì…ë ¥ì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            test('XML íŒŒì‹± - ì˜ëª»ëœ í˜•ì‹', function() {
                const spec = parseXMLSpec('<invalid><unclosed>');
                if (spec !== null) return 'ì˜ëª»ëœ XMLì¸ë° íŒŒì‹±ë¨';
                return true;
            });

            // =========================================
            // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 10: í†µì „ë¬¸ íŒŒì‹±
            // =========================================
            test('í†µì „ë¬¸ íŒŒì‹± - ì •ìƒ', function() {
                const xml = `<packet>
                    <col id="code" type="X" size="3" />
                    <col id="name" type="X" size="5" />
                </packet>`;
                const telegram = 'ABCHELLO';
                
                const spec = parseXMLSpec(xml);
                const parsed = parseTelegram(telegram, spec);
                
                if (parsed.length !== 2) return 'í•„ë“œ ê°œìˆ˜ ë¶ˆì¼ì¹˜';
                if (parsed[0].value !== 'ABC') return 'ì²« ë²ˆì§¸ ê°’ ë¶ˆì¼ì¹˜';
                if (parsed[1].value !== 'HELLO') return 'ë‘ ë²ˆì§¸ ê°’ ë¶ˆì¼ì¹˜';
                
                return true;
            });

            return { passed: passed, failed: failed, results: results };
        }

        /**
         * =====================================================
         * í…ŒìŠ¤íŠ¸ ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
         * í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ UIì— í‘œì‹œ
         * =====================================================
         * @param {Object} testResult - runTests()ì˜ ë°˜í™˜ê°’
         */
        function displayTestResults(testResult) {
            const container = document.getElementById('struct-result-container');
            container.innerHTML = '';

            const div = document.createElement('div');
            div.className = 'test-results ' + (testResult.failed === 0 ? 'success' : 'failure');

            const title = document.createElement('h3');
            title.textContent = 'í…ŒìŠ¤íŠ¸ ê²°ê³¼: ' + testResult.passed + 'ê°œ í†µê³¼, ' + testResult.failed + 'ê°œ ì‹¤íŒ¨';
            div.appendChild(title);

            testResult.results.forEach(function(result) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                if (result.passed) {
                    item.innerHTML = '<span class="test-pass">âœ“</span> ' + result.name;
                } else {
                    item.innerHTML = '<span class="test-fail">âœ—</span> ' + result.name + 
                                   ' <small>(' + result.reason + ')</small>';
                }
                
                div.appendChild(item);
            });

            container.appendChild(div);
        }

        // =========================================
        // DOMContentLoaded ì´ë²¤íŠ¸ - ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        // =========================================
        document.addEventListener('DOMContentLoaded', function() {
            // ë„ì›€ë§ í† ê¸€ ì´ë²¤íŠ¸
            const helpToggle = document.querySelector('.help-toggle');
            const helpContent = document.querySelector('.help-content');
            
            if (helpToggle && helpContent) {
                helpToggle.addEventListener('click', function() {
                    helpToggle.classList.toggle('expanded');
                    helpContent.classList.toggle('expanded');
                });
            }

            // íƒ­ ì „í™˜ ì´ë²¤íŠ¸
            document.querySelectorAll('.tab-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    // ëª¨ë“  íƒ­ ë²„íŠ¼ì—ì„œ active ì œê±°
                    document.querySelectorAll('.tab-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    // í´ë¦­ëœ ë²„íŠ¼ì— active ì¶”ê°€
                    this.classList.add('active');

                    // ëª¨ë“  íƒ­ ì½˜í…ì¸  ìˆ¨ê¸°ê¸°
                    document.querySelectorAll('.tab-content').forEach(function(content) {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });

                    // ì„ íƒëœ íƒ­ ì½˜í…ì¸  í‘œì‹œ
                    const tabId = this.getAttribute('data-tab') + '-tab';
                    const selectedTab = document.getElementById(tabId);
                    selectedTab.classList.add('active');
                    selectedTab.style.display = 'block';
                });
            });

            // ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('sample-btn').addEventListener('click', function() {
                // XML ê·œê²© ìƒ˜í”Œ ì„¤ì •
                const sampleXml = `<packet id="ì†¡ê¸ˆì „ë¬¸" default=" ">
  <col id="í—¤ë”ì‹œì‘" type="X" size="6" />
  <col id="ê±°ë˜êµ¬ë¶„" type="X" size="2" />
  <col id="ê³„ì¢Œë²ˆí˜¸" type="N" size="12" />
  <col id="ì†¡ê¸ˆì•¡" type="N" size="15" />
  <col id="ë°›ëŠ”ì‚¬ëŒ" type="X" size="20" />
</packet>`;
                
                // í†µì „ë¬¸ ìƒ˜í”Œ ì„¤ì • (ì •í™•íˆ 55ì)
                const sampleTelegram = 'HEADER01123456789012000000000100000í™ê¸¸ë™              ';
                
                document.getElementById('xml-input').value = sampleXml;
                document.getElementById('telegram-input').value = sampleTelegram;
            });

            // íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('parse-btn').addEventListener('click', function() {
                // 1. xml-inputê³¼ telegram-input ê°’ ê°€ì ¸ì˜¤ê¸°
                const xmlInput = document.getElementById('xml-input').value;
                const telegramInput = document.getElementById('telegram-input').value;

                // 2. ë‘˜ ë‹¤ trim()í•´ì„œ ë¹ˆ ë¬¸ìì—´ì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                if (xmlInput.trim() === '' || telegramInput.trim() === '') {
                    displayError("ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”");
                    return;
                }

                // 3. parseXMLSpec í˜¸ì¶œ, ê²°ê³¼ê°€ nullì´ë©´ ì—ëŸ¬ í‘œì‹œ í›„ return
                const xmlSpec = parseXMLSpec(xmlInput);
                if (xmlSpec === null) {
                    displayError("XML íŒŒì‹± ì‹¤íŒ¨: í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”");
                    return;
                }

                // 4. parseTelegram í˜¸ì¶œ
                const parsedData = parseTelegram(telegramInput, xmlSpec);

                // 5. displayResults í˜¸ì¶œ
                displayResults(parsedData);
            });

            // ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('clear-btn').addEventListener('click', function() {
                document.getElementById('xml-input').value = '';
                document.getElementById('telegram-input').value = '';
                document.getElementById('result-container').innerHTML = '';
            });

            // êµ¬ì¡°ì²´ ìƒ˜í”Œ ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-sample-btn').addEventListener('click', function() {
                // C êµ¬ì¡°ì²´ ì •ì˜ ìƒ˜í”Œ (DHF_H, DHF_D, DHF_T)
                const sampleStructDef = `typedef struct{
  char record_kubun[1];
  char bank_cd[2];
  char cust_id[7];
} DHF_H;

typedef struct{
  char record_kubun[1];
  char acno[16];
  char amt[20];
} DHF_D;

typedef struct{
  char record_kubun[1];
  char tot_cnt[10];
  char tot_amt[20];
} DHF_T;`;

                // í†µ ë°ì´í„° ìƒ˜í”Œ (êµ¬ì¡°ì²´ ê¸¸ì´ì— ë§ê²Œ ì¡°ì •)
                // DHF_H: 1+2+7 = 10ì
                // DHF_D: 1+16+20 = 37ì
                // DHF_T: 1+10+20 = 31ì
                const sampleData = `H881234567
D123456789012345600000000000000100000
D987654321098765400000000000000200000
T000000000200000000000000300000`;

                document.getElementById('struct-definitions').value = sampleStructDef;
                document.getElementById('struct-data').value = sampleData;
            });

            // êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-parse-btn').addEventListener('click', function() {
                // 1. struct-definitions ê°’ ê°€ì ¸ì˜¤ê¸°, trim
                const structDefInput = document.getElementById('struct-definitions').value.trim();
                
                // 2. struct-data ê°’ ê°€ì ¸ì˜¤ê¸°, trim
                const dataInput = document.getElementById('struct-data').value.trim();

                // 3. ë‘˜ ë‹¤ ë¹„ì–´ìˆìœ¼ë©´ displayError í˜¸ì¶œ
                if (structDefInput === '' || dataInput === '') {
                    displayError('ì…ë ¥ê°’ì„ í™•ì¸í•˜ì„¸ìš”', 'struct-result-container');
                    return;
                }

                // 4. parseStructDefinitions í˜¸ì¶œ, nullì´ë©´ displayError
                const structDefs = parseStructDefinitions(structDefInput);
                if (structDefs === null) {
                    displayError('êµ¬ì¡°ì²´ íŒŒì‹± ì‹¤íŒ¨', 'struct-result-container');
                    return;
                }

                // 5. íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜ ì½˜ì†” ì¶œë ¥
                console.log('íŒŒì‹±ëœ êµ¬ì¡°ì²´ ê°œìˆ˜: ' + structDefs.length);

                // 6. parseStructData í˜¸ì¶œ
                const parsedData = parseStructData(dataInput, structDefs);

                // 7. displayStructResults í˜¸ì¶œ (structDefs ì „ë‹¬)
                displayStructResults(parsedData, structDefs);
            });

            // êµ¬ì¡°ì²´ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.getElementById('struct-clear-btn').addEventListener('click', function() {
                document.getElementById('struct-definitions').value = '';
                document.getElementById('struct-data').value = '';
                document.getElementById('struct-result-container').innerHTML = '';
            });

            // í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ë²„íŠ¼ì´ ì¡´ì¬í•  ê²½ìš°ì—ë§Œ)
            const runTestsBtn = document.getElementById('run-tests-btn');
            if (runTestsBtn) {
                runTestsBtn.addEventListener('click', function() {
                    const testResult = runTests();
                    displayTestResults(testResult);
                });
            }

            // ë³µì‚¬ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ì´ë²¤íŠ¸ ìœ„ì„ ì‚¬ìš©)
            document.getElementById('struct-result-container').addEventListener('click', function(e) {
                // í´ë¦­ëœ ìš”ì†Œê°€ ë³µì‚¬ ë²„íŠ¼ì¸ì§€ í™•ì¸
                if (!e.target.classList.contains('copy-result-btn')) {
                    return;
                }

                const btn = e.target;
                const lineNum = btn.getAttribute('data-line');

                // í•´ë‹¹ ë¼ì¸ì˜ ê·¸ë£¹ ì°¾ê¸°
                const groupDiv = btn.closest('.struct-result-group');
                if (!groupDiv) {
                    return;
                }

                // í…Œì´ë¸”ì˜ tbodyì—ì„œ ëª¨ë“  í–‰ ê°€ì ¸ì˜¤ê¸°
                const tbody = groupDiv.querySelector('tbody');
                if (!tbody) {
                    return;
                }

                const rows = tbody.querySelectorAll('tr');
                
                // TSV í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (í•„ë“œëª…\tê°’)
                const tsvLines = [];
                rows.forEach(function(row) {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 6) {
                        const fieldName = cells[1].textContent;  // í•„ë“œëª…
                        const value = cells[5].textContent;       // ê°’
                        tsvLines.push(fieldName + '\t' + value);
                    }
                });

                const tsvText = tsvLines.join('\n');

                // í´ë¦½ë³´ë“œì— ë³µì‚¬
                navigator.clipboard.writeText(tsvText).then(function() {
                    // ë³µì‚¬ ì„±ê³µ ì‹œ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì„ì‹œ ë³€ê²½
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ“ ë³µì‚¬ë¨';
                    
                    // 2ì´ˆ í›„ ì›ë˜ í…ìŠ¤íŠ¸ë¡œ ë³µì›
                    setTimeout(function() {
                        btn.textContent = originalText;
                    }, 2000);
                }).catch(function(err) {
                    console.error('í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:', err);
                    alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                });
            });
        });
    </script>
</body>
</html>
